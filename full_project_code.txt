--- FILE: monitor.py ---
import os
import time
import psutil
import sys
import requests
from pathlib import Path
from dotenv import load_dotenv

sys.path.append(str(Path(__file__).parent.resolve()))
from core.logging_config import setup_logging

BASE_DIR = Path(__file__).parent.resolve()
load_dotenv(BASE_DIR / ".env")

logger = setup_logging("MONITOR")

FROZEN_THRESHOLD_SECONDS = 90
CHECK_INTERVAL_SECONDS = 60

PID_FILE = BASE_DIR / "bot.pid"
HEARTBEAT_FILE = BASE_DIR / "heartbeat.txt"
PING_FILE = BASE_DIR / "ping.txt"

def get_bot_pid():
    try:
        with open(PID_FILE, "r") as f:
            return int(f.read().strip())
    except (FileNotFoundError, ValueError):
        return None

def kill_process(pid: int):
    try:
        process = psutil.Process(pid)
        logger.warning(f"Process {pid} found. Attempting to terminate gracefully.")
        process.terminate()
        try:
            process.wait(timeout=5)
            logger.info(f"Process {pid} terminated gracefully.")
        except psutil.TimeoutExpired:
            logger.warning(f"Graceful termination failed. Forcing kill on process {pid}.")
            process.kill()
            logger.info(f"Process {pid} killed.")
    except psutil.NoSuchProcess:
        logger.warning(f"Process {pid} not found (already terminated).")
    except psutil.Error as e:
        logger.error(f"Failed to terminate process {pid} with psutil error: {e}", exc_info=True)
    except Exception as e:
        logger.error(f"An unexpected error occurred while terminating process {pid}: {e}", exc_info=True)


def cleanup_files():
    for f in [PID_FILE, HEARTBEAT_FILE, PING_FILE]:
        if f.exists():
            try:
                os.remove(f)
            except (OSError, PermissionError) as e:
                logger.error(f"Failed to remove file {f}: {e}")
    logger.info("State files cleaned up.")

def send_ping_to_bot():
    url = "http://localhost:8888/ping"
    try:
        response = requests.get(url, timeout=5)
        response.raise_for_status()
        logger.info(f"HTTP Ping to {url} successful (status {response.status_code}).")
        return True
    except requests.RequestException as e:
        logger.error(f"Network error sending HTTP ping to {url}: {e}")
        return False

if __name__ == "__main__":
    logger.info("Health Monitor started.")
    while True:
        try:
            time.sleep(CHECK_INTERVAL_SECONDS)

            bot_pid = get_bot_pid()
            if not bot_pid or not psutil.pid_exists(bot_pid):
                logger.warning(f"Bot is not running (PID {bot_pid} not found). Skipping check.")
                continue

            if HEARTBEAT_FILE.exists():
                try:
                    time_since_heartbeat = time.time() - HEARTBEAT_FILE.stat().st_mtime
                    if time_since_heartbeat > FROZEN_THRESHOLD_SECONDS:
                        logger.critical(
                            f"PROCESS HEARTBEAT LOST! Last signal was {time_since_heartbeat:.0f}s ago. Killing process {bot_pid}."
                        )
                        kill_process(bot_pid)
                        cleanup_files()
                        continue
                except FileNotFoundError:
                    logger.warning("Heartbeat file disappeared during check. Race condition?")
            else:
                 logger.warning("Heartbeat file (heartbeat.txt) not found. Bot might have just started.")

            logger.info("Performing functional check via HTTP /ping...")
            if not send_ping_to_bot():
                logger.critical(f"BOT IS UNRESPONSIVE! HTTP server did not respond. Killing process {bot_pid}.")
                kill_process(bot_pid)
                cleanup_files()
            else:
                logger.info("‚úÖ HEALTH CHECK PASSED. Bot is responsive.")

        except KeyboardInterrupt:
            logger.info("Health Monitor stopped by user.")
            sys.exit(0)
        except Exception as e:
            logger.error(f"Unexpected error in monitor loop: {e}", exc_info=True)
            time.sleep(CHECK_INTERVAL_SECONDS)

--- FILE: models.py ---
from enum import Enum, auto

class OnboardingState(Enum):
    POSITION = auto()
    AWAIT_OTHER_POSITION = auto()
    IMPRESSION = auto()
    INTEREST_RATING = auto()
    INTEREST_REASON = auto()

class OnboardingFollowupState(Enum):
    AWAITING_STATUS = auto()
    AWAITING_LEAVING_REASON = auto()
    AWAITING_FURTHER_REASON = auto()

class ExitState(Enum):
    RESTAURANT = auto()
    POSITION = auto()
    DURATION = auto()
    LEADERSHIP = auto()
    TRAINING = auto()
    FEEDBACK = auto()
    AWAITING_REASON = auto()
    AWAITING_IMPROVEMENT = auto()
    AWAITING_COMMENTS = auto()

class ClimateState(Enum):
    AWAIT_EMPLOYMENT_STATUS = auto()
    RESTAURANT = auto()
    GENDER = auto()
    POSITION = auto()
    RECOMMEND = auto()
    RECOMMEND_REASON = auto()
    EXPECTATIONS = auto()
    BEST_ABILITY = auto()
    PRAISE = auto()
    DEVELOPMENT_CARE = auto()
    OPINION = auto()
    COLLEAGUE_SUCCESS = auto()
    MISSION = auto()
    IMPORTANCE = auto()
    GROWTH_OPPORTUNITY = auto()
    SUPPORT = auto()
    FRIENDS = auto()
    TEAM_PART = auto()

class RecruitmentState(Enum):
    FULL_NAME = auto()
    AGE = auto()
    FAMILY_INFO = auto()
    VACANCY_SOURCE = auto()
    AWAIT_MULTI_VACANCY = auto()
    AWAIT_OTHER_VACANCY = auto()
    REASON_FOR_CHOICE = auto()
    AWAIT_MULTI_RESTAURANT = auto()
    KNOWS_MARCELLIS = auto()
    NIGHT_SHIFTS = auto()
    WEEKLY_SHIFTS = auto()
    MOBILE_PHONE = auto()
    SOCIAL_LINK = auto()
    CITY = auto()
    ADDRESS = auto()
    AWAIT_CHECKPOINT_1 = auto()
    MARITAL_STATUS = auto()
    CHILDREN = auto()
    HEALTH_ASSESSMENT = auto()
    ATTITUDE_TO_APPEARANCE = auto()
    EDUCATION_NAME = auto()
    GRADUATION_YEAR = auto()
    COURSE = auto()
    EDUCATION_FORM = auto()
    AWAIT_ADDITIONAL_COURSES_DECISION = auto()
    ADDITIONAL_COURSES = auto()
    EXPERIENCE_DURATION = auto()
    AWAIT_EXPERIENCE_DETAILS = auto()
    EXPECTED_INCOME = auto()
    REASON_FOR_LEAVING = auto()
    PREVIOUS_JOBS_COUNT = auto()
    AWAIT_CHECKPOINT_2 = auto()
    ATTITUDE_TO_SPORT = auto()
    LIFE_VALUES = auto()
    LIFE_WEAKNESSES = auto()
    LIFE_GOAL = auto()
    READING_NOW = auto()
    JUDGED_BEFORE = auto()

class ManagerRegistrationState(Enum):
    CHOOSE_RESTAURANT = auto()
    AWAIT_FULL_NAME = auto()

class AdminState(Enum):
    MENU = auto()
    MANAGE_MANAGERS = auto()
    MANAGE_EMPLOYEES = auto()
    CHOOSE_EMPLOYEE_RESTAURANT = auto()
    LIST_EMPLOYEES_PAGINATED = auto()
    AWAIT_REMOVAL_ID = auto()
    CHOOSE_ADD_RESTAURANT = auto()
    AWAIT_ADD_ID = auto()
    BROADCAST_CONFIRM = auto()
    AWAIT_CANDIDATE_ACTION = auto()

class FeedbackState(Enum):
    AWAITING_FEEDBACK = auto()

class ManagerFeedbackState(Enum):
    AWAITING_DECISION = auto()
    AWAITING_REASON = auto()
    AWAITING_SHIFT_DATE = auto()
    AWAITING_MANUAL_SHIFT_DATE = auto()
    AWAITING_SHIFT_TIME = auto()
    AWAITING_COMMENT = auto()

class CandidateFeedbackState(Enum):
    AWAITING_IMPRESSION = auto()
    AWAITING_CONDITIONS_MET = auto()
    AWAITING_REQUIREMENTS_CLEAR = auto()
    AWAITING_ADDITIONAL_COMMENTS = auto()

class MainMenuState(Enum):
    MAIN = auto()
    AWAITING_FEEDBACK_CHOICE = auto()
    ADMIN_PANEL = auto()

--- FILE: watchdog.py ---
import subprocess
import time
import sys
import os
from pathlib import Path

sys.path.append(str(Path(__file__).parent.resolve()))
from core.logging_config import setup_logging

logger = setup_logging("WATCHDOG")

script_dir = Path(__file__).parent.resolve()
main_script_path = script_dir / "main.py"

if not main_script_path.is_file():
    logger.critical(f"Main bot script not found at: {main_script_path}")
    sys.exit(1)

python_executable = sys.executable

RESTART_INTERVAL_SECONDS = 604800

logger.info(f"Using Python: {python_executable}")
logger.info(f"Path to bot script: {main_script_path}")
logger.info(f"Watchdog starting. Bot will be restarted every {RESTART_INTERVAL_SECONDS / 3600:.1f} hours.")

while True:
    try:
        logger.info("Starting bot process...")
        start_time = time.time()

        process = subprocess.Popen(
            [python_executable, str(main_script_path)],
            env=os.environ.copy()
        )

        while True:
            return_code = process.poll()
            if return_code is not None:
                logger.warning(f"Bot process exited with code: {return_code}. Restarting in 5 seconds...")
                time.sleep(5)
                break

            uptime = time.time() - start_time
            if uptime > RESTART_INTERVAL_SECONDS:
                logger.info(f"Planned restart: bot has been running for {uptime:.0f} seconds. Terminating...")
                process.terminate()
                try:
                    process.wait(timeout=10)
                    logger.info("Bot terminated gracefully for planned restart.")
                except subprocess.TimeoutExpired:
                    logger.warning("Graceful termination failed during planned restart. Forcing kill.")
                    process.kill()
                break

            time.sleep(1)

    except KeyboardInterrupt:
        logger.info("KeyboardInterrupt received. Shutting down watchdog...")
        if 'process' in locals() and process.poll() is None:
            logger.info("Terminating bot process...")
            process.terminate()
            try:
                process.wait(timeout=5)
            except subprocess.TimeoutExpired:
                logger.warning("Bot did not terminate gracefully, killing.")
                process.kill()
        break

    except (OSError, subprocess.SubprocessError) as e:
        logger.error(f"Error in watchdog loop regarding subprocess: {e}", exc_info=True)
        logger.warning("Restarting in 15 seconds after error...")
        time.sleep(15)
        continue
    except Exception as e:
        logger.error(f"Unexpected error in watchdog loop: {e}", exc_info=True)
        logger.warning("Restarting in 15 seconds after error...")
        time.sleep(15)
        continue

    time.sleep(1)

logger.info("Watchdog has been shut down.")

--- FILE: requirements.txt ---
aiohappyeyeballs==2.6.1
aiohttp==3.12.13
aiosignal==1.3.2
aiosqlite==0.21.0
anyio==4.8.0
APScheduler==3.11.0
attrs==25.3.0
cachetools==5.5.1
certifi==2025.7.14
charset-normalizer==3.4.1
class-registry==2.1.2
filters==1.3.2
frozenlist==1.7.0
google-api-core==2.25.1
google-api-python-client==2.176.0
google-auth==2.38.0
google-auth-httplib2==0.2.0
google-auth-oauthlib==1.2.1
googleapis-common-protos==1.70.0
gspread==6.0.2
gspread_asyncio==2.0.0
h11==0.14.0
httpcore==1.0.7
httplib2==0.22.0
httpx==0.28.1
idna==3.10
multidict==6.4.4
numpy==2.2.2
oauthlib==3.2.2
pandas==2.2.3
propcache==0.3.2
proto-plus==1.26.1
protobuf==6.31.1
psutil==7.0.0
pyasn1==0.6.1
pyasn1_modules==0.4.1
pyparsing==3.2.3
pytest-win32consoletitle==0.1.2
python-dateutil==2.9.0.post0
python-dotenv==1.1.0
python-telegram-bot==22.0
pytz==2025.1
regex==2024.11.6
requests==2.32.3
requests-oauthlib==2.0.0
rsa==4.9
six==1.17.0
sniffio==1.3.1
StrEnum==0.4.15
tenacity==9.0.0
typing_extensions==4.12.2
tzdata==2025.1
tzlocal==5.3
uritemplate==4.2.0
urllib3==2.3.0
watchdog==5.0.3
Win32Security==2.1.0
yarl==1.20.1


--- FILE: package_project.py ---
import os
from pathlib import Path

# --- –ù–ê–°–¢–†–û–ô–ö–ò ---
# –ü–∞–ø–∫–∞, –≤ –∫–æ—Ç–æ—Ä–æ–π –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤–∞—à –ø—Ä–æ–µ–∫—Ç
ROOT_DIRECTORY = Path(__file__).parent

# –ò–º—è —Ñ–∞–π–ª–∞, –≤ –∫–æ—Ç–æ—Ä—ã–π –±—É–¥–µ—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω –≤–µ—Å—å –∫–æ–¥
OUTPUT_FILE = "full_project_code.txt"

# –ü–∞–ø–∫–∏, –∫–æ—Ç–æ—Ä—ã–µ –Ω—É–∂–Ω–æ –∏—Å–∫–ª—é—á–∏—Ç—å –∏–∑ —Å–±–æ—Ä–∫–∏ (–æ—á–µ–Ω—å –≤–∞–∂–Ω–æ –¥–ª—è venv!)
EXCLUDE_DIRS = {
    ".venv",
    "venv",
    "__pycache__",
    ".git",
    ".idea",
    "bot_database.sqlite-journal"  # –ò—Å–∫–ª—é—á–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã –ë–î
}

# –†–∞—Å—à–∏—Ä–µ–Ω–∏—è —Ñ–∞–π–ª–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ –Ω—É–∂–Ω–æ –≤–∫–ª—é—á–∏—Ç—å
INCLUDE_EXTENSIONS = {
    ".py",
    ".txt",
    ".env",
    ".json"
}


# ------------------

def package_project():
    """–°–æ–±–∏—Ä–∞–µ—Ç –≤—Å–µ —Ç–µ–∫—Å—Ç–æ–≤—ã–µ —Ñ–∞–π–ª—ã –ø—Ä–æ–µ–∫—Ç–∞ –≤ –æ–¥–∏–Ω –±–æ–ª—å—à–æ–π —Ç–µ–∫—Å—Ç–æ–≤—ã–π —Ñ–∞–π–ª."""
    full_code = []

    print(f"–ù–∞—á–∏–Ω–∞—é —Å–±–æ—Ä–∫—É –ø—Ä–æ–µ–∫—Ç–∞ –∏–∑ –ø–∞–ø–∫–∏: {ROOT_DIRECTORY}")

    # os.walk —Ä–µ–∫—É—Ä—Å–∏–≤–Ω–æ –æ–±–æ–π–¥–µ—Ç –≤—Å–µ –ø–∞–ø–∫–∏ –∏ —Ñ–∞–π–ª—ã
    for dirpath, dirnames, filenames in os.walk(ROOT_DIRECTORY):

        # –£–¥–∞–ª—è–µ–º –∏–∑ —Å–ø–∏—Å–∫–∞ –ø–∞–ø–æ–∫ —Ç–µ, –∫–æ—Ç–æ—Ä—ã–µ –Ω—É–∂–Ω–æ –∏—Å–∫–ª—é—á–∏—Ç—å
        # –≠—Ç–æ –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ—Ç –æ–±—Ö–æ–¥ —ç—Ç–∏—Ö –ø–∞–ø–æ–∫ os.walk
        dirnames[:] = [d for d in dirnames if d not in EXCLUDE_DIRS]

        # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –ø—É—Ç—å –≤ –æ–±—ä–µ–∫—Ç Path –¥–ª—è —É–¥–æ–±—Å—Ç–≤–∞
        current_path = Path(dirpath)

        for filename in filenames:
            # –°–æ–±–∏—Ä–∞–µ–º –ø–æ–ª–Ω—ã–π –ø—É—Ç—å –∫ —Ñ–∞–π–ª—É
            file_path = current_path / filename

            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ —Ñ–∞–π–ª–∞
            if file_path.suffix in INCLUDE_EXTENSIONS:
                try:
                    with open(file_path, 'r', encoding='utf-8') as f:
                        content = f.read()

                        # –ü–æ–ª—É—á–∞–µ–º –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–π –ø—É—Ç—å –¥–ª—è –∑–∞–≥–æ–ª–æ–≤–∫–∞
                        relative_path = file_path.relative_to(ROOT_DIRECTORY)

                        # –§–æ—Ä–º–∏—Ä—É–µ–º –∫—Ä–∞—Å–∏–≤—ã–π –∑–∞–≥–æ–ª–æ–≤–æ–∫
                        header = f"--- FILE: {str(relative_path).replace(os.sep, '/')} ---\n"

                        # –î–æ–±–∞–≤–ª—è–µ–º –∑–∞–≥–æ–ª–æ–≤–æ–∫ –∏ —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –≤ –Ω–∞—à —Å–ø–∏—Å–æ–∫
                        full_code.append(header)
                        full_code.append(content)
                        full_code.append("\n\n")  # –î–æ–±–∞–≤–ª—è–µ–º –æ—Ç—Å—Ç—É–ø –º–µ–∂–¥—É —Ñ–∞–π–ª–∞–º–∏

                        print(f"  [+] –î–æ–±–∞–≤–ª–µ–Ω —Ñ–∞–π–ª: {relative_path}")

                except Exception as e:
                    print(f"  [!] –û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è —Ñ–∞–π–ª–∞ {file_path}: {e}")

    # –ó–∞–ø–∏—Å—ã–≤–∞–µ–º –≤—Å–µ —Å–æ–±—Ä–∞–Ω–Ω–æ–µ –≤ –æ–¥–∏–Ω —Ñ–∞–π–ª
    try:
        with open(ROOT_DIRECTORY / OUTPUT_FILE, 'w', encoding='utf-8') as f:
            f.writelines(full_code)
        print(f"\n‚úÖ –ü—Ä–æ–µ–∫—Ç —É—Å–ø–µ—à–Ω–æ —Å–æ–±—Ä–∞–Ω –≤ —Ñ–∞–π–ª: {OUTPUT_FILE}")
    except Exception as e:
        print(f"\n‚ùå –û—à–∏–±–∫–∞ –∑–∞–ø–∏—Å–∏ –≤ –∏—Ç–æ–≥–æ–≤—ã–π —Ñ–∞–π–ª: {e}")


if __name__ == "__main__":
    package_project()

--- FILE: main.py ---
import asyncio
import logging
import os
import time
import psutil
from datetime import timedelta

from telegram import Update
from telegram.ext import (
    Application,
    PicklePersistence,
    CommandHandler,
    CallbackQueryHandler,
    ChatMemberHandler,
    TypeHandler,
    ConversationHandler,
    JobQueue,
    MessageHandler,
    filters,
    ContextTypes,
)
from aiohttp import web

from models import AdminState, MainMenuState, FeedbackState, ManagerFeedbackState
from core import settings, database, g_sheets, monitoring
from core.logging_config import setup_logging
from handlers.common import error_handler, update_timestamp_handler, cancel
from handlers.recruitment import recruitment_conversation_handler, show_full_recruitment_report, \
    send_candidate_check_info
from handlers.onboarding import onboarding_conversation_handler
from handlers.exit_interview import (
    exit_interview_conversation_handler,
    chat_member_handler,
    quit_clarification_handler
)
from handlers.climate_survey import climate_survey_conversation_handler
from handlers.bot_feedback import feedback_submission_handler
from handlers.manager import manager_registration_handler, handle_manager_approval
from handlers.admin import (
    list_managers, add_manager_start, remove_manager_start,
    broadcast_climate_start, admin_panel_start, add_restaurant_chosen,
    add_id_received, handle_broadcast_confirmation,
    show_stats, admin_list_pending_candidates, remove_manager_selected,
    handle_admin_delete_candidate, handle_admin_delete_confirmation,
    manage_employees_start, toggle_employee_status_handler, manage_managers_start,
    show_employees_paginated, handle_candidate_action_menu
)
from handlers.feedback import (
    candidate_feedback_conversation_handler,
    onboarding_followup_conversation_handler,
)
from handlers.main_menu import start, handle_manager_feedback_button, handle_feedback_candidate_selection, \
    receive_and_forward_feedback, start_feedback
from handlers.manager_feedback_flow import (
    start_manager_feedback_flow,
    decision_received,
    shift_date_received,
    manual_shift_date_received,
    shift_time_received,
    comment_received,
    skip_comment,
    process_manager_feedback
)
from utils.helpers import send_or_edit_message

logger = setup_logging(__name__)

background_tasks = set()
stop_event = asyncio.Event()


async def cleanup_bot_data(context: ContextTypes.DEFAULT_TYPE):
    now = time.time()
    bot_data = context.bot_data
    cleanup_count = 0
    if 'candidate_check_info' in bot_data:
        thirty_days_ago = now - timedelta(days=30).total_seconds()
        keys_to_delete = [
            cid for cid, data in bot_data['candidate_check_info'].items()
            if data.get('timestamp', 0) < thirty_days_ago
        ]
        for key in keys_to_delete:
            del bot_data['candidate_check_info'][key]
            cleanup_count += 1

    if cleanup_count > 0:
        logger.info(f"Bot data cleanup: Removed {cleanup_count} old entries.")


async def post_init(application: Application):
    global background_tasks, stop_event
    application.bot_data.setdefault("last_telegram_update_ts", time.time())

    if not all([settings.TOKEN, settings.GOOGLE_CREDENTIALS_JSON, settings.SPREADSHEET_ID, settings.ADMIN_IDS]):
        logger.critical("CRITICAL ERROR: One or more required environment variables are missing or invalid.")

    agc_manager = await g_sheets.init_google_sheets_client()
    if not agc_manager:
        logger.warning("Google Sheets client failed to initialize. Recording to sheets is disabled.")

    loop = asyncio.get_running_loop()

    if agc_manager:
        writer_task = loop.create_task(
            g_sheets.batch_writer_task(application, stop_event, agc_manager, application.bot_data)
        )
        background_tasks.add(writer_task)
        writer_task.add_done_callback(background_tasks.discard)

    if application.job_queue:
        application.job_queue.run_repeating(
            cleanup_bot_data,
            interval=timedelta(hours=24),
            first=timedelta(seconds=10),
            name="cleanup_bot_data"
        )
        logger.info("Scheduled periodic bot_data cleanup.")

    logger.info(f"Bot post-initialization complete. {len(background_tasks)} background tasks started.")


async def on_shutdown(application: Application):
    global background_tasks, stop_event
    logger.info("--- Initiating graceful shutdown sequence ---")
    if not stop_event.is_set():
        stop_event.set()
    if background_tasks:
        logger.info(f"Cancelling {len(background_tasks)} background tasks...")
        for task in list(background_tasks):
            if not task.done():
                task.cancel()
        try:
            await asyncio.gather(*background_tasks, return_exceptions=True)
            logger.info("All background tasks cancelled.")
        except asyncio.CancelledError:
            logger.info("Gather was cancelled, this is expected.")
        background_tasks.clear()
    if os.path.exists(settings.PID_FILE):
        try:
            os.remove(settings.PID_FILE)
            logger.info(f"PID file {settings.PID_FILE} removed.")
        except OSError:
            pass
    logger.info("--- Bot shutdown complete ---")


async def reason_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    context.user_data["feedback_reason"] = update.message.text
    await send_or_edit_message(update, context, "–°–ø–∞—Å–∏–±–æ, —Ç–≤–æ—è –æ–±—Ä–∞—Ç–Ω–∞—è —Å–≤—è–∑—å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞! üôè")
    await process_manager_feedback(context, update.effective_user)
    return ConversationHandler.END


async def main() -> None:
    logger.info("--- Bot Starting Up ---")

    await database.init_db()
    logger.info("Database initialization complete.")

    try:
        pid = os.getpid()
        with open(settings.PID_FILE, "w") as f:
            f.write(str(pid))
        logger.info(f"Bot process started with PID: {pid}.")
    except Exception as e:
        logger.critical(f"Could not write PID file '{settings.PID_FILE}': {e}.")
        return

    persistence = PicklePersistence(filepath=settings.PERSISTENCE_FILE)
    application = (
        Application.builder()
        .token(settings.TOKEN)
        .persistence(persistence)
        .post_init(post_init)
        .post_shutdown(on_shutdown)
        .read_timeout(30).write_timeout(30).connect_timeout(30)
        .job_queue(JobQueue())
        .build()
    )

    application.add_handler(TypeHandler(Update, update_timestamp_handler), group=-1)
    application.add_handler(
        CallbackQueryHandler(handle_manager_approval,
                             pattern=f"^{settings.CALLBACK_MGR_APPROVE_PREFIX}|^{settings.CALLBACK_MGR_REJECT_PREFIX}")
    )
    application.add_handler(CallbackQueryHandler(show_full_recruitment_report, pattern=f"^show_full_report_"))
    application.add_handler(CallbackQueryHandler(send_candidate_check_info, pattern=f"^check_candidate_"))
    application.add_handler(CallbackQueryHandler(handle_admin_delete_confirmation, pattern="^cand_del_confirm_"))
    application.add_handler(chat_member_handler)
    application.add_handler(quit_clarification_handler)

    application.add_handler(recruitment_conversation_handler)
    application.add_handler(onboarding_conversation_handler)
    application.add_handler(candidate_feedback_conversation_handler)
    application.add_handler(onboarding_followup_conversation_handler)
    application.add_handler(manager_registration_handler)
    application.add_handler(climate_survey_conversation_handler)
    application.add_handler(exit_interview_conversation_handler)
    application.add_handler(feedback_submission_handler)

    admin_conversation_handler = ConversationHandler(
        entry_points=[
            CommandHandler("start", admin_panel_start, filters=filters.User(user_id=settings.ADMIN_IDS)),
            CommandHandler("admin", admin_panel_start, filters=filters.User(user_id=settings.ADMIN_IDS)),
            CallbackQueryHandler(admin_panel_start, pattern=f"^{settings.CALLBACK_ADMIN_BACK}$")
        ],
        states={
            AdminState.MENU: [
                CallbackQueryHandler(manage_managers_start, pattern="admin_manage_managers"),
                CallbackQueryHandler(manage_employees_start, pattern="admin_manage_employees"),
                CallbackQueryHandler(admin_list_pending_candidates, pattern="admin_pending_candidates"),
                CallbackQueryHandler(broadcast_climate_start, pattern="admin_broadcast_climate_start"),
                CallbackQueryHandler(show_stats, pattern="admin_stats"),
            ],
            AdminState.MANAGE_MANAGERS: [
                CallbackQueryHandler(add_manager_start, pattern="admin_add_manager_start"),
                CallbackQueryHandler(remove_manager_start, pattern="admin_remove_manager_start"),
                CallbackQueryHandler(list_managers, pattern="admin_list_managers"),
                CallbackQueryHandler(admin_panel_start, pattern=settings.CALLBACK_ADMIN_BACK),
            ],
            AdminState.CHOOSE_EMPLOYEE_RESTAURANT: [
                CallbackQueryHandler(show_employees_paginated, pattern="^list_emp_res_"),
                CallbackQueryHandler(admin_panel_start, pattern=settings.CALLBACK_ADMIN_BACK),
            ],
            AdminState.LIST_EMPLOYEES_PAGINATED: [
                CallbackQueryHandler(toggle_employee_status_handler, pattern="^adm_tgl_emp_"),
                CallbackQueryHandler(show_employees_paginated, pattern="^list_emp_res_"),
                CallbackQueryHandler(manage_employees_start, pattern="admin_manage_employees"),
            ],
            AdminState.CHOOSE_ADD_RESTAURANT: [
                CallbackQueryHandler(add_restaurant_chosen, pattern="^res_"),
                CallbackQueryHandler(manage_managers_start, pattern="admin_manage_managers"),
            ],
            AdminState.AWAIT_ADD_ID: [
                MessageHandler(filters.TEXT & ~filters.COMMAND | filters.FORWARDED, add_id_received),
                CallbackQueryHandler(add_manager_start, pattern="admin_add_manager_start"),
            ],
            AdminState.AWAIT_REMOVAL_ID: [
                CallbackQueryHandler(remove_manager_selected, pattern="^admin_remove_mgr_"),
                CallbackQueryHandler(manage_managers_start, pattern="admin_manage_managers"),
            ],
            AdminState.BROADCAST_CONFIRM: [
                CallbackQueryHandler(handle_broadcast_confirmation,
                                     pattern=f"^(admin_broadcast_confirm|admin_broadcast_cancel)$"),
            ],
            AdminState.AWAIT_CANDIDATE_ACTION: [
                CallbackQueryHandler(handle_candidate_action_menu, pattern="^cand_act_"),
                CallbackQueryHandler(handle_admin_delete_candidate, pattern="^cand_del_"),
                CallbackQueryHandler(admin_list_pending_candidates, pattern="admin_pending_candidates")
            ]
        },
        fallbacks=[
            CommandHandler("cancel", cancel),
            CommandHandler("start", admin_panel_start, filters=filters.User(user_id=settings.ADMIN_IDS))
        ],
        persistent=True,
        name="admin_conv",
        per_message=False,
    )

    main_conversation_handler = ConversationHandler(
        entry_points=[
            CommandHandler("start", start, filters=~filters.User(user_id=settings.ADMIN_IDS)),
            CommandHandler("feedback", start_feedback),
            CallbackQueryHandler(start, pattern=f"^{settings.CALLBACK_GO_TO_MAIN_MENU}$"),
            MessageHandler(
                filters.TEXT & ~filters.COMMAND & filters.ChatType.PRIVATE & ~filters.User(user_id=settings.ADMIN_IDS),
                start_feedback),
        ],
        states={
            MainMenuState.MAIN: [
                CallbackQueryHandler(handle_manager_feedback_button, pattern="^manager_feedback$"),
                CallbackQueryHandler(start, pattern="^main_menu$"),
            ],
            MainMenuState.AWAITING_FEEDBACK_CHOICE: [
                CallbackQueryHandler(handle_feedback_candidate_selection, pattern="^fb_"),
                CallbackQueryHandler(start, pattern="^main_menu$"),
            ],
            FeedbackState.AWAITING_FEEDBACK: [
                MessageHandler(filters.TEXT & ~filters.COMMAND & filters.ChatType.PRIVATE, receive_and_forward_feedback)
            ],
            ManagerFeedbackState.AWAITING_DECISION: [
                CallbackQueryHandler(decision_received, pattern=f"^{settings.CALLBACK_MGR_FEEDBACK_PREFIX}")
            ],
            ManagerFeedbackState.AWAITING_REASON: [MessageHandler(filters.TEXT & ~filters.COMMAND, reason_received)],
            ManagerFeedbackState.AWAITING_SHIFT_DATE: [
                CallbackQueryHandler(shift_date_received, pattern="^shift_date_")
            ],
            ManagerFeedbackState.AWAITING_MANUAL_SHIFT_DATE: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, manual_shift_date_received)
            ],
            ManagerFeedbackState.AWAITING_SHIFT_TIME: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, shift_time_received)
            ],
            ManagerFeedbackState.AWAITING_COMMENT: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, comment_received),
                CallbackQueryHandler(skip_comment, pattern="^skip_comment$"),
                CommandHandler("skip", skip_comment),
            ],
        },
        fallbacks=[
            CommandHandler("cancel", cancel),
            CommandHandler("start", start, filters=~filters.User(user_id=settings.ADMIN_IDS))
        ],
        persistent=True,
        name="main_conversation_handler",
        per_message=False,
    )

    application.add_handler(admin_conversation_handler)
    application.add_handler(main_conversation_handler)
    application.add_error_handler(error_handler)

    logger.info("Starting bot polling...")

    await application.initialize()
    await application.start()
    await application.updater.start_polling(allowed_updates=Update.ALL_TYPES)

    await stop_event.wait()

    await application.updater.stop()
    await application.stop()
    await application.shutdown()


if __name__ == "__main__":
    try:
        asyncio.run(main())
    except (KeyboardInterrupt, SystemExit):
        logger.info("Bot stopped by user or system.")
    except Exception as e:
        logger.critical(f"Bot failed to run due to an unhandled exception: {e}", exc_info=True)

--- FILE: ping.txt ---
1756994692.770977

--- FILE: heartbeat.txt ---
1756994730.699946

--- FILE: core/g_sheets.py ---
import asyncio
import gspread
import gspread_asyncio
import html
import logging
import requests
import json
from collections import defaultdict
from tenacity import retry, stop_after_attempt, wait_exponential, retry_if_exception_type
from typing import List, Any, Tuple

from google.oauth2.service_account import Credentials
from telegram.ext import Application
from telegram.constants import ParseMode

from core import settings, database

logger = logging.getLogger(__name__)

GSPREAD_RETRY_ERRORS = (
    gspread.exceptions.APIError,
    requests.exceptions.ConnectionError,
    requests.exceptions.Timeout,
    requests.exceptions.RequestException,
    gspread.exceptions.GSpreadException,
    TimeoutError,
)

MAX_WRITE_ATTEMPTS = 3

retry_gspread_operation = retry(
    stop=stop_after_attempt(5),
    wait=wait_exponential(multiplier=1, min=10, max=60),
    retry=retry_if_exception_type(GSPREAD_RETRY_ERRORS),
    reraise=True,
    before_sleep=lambda retry_state: logger.warning(
        f"Retrying GSheets operation (attempt {retry_state.attempt_number}) due to: {retry_state.outcome.exception()}"
    )
)


async def init_google_sheets_client() -> gspread_asyncio.AsyncioGspreadClientManager | None:
    logger.info("Initializing Google Sheets client...")
    if not settings.GOOGLE_CREDENTIALS_JSON:
        logger.error("GSheets credentials not found in GOOGLE_CREDENTIALS_JSON env variable. Sheets will not work.")
        return None
    if not settings.SPREADSHEET_ID:
        logger.error("SPREADSHEET_ID is not set in .env file. Sheets will not work.")
        return None

    try:
        creds_json = json.loads(settings.GOOGLE_CREDENTIALS_JSON)

        scope = [
            "https://www.googleapis.com/auth/spreadsheets",
            "https://www.googleapis.com/auth/drive",
        ]

        creds = Credentials.from_service_account_info(creds_json, scopes=scope)

        agc_manager = gspread_asyncio.AsyncioGspreadClientManager(lambda: creds)
        client = await agc_manager.authorize()
        await client.open_by_key(settings.SPREADSHEET_ID)
        logger.info("Google Sheets client initialized and spreadsheet access verified.")
        return agc_manager
    except json.JSONDecodeError:
        logger.error("Failed to parse GOOGLE_CREDENTIALS_JSON. Make sure it's a valid JSON string.")
    except Exception as e:
        logger.error(f"Unexpected error initializing Google Sheets client: {e}", exc_info=True)
    return None


@retry_gspread_operation
async def append_rows_to_sheet(worksheet: gspread_asyncio.AsyncioGspreadWorksheet, data: List[List[Any]]):
    if not data:
        return
    await worksheet.append_rows(data, value_input_option='USER_ENTERED')
    logger.info(f"Successfully appended {len(data)} rows to sheet '{worksheet.title}'.")


async def process_batch_for_sheet(application: Application, agc_manager, sheet_name: str, items: List[dict]):
    item_ids = [item['id'] for item in items]
    data_to_write = [json.loads(item['data_json']) for item in items]

    try:
        agc = await agc_manager.authorize()
        spreadsheet = await agc.open_by_key(settings.SPREADSHEET_ID)
        worksheet = await spreadsheet.worksheet(sheet_name)
        await append_rows_to_sheet(worksheet, data_to_write)
        await database.mark_sheets_queue_items_processed(item_ids)
    except Exception as e:
        logger.error(f"Failed to write batch to '{sheet_name}': {e}. Incrementing attempts.", exc_info=True)
        await database.increment_sheets_queue_attempts(item_ids)

        failed_items_count = 0
        for item in items:
            if item['attempts'] + 1 >= MAX_WRITE_ATTEMPTS:
                failed_items_count += 1

        if failed_items_count > 0:
            message = (f"üö® <b>–ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –û–®–ò–ë–ö–ê GOOGLE SHEETS</b> üö®\n"
                       f"–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–ø–∏—Å–∞—Ç—å –¥–∞–Ω–Ω—ã–µ –≤ –ª–∏—Å—Ç <b>'{html.escape(sheet_name)}'</b> –ø–æ—Å–ª–µ {MAX_WRITE_ATTEMPTS} –ø–æ–ø—ã—Ç–æ–∫.\n"
                       f"<b>–û—à–∏–±–∫–∞:</b> <pre>{html.escape(str(e))[:1000]}</pre>\n"
                       f"‚ùóÔ∏è <b>{failed_items_count} –∑–∞–ø–∏—Å–µ–π –ø–æ–º–µ—á–µ–Ω—ã –∫–∞–∫ '–Ω–µ—É–¥–∞—á–Ω—ã–µ' –∏ –±–æ–ª—å—à–µ –Ω–µ –±—É–¥—É—Ç –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å—Å—è.</b> –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ë–î –∏ –ª–æ–≥–∏.")

            if settings.ADMIN_IDS:
                for admin_id in settings.ADMIN_IDS:
                    try:
                        await application.bot.send_message(admin_id, message, parse_mode=ParseMode.HTML)
                    except Exception as notify_err:
                        logger.error(f"Failed to notify admin {admin_id}: {notify_err}")


async def batch_writer_task(application: Application, stop_event: asyncio.Event, agc_manager, bot_data):
    logger.info("Batch writer task started.")

    async def perform_write():
        batch = await database.get_sheets_queue_batch()
        if not batch:
            return

        items_by_sheet = defaultdict(list)
        for item in batch:
            items_by_sheet[item['sheet_name']].append(item)

        for sheet_name, items in items_by_sheet.items():
            await process_batch_for_sheet(application, agc_manager, sheet_name, items)

    while not stop_event.is_set():
        try:
            await asyncio.wait_for(stop_event.wait(), timeout=settings.BATCH_INTERVAL)
        except asyncio.TimeoutError:
            await perform_write()
        except asyncio.CancelledError:
            break

    logger.info("Batch writer task stopping. Performing final write...")
    await perform_write()
    logger.info("Batch writer task finished.")

--- FILE: core/logging_config.py ---
import logging
import sys
from logging.handlers import TimedRotatingFileHandler
from pathlib import Path

LOG_DIR = Path(__file__).parent.parent / "logs"
LOG_DIR.mkdir(exist_ok=True)

LOG_FILE = LOG_DIR / "bot.log"


class InteractionAndErrorFilter(logging.Filter):
    def filter(self, record):
        is_interaction = record.name.startswith('handlers') or record.name == '__main__'
        is_error_level = record.levelno >= logging.WARNING
        return is_interaction or is_error_level


def setup_logging(name: str):
    return logging.getLogger(name)


formatter = logging.Formatter(
    '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
log_filter = InteractionAndErrorFilter()

file_handler = TimedRotatingFileHandler(
    LOG_FILE,
    when='W0',
    interval=1,
    backupCount=1,
    encoding='utf-8',
    delay=False
)
file_handler.setFormatter(formatter)
file_handler.addFilter(log_filter)

stream_handler = logging.StreamHandler(sys.stdout)
stream_handler.setFormatter(formatter)
stream_handler.addFilter(log_filter)

root_logger = logging.getLogger()
root_logger.setLevel(logging.INFO)

if root_logger.hasHandlers():
    root_logger.handlers.clear()

root_logger.addHandler(file_handler)
root_logger.addHandler(stream_handler)

logging.getLogger("httpx").setLevel(logging.WARNING)
logging.getLogger("googleapiclient.discovery_cache").setLevel(logging.ERROR)
logging.getLogger("apscheduler").setLevel(logging.WARNING)
logging.getLogger("aiohttp.access").setLevel(logging.WARNING)

--- FILE: core/monitoring.py ---
import asyncio
import logging
import time
import os
from datetime import datetime

from aiohttp import web
from telegram.ext import Application

from core import settings

logger = logging.getLogger(__name__)


async def handle_http_ping(request: web.Request) -> web.Response:
    try:
        with open(settings.PING_FILE, 'w') as f:
            f.write(str(time.time()))
        logger.info("HTTP PING HANDLED, ping.txt updated.")
        return web.Response(text="OK")
    except Exception as e:
        logger.error(f"HTTP PING: Failed to write ping file: {e}", exc_info=True)
        return web.Response(text="ERROR", status=500)


async def start_http_server(app: web.Application, stop_event: asyncio.Event):
    runner = web.AppRunner(app)
    await runner.setup()
    site = web.TCPSite(runner, '0.0.0.0', 8888)
    try:
        await site.start()
        logger.info("HTTP Health Check Server started at http://0.0.0.0:8888")
        await stop_event.wait()
    except Exception as e:
        logger.error(f"HTTP server failed to start or run: {e}")
    finally:
        logger.info("Stopping HTTP Health Check Server...")
        await runner.cleanup()
        logger.info("HTTP server cleanup complete.")


async def heartbeat_task(application: Application, stop_event: asyncio.Event, bot_data):
    while not stop_event.is_set():
        try:
            now = time.time()
            with open(settings.HEARTBEAT_FILE, "w") as f:
                f.write(str(now))

            await asyncio.wait_for(stop_event.wait(), timeout=settings.HEARTBEAT_INTERVAL_SECONDS)

        except asyncio.TimeoutError:
            continue
        except asyncio.CancelledError:
            break
        except Exception as e:
            logger.error(f"Error in heartbeat task: {e}", exc_info=True)
            await asyncio.sleep(settings.HEARTBEAT_INTERVAL_SECONDS)

    logger.info("Heartbeat task finished.")
    if os.path.exists(settings.HEARTBEAT_FILE):
        try:
            os.remove(settings.HEARTBEAT_FILE)
        except OSError:
            pass

--- FILE: core/database.py ---
import asyncio
import sqlite3
import logging
import json
from typing import List, Tuple, Optional, Dict, Any

from core.settings import DATABASE_FILE

logger = logging.getLogger(__name__)


class DatabaseError(Exception):
    pass


def _execute_query_sync(query: str, params: tuple = (), fetch: Optional[str] = None):
    try:
        with sqlite3.connect(DATABASE_FILE) as conn:
            conn.row_factory = sqlite3.Row
            cursor = conn.cursor()
            cursor.execute("PRAGMA journal_mode=WAL;")
            cursor.execute("PRAGMA foreign_keys = ON;")
            cursor.execute(query, params)
            conn.commit()
            if fetch == "one":
                result = cursor.fetchone()
                return dict(result) if result else None
            if fetch == "all":
                results = cursor.fetchall()
                return [dict(row) for row in results]
            return cursor.lastrowid
    except sqlite3.Error as e:
        logger.error(f"Database error on query '{query}': {e}", exc_info=True)
        raise DatabaseError(f"Database operation failed: {e}")


async def execute_query(query: str, params: tuple = (), fetch: Optional[str] = None):
    try:
        return await asyncio.to_thread(_execute_query_sync, query, params, fetch)
    except DatabaseError:
        return None if fetch else 0


async def init_db():
    query_managers = "CREATE TABLE IF NOT EXISTS managers (user_id INTEGER NOT NULL, restaurant_code TEXT NOT NULL, full_name TEXT, username TEXT, PRIMARY KEY (user_id, restaurant_code));"
    await execute_query(query_managers)
    query_pending_managers = "CREATE TABLE IF NOT EXISTS pending_managers (user_id INTEGER PRIMARY KEY, full_name TEXT NOT NULL, username TEXT, restaurant_code TEXT NOT NULL, restaurant_name TEXT NOT NULL, request_time REAL NOT NULL);"
    await execute_query(query_pending_managers)
    query_pending_feedback = "CREATE TABLE IF NOT EXISTS pending_feedback (feedback_id TEXT PRIMARY KEY, manager_id INTEGER NOT NULL, message_id INTEGER, candidate_id INTEGER NOT NULL, candidate_name TEXT NOT NULL, job_data_json TEXT NOT NULL, created_at REAL NOT NULL);"
    await execute_query(query_pending_feedback)
    query_surveys = "CREATE TABLE IF NOT EXISTS surveys (survey_type TEXT NOT NULL, user_id INTEGER NOT NULL, restaurant_code TEXT, completed_at REAL NOT NULL, PRIMARY KEY (survey_type, user_id));"
    await execute_query(query_surveys)
    query_sheets_queue = "CREATE TABLE IF NOT EXISTS sheets_queue (id INTEGER PRIMARY KEY AUTOINCREMENT, sheet_name TEXT NOT NULL, data_json TEXT NOT NULL, created_at REAL NOT NULL, attempts INTEGER DEFAULT 0, is_processed BOOLEAN DEFAULT 0);"
    await execute_query(query_sheets_queue)
    query_candidate_restaurants = "CREATE TABLE IF NOT EXISTS candidate_restaurants (user_id INTEGER PRIMARY KEY, restaurant_code TEXT NOT NULL);"
    await execute_query(query_candidate_restaurants)
    query_feedback_history = "CREATE TABLE IF NOT EXISTS feedback_history (feedback_id TEXT PRIMARY KEY, manager_id INTEGER NOT NULL, message_id INTEGER, candidate_id INTEGER NOT NULL, candidate_name TEXT NOT NULL, job_data_json TEXT NOT NULL, created_at REAL NOT NULL, decision_at REAL, decision_by_id INTEGER, status TEXT);"
    await execute_query(query_feedback_history)
    query_employees = "CREATE TABLE IF NOT EXISTS employees (user_id INTEGER PRIMARY KEY, full_name TEXT, restaurant_code TEXT, is_active BOOLEAN DEFAULT 1, added_at REAL);"
    await execute_query(query_employees)
    logger.info("Database initialized successfully.")


async def add_employee(user_id: int, full_name: str, restaurant_code: str):
    query = "INSERT OR REPLACE INTO employees (user_id, full_name, restaurant_code, is_active, added_at) VALUES (?, ?, ?, 1, ?)"
    await execute_query(query, (user_id, full_name, restaurant_code, asyncio.get_event_loop().time()))
    logger.info(f"Added/updated employee {user_id} ({full_name}) for restaurant {restaurant_code}.")


async def register_candidate(user_id: int, full_name: str, restaurant_code: str):
    query = "INSERT OR REPLACE INTO employees (user_id, full_name, restaurant_code, is_active, added_at) VALUES (?, ?, ?, 0, ?)"
    await execute_query(query, (user_id, full_name, restaurant_code, asyncio.get_event_loop().time()))
    logger.info(f"Registered candidate {user_id} ({full_name}) for restaurant {restaurant_code} as inactive.")


async def activate_employee(user_id: int):
    query = "UPDATE employees SET is_active = 1 WHERE user_id = ?"
    await execute_query(query, (user_id,))
    logger.info(f"Activated employee {user_id}.")


async def deactivate_employee(user_id: int):
    query = "UPDATE employees SET is_active = 0 WHERE user_id = ?"
    await execute_query(query, (user_id,))
    logger.info(f"Deactivated employee {user_id}.")


async def toggle_employee_status(user_id: int):
    query = "UPDATE employees SET is_active = NOT is_active WHERE user_id = ?"
    await execute_query(query, (user_id,))
    logger.info(f"Toggled active status for employee {user_id}.")


async def get_active_employees() -> List[int]:
    query = "SELECT user_id FROM employees WHERE is_active = 1"
    result = await execute_query(query, fetch="all")
    return [row['user_id'] for row in result] if result else []


async def get_all_employees_with_status() -> List[Dict[str, Any]]:
    query = "SELECT user_id, full_name, restaurant_code, is_active FROM employees ORDER BY is_active DESC, full_name"
    return await execute_query(query, fetch="all") or []


async def count_employees_in_restaurant(restaurant_code: str) -> int:
    query = "SELECT COUNT(user_id) as count FROM employees WHERE restaurant_code = ?"
    result = await execute_query(query, (restaurant_code,), fetch="one")
    return result['count'] if result else 0


async def get_employees_paginated(restaurant_code: str, page: int, limit: int) -> List[Dict[str, Any]]:
    offset = page * limit
    query = "SELECT user_id, full_name, is_active FROM employees WHERE restaurant_code = ? ORDER BY is_active DESC, full_name LIMIT ? OFFSET ?"
    return await execute_query(query, (restaurant_code, limit, offset), fetch="all") or []


async def get_feedback_from_history(feedback_id: str) -> Optional[Dict[str, Any]]:
    query = "SELECT * FROM feedback_history WHERE feedback_id = ?"
    result = await execute_query(query, (feedback_id,), fetch="one")
    if result:
        result['job_data'] = json.loads(result['job_data_json'])
        return result
    return None


async def move_pending_feedback_to_history(candidate_id: int, decision_by_id: int, status: str):
    first_task_details_query = "SELECT * FROM pending_feedback WHERE candidate_id = ? LIMIT 1"
    task_details = await execute_query(first_task_details_query, (candidate_id,), fetch="one")
    if not task_details:
        await remove_all_pending_feedback_for_candidate(candidate_id)
        return

    insert_query = "INSERT OR IGNORE INTO feedback_history (feedback_id, manager_id, message_id, candidate_id, candidate_name, job_data_json, created_at, decision_at, decision_by_id, status) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)"
    decision_time = asyncio.get_event_loop().time()
    await execute_query(insert_query, (
        task_details['feedback_id'], task_details['manager_id'], task_details['message_id'],
        task_details['candidate_id'], task_details['candidate_name'], task_details['job_data_json'],
        task_details['created_at'], decision_time, decision_by_id, status
    ))
    logger.info(f"Moved feedback for candidate {candidate_id} to history with status '{status}'.")
    await remove_all_pending_feedback_for_candidate(candidate_id)


async def add_to_sheets_db_queue(sheet_name: str, data: list):
    query = "INSERT INTO sheets_queue (sheet_name, data_json, created_at) VALUES (?, ?, ?)"
    data_json = json.dumps(data, ensure_ascii=False)
    created_at = asyncio.get_event_loop().time()
    await execute_query(query, (sheet_name, data_json, created_at))


async def get_sheets_queue_batch(limit: int = 50) -> List[Dict[str, Any]]:
    query = "SELECT id, sheet_name, data_json, attempts FROM sheets_queue WHERE is_processed = 0 ORDER BY created_at LIMIT ?"
    result = await execute_query(query, (limit,), fetch="all")
    return result if result else []


async def mark_sheets_queue_items_processed(item_ids: List[int]):
    if not item_ids: return
    query = f"UPDATE sheets_queue SET is_processed = 1 WHERE id IN ({','.join(['?'] * len(item_ids))})"
    await execute_query(query, tuple(item_ids))


async def increment_sheets_queue_attempts(item_ids: List[int]):
    if not item_ids: return
    query = f"UPDATE sheets_queue SET attempts = attempts + 1 WHERE id IN ({','.join(['?'] * len(item_ids))})"
    await execute_query(query, tuple(item_ids))


async def add_manager(user_id: int, restaurant_code: str, full_name: str, username: Optional[str]):
    query = "INSERT OR REPLACE INTO managers (user_id, restaurant_code, full_name, username) VALUES (?, ?, ?, ?)"
    await execute_query(query, (user_id, restaurant_code, full_name, username))
    logger.info(f"Added/updated manager {user_id} ({full_name}) for restaurant {restaurant_code}.")


async def get_manager_details(user_id: int) -> Optional[Dict[str, Any]]:
    query = "SELECT user_id, full_name, username FROM managers WHERE user_id = ? LIMIT 1"
    return await execute_query(query, (user_id,), fetch="one")


async def remove_manager_from_all_restaurants(user_id: int):
    query = "DELETE FROM managers WHERE user_id = ?"
    await execute_query(query, (user_id,))
    logger.info(f"Removed manager {user_id} from all restaurants.")


async def get_managers_for_restaurant(restaurant_code: str) -> List[int]:
    query = "SELECT user_id FROM managers WHERE restaurant_code = ?"
    result = await execute_query(query, (restaurant_code,), fetch="all")
    return [row['user_id'] for row in result] if result else []


async def get_all_managers_by_restaurant() -> dict[str, list[dict]]:
    query = "SELECT restaurant_code, user_id, full_name, username FROM managers ORDER BY restaurant_code, full_name"
    result = await execute_query(query, fetch="all")
    managers_map = {}
    if result:
        for row in result:
            res_code = row['restaurant_code']
            if res_code not in managers_map:
                managers_map[res_code] = []
            managers_map[res_code].append(
                {'user_id': row['user_id'], 'full_name': row['full_name'], 'username': row['username']}
            )
    return managers_map


async def is_manager_in_restaurant(user_id: int, restaurant_code: str) -> bool:
    query = "SELECT 1 FROM managers WHERE user_id = ? AND restaurant_code = ?"
    result = await execute_query(query, (user_id, restaurant_code), fetch="one")
    return result is not None


async def is_user_a_manager(user_id: int) -> bool:
    query = "SELECT 1 FROM managers WHERE user_id = ? LIMIT 1"
    result = await execute_query(query, (user_id,), fetch="one")
    return result is not None


async def add_pending_manager(user_id: int, restaurant_code: str, restaurant_name: str, full_name: str, username: Optional[str],
                              request_time: float):
    query = "INSERT OR REPLACE INTO pending_managers (user_id, restaurant_code, restaurant_name, full_name, username, request_time) VALUES (?, ?, ?, ?, ?, ?)"
    await execute_query(query, (user_id, restaurant_code, restaurant_name, full_name, username, request_time))
    logger.info(f"Added pending manager request for user {user_id}.")


async def get_pending_manager(user_id: int) -> Optional[dict]:
    query = "SELECT restaurant_code, restaurant_name, full_name, username FROM pending_managers WHERE user_id = ?"
    result = await execute_query(query, (user_id,), fetch="one")
    return result


async def remove_pending_manager(user_id: int):
    query = "DELETE FROM pending_managers WHERE user_id = ?"
    await execute_query(query, (user_id,))
    logger.info(f"Removed pending manager request for user {user_id}.")


async def add_pending_feedback(feedback_id: str, manager_id: int, message_id: int, candidate_id: int,
                               candidate_name: str,
                               job_data: dict, created_at: float):
    query = "INSERT INTO pending_feedback (feedback_id, manager_id, message_id, candidate_id, candidate_name, job_data_json, created_at) VALUES (?, ?, ?, ?, ?, ?, ?)"
    job_data_json = json.dumps(job_data, ensure_ascii=False)
    await execute_query(query,
                        (feedback_id, manager_id, message_id, candidate_id, candidate_name, job_data_json, created_at))
    logger.info(f"Added pending feedback task {feedback_id} for manager {manager_id} about candidate {candidate_id}.")


async def get_pending_feedback_for_manager(manager_id: int) -> List[Dict[str, Any]]:
    query = "SELECT feedback_id, candidate_name FROM pending_feedback WHERE manager_id = ?"
    result = await execute_query(query, (manager_id,), fetch="all")
    return [{"id": row['feedback_id'], "name": row['candidate_name']} for row in result] if result else []


async def get_all_pending_feedback() -> List[Dict[str, Any]]:
    query = "SELECT feedback_id, candidate_id, candidate_name, job_data_json FROM pending_feedback ORDER BY created_at"
    results = await execute_query(query, fetch="all")
    if not results: return []
    tasks, processed_candidates = [], set()
    for row in results:
        candidate_id = row['candidate_id']
        if candidate_id in processed_candidates: continue
        job_data = json.loads(row['job_data_json'])
        tasks.append({
            "id": row['feedback_id'],
            "candidate_id": candidate_id,
            "name": row['candidate_name'],
            "restaurant_name": job_data.get('interview_restaurant_name', '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ')
        })
        processed_candidates.add(candidate_id)
    return tasks


async def get_pending_feedback_by_id(feedback_id: str) -> Optional[Dict[str, Any]]:
    query = "SELECT * FROM pending_feedback WHERE feedback_id = ?"
    result = await execute_query(query, (feedback_id,), fetch="one")
    if result:
        result['job_data'] = json.loads(result['job_data_json'])
        return result
    return None


async def get_candidate_id_from_feedback_id(feedback_id: str) -> Optional[int]:
    query = "SELECT candidate_id FROM pending_feedback WHERE feedback_id = ? LIMIT 1"
    result = await execute_query(query, (feedback_id,), fetch="one")
    return result['candidate_id'] if result else None


async def get_all_pending_feedback_for_candidate(candidate_id: int) -> List[Dict[str, Any]]:
    query = "SELECT * FROM pending_feedback WHERE candidate_id = ?"
    return await execute_query(query, (candidate_id,), fetch="all") or []


async def remove_all_pending_feedback_for_candidate(candidate_id: int):
    query = "DELETE FROM pending_feedback WHERE candidate_id = ?"
    await execute_query(query, (candidate_id,))
    logger.info(f"Removed all pending feedback tasks for candidate {candidate_id}.")


async def get_survey_counts_by_restaurant() -> Dict[str, Dict[str, int]]:
    query = "SELECT restaurant_code, survey_type, COUNT(*) as count FROM surveys GROUP BY restaurant_code, survey_type"
    results = await execute_query(query, fetch="all")
    stats = {}
    if not results: return stats
    for row in results:
        res_code, survey_type, count = row['restaurant_code'] or 'N/A', row['survey_type'], row['count']
        if res_code not in stats: stats[res_code] = {}
        stats[res_code][survey_type] = count
    return stats


async def log_survey_completion(survey_type: str, user_id: int, restaurant_code: Optional[str] = None):
    query = "INSERT OR REPLACE INTO surveys (survey_type, user_id, restaurant_code, completed_at) VALUES (?, ?, ?, ?)"
    await execute_query(query, (survey_type, user_id, restaurant_code, asyncio.get_event_loop().time()))


async def is_survey_completed(survey_type: str, user_id: int) -> bool:
    query = "SELECT 1 FROM surveys WHERE survey_type = ? AND user_id = ?"
    result = await execute_query(query, (survey_type, user_id), fetch="one")
    return result is not None


async def log_candidate_restaurant(user_id: int, restaurant_code: str):
    query = "INSERT OR REPLACE INTO candidate_restaurants (user_id, restaurant_code) VALUES (?, ?)"
    await execute_query(query, (user_id, restaurant_code))


async def get_candidate_restaurant(user_id: int) -> Optional[str]:
    query = "SELECT restaurant_code FROM candidate_restaurants WHERE user_id = ?"
    result = await execute_query(query, (user_id,), fetch="one")
    return result['restaurant_code'] if result else None


async def delete_user_data(user_id: int):
    logger.warning(f"Deleting all data for user_id: {user_id}")
    tables_with_user_id = ["managers", "pending_managers", "surveys", "candidate_restaurants", "employees"]
    for table in tables_with_user_id:
        await execute_query(f"DELETE FROM {table} WHERE user_id = ?", (user_id,))
    await execute_query("DELETE FROM pending_feedback WHERE candidate_id = ?", (user_id,))
    await execute_query("DELETE FROM pending_feedback WHERE manager_id = ?", (user_id,))
    await execute_query("UPDATE feedback_history SET decision_by_id = NULL WHERE decision_by_id = ?", (user_id,))
    logger.info(f"Successfully deleted data for user_id: {user_id}")


async def remove_manager(user_id: int, restaurant_code: str):
    query = "DELETE FROM managers WHERE user_id = ? AND restaurant_code = ?"
    await execute_query(query, (user_id, restaurant_code))
    logger.info(f"Removed manager {user_id} from restaurant {restaurant_code}.")

--- FILE: core/stickers.py ---
import random

# --- –ü—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏—è ---
GREETING_HOSTESS = "CAACAgIAAxkBAAIHj2iAChs6ubi63zrSCHd1wehShbDJAAJ2gwACLfIAAUgAAVT4KBDVr2Y2BA"
GREETING_TEAM = "CAACAgIAAxkBAAIHlWiACr5xbMv9tNQ49KymsksqOYYLAAIUgQACfZwAAUgcJKOgFuH9lTYE"
GREETING_CHEF = "CAACAgIAAxkBAAIHmWiAC1efwOzU8PXv1cpGP2IZ01BEAAN7AALN5wFI533VDdT1mHo2BA"
GREETING_WAITER = "CAACAgIAAxkBAAIHnGiAC3iUpaLbf_-H5J9czOn6997CAAKfggACV28AAUiiD8EOkiO0cTYE"

# --- –≠–º–æ—Ü–∏–∏ –∏ –¥–µ–π—Å—Ç–≤–∏—è ---
QUESTION_DOG = "CAACAgIAAxkBAAIHn2iAC5maCrWA69Cgrzfmcl4ZOeHPAAISgQACM0cAAUgQ_dl65aVWljYE"
FEEDBACK_SENT_DOG = "CAACAgIAAxkBAAIHomiAC85YGIm1_BbEF1NKi5gB3xSnAAKKgAAC3T8AAUjlRNKUgmsdrTYE"
ONBOARDING_INFO_DOG = "CAACAgIAAxkBAAIHpWiAC_VJG1TFQPhfztpeA5eXZflGAAIqjwAC8jABSBuofKT7h7gINgQ"
CONTACT_MANAGER = "CAACAgIAAxkBAAIHqGiADDZiFgfl-2wPnPD6XrYMB3RRAAKyhAAC5XABSOmbTsnxVW-RNgQ"
SUCCESS_DOG = "CAACAgIAAxkBAAIHq2iADFnw9MexQP_XPAMAAQzkjsZBAQACQYcAAmj5AUj2xzFdQF12uTYE"


# –°–ø–∏—Å–æ–∫ –¥–ª—è —Å–ª—É—á–∞–π–Ω–æ–≥–æ –≤—ã–±–æ—Ä–∞ –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ —Å—Ç–∏–∫–µ—Ä–∞
GREETING_STICKERS = [GREETING_HOSTESS, GREETING_TEAM, GREETING_CHEF, GREETING_WAITER]

def get_random_greeting():
    """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç ID —Å–ª—É—á–∞–π–Ω–æ–≥–æ –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ —Å—Ç–∏–∫–µ—Ä–∞."""
    return random.choice(GREETING_STICKERS)

--- FILE: core/settings.py ---
import os
from pathlib import Path
from dotenv import load_dotenv

BASE_DIR = Path(__file__).parent.parent.resolve()
load_dotenv(BASE_DIR / ".env")

TOKEN = os.getenv("BOT_TOKEN")
GOOGLE_CREDENTIALS_JSON = os.getenv("GOOGLE_CREDENTIALS_JSON")
SPREADSHEET_ID = os.getenv("SPREADSHEET_ID")
MOSCOW_TIMEZONE = "Europe/Moscow"

raw_admin_ids = os.getenv("ADMIN_CHAT_ID", "")
try:
    ADMIN_IDS = {int(admin_id.strip()) for admin_id in raw_admin_ids.split(',') if admin_id.strip().isdigit()}
except (ValueError, TypeError):
    ADMIN_IDS = set()

EMPLOYEES_PER_PAGE = 15

ONBOARDING_SHEET_NAME = "–û–∑–Ω–∞–∫–æ–º–∏—Ç–µ–ª—å–Ω–∞—è —Å–º–µ–Ω–∞"
EXIT_INTERVIEW_SHEET_NAME = "exit interview"
CLIMATE_SURVEY_SHEET_NAME = "–ó–∞–º–µ—Ä –∫–ª–∏–º–∞—Ç–∞"
INTERVIEW_SHEET_NAME = os.getenv("INTERVIEW_SHEET_NAME", "–ü–µ—Ä–≤–∏—á–Ω—ã–π –∫–æ–Ω—Ç–∞–∫—Ç")
MANAGER_FEEDBACK_SHEET_NAME = "–û–° –æ—Ç –º–µ–Ω–µ–¥–∂–µ—Ä–∞"
CANDIDATE_FEEDBACK_SHEET_NAME = "–û–° –æ—Ç –∫–∞–Ω–¥–∏–¥–∞—Ç–∞"
LEAVING_REASON_SHEET_NAME = "–ü—Ä–∏—á–∏–Ω—ã —É—Ö–æ–¥–∞ (–∞–≤—Ç–æ)"
BOT_FEEDBACK_SHEET_NAME = "–û–° –ø–æ –±–æ—Ç—É"
CANDIDATE_NOSHOW_SHEET_NAME = "–ö–∞–Ω–¥–∏–¥–∞—Ç—ã (–ø–µ—Ä–µ–¥—É–º–∞–ª–∏)"


BATCH_INTERVAL = 30

EXIT_INTERVIEW_COOLDOWN_SECONDS = 60 * 60 * 24 * 7
FEEDBACK_DELAY_SECONDS = 1800
ONBOARDING_FOLLOWUP_SECONDS = 60 * 60 * 24 * 7

PID_FILE = BASE_DIR / "bot.pid"
HEARTBEAT_FILE = BASE_DIR / "heartbeat.txt"
PING_FILE = BASE_DIR / "ping.txt"
PERSISTENCE_FILE = BASE_DIR / "bot_persistence.pkl"
DATABASE_FILE = BASE_DIR / "bot_database.sqlite"

HEARTBEAT_INTERVAL_SECONDS = 30
TELEGRAM_INACTIVITY_THRESHOLD_SECONDS = 60 * 10
CONVERSATION_TIMEOUT_SECONDS = 60 * 60 * 3

ACTIVE_MESSAGE_ID_KEY = "active_message_id"

CALLBACK_START_ONBOARDING = "start_onboarding"
CALLBACK_START_EXIT = "start_exit_interview"
CALLBACK_START_CLIMATE = "start_climate_survey"
CALLBACK_CONFIRM_QUIT = "confirm_quit"
CALLBACK_DECLINE_QUIT = "decline_quit"

CALLBACK_ADMIN_LIST = "admin_list_managers"
CALLBACK_ADMIN_ADD_START = "admin_add_manager_start"
CALLBACK_ADMIN_REMOVE_START = "admin_remove_manager_start"
CALLBACK_ADMIN_BACK = "admin_back_to_menu"
CALLBACK_ADMIN_EXIT = "admin_exit_panel"
CALLBACK_ADMIN_BROADCAST_CLIMATE_START = "admin_broadcast_climate_start"
CALLBACK_ADMIN_BROADCAST_CONFIRM = "admin_broadcast_confirm"
CALLBACK_ADMIN_BROADCAST_CANCEL = "admin_broadcast_cancel"
CALLBACK_ADMIN_STATS = "admin_stats"

CALLBACK_MGR_APPROVE_PREFIX = "mgr_approve_"
CALLBACK_MGR_REJECT_PREFIX = "mgr_reject_"

CALLBACK_MGR_FEEDBACK_PREFIX = "mgr_feedback_status_"
CALLBACK_START_CANDIDATE_FEEDBACK = "start_candidate_feedback"

CALLBACK_ONBOARDING_FOLLOWUP_YES = "onboarding_followup_yes"
CALLBACK_ONBOARDING_FOLLOWUP_NO = "onboarding_followup_no"

CALLBACK_GO_TO_MAIN_MENU = "go_to_main_menu"

--- FILE: utils/keyboards.py ---
import locale
from datetime import date, timedelta
from typing import List, Tuple, Dict, Any
from telegram import InlineKeyboardButton, InlineKeyboardMarkup
from utils.helpers import build_inline_keyboard, get_now
from core import settings

try:
    locale.setlocale(locale.LC_TIME, 'ru_RU.UTF-8')
except locale.Error:
    try:
        locale.setlocale(locale.LC_TIME, 'russian')
    except locale.Error:
        print("Warning: Could not set Russian locale. Dates might be in English.")

InlineButtonOption = Tuple[str, str]

RESTAURANT_OPTIONS: List[InlineButtonOption] = [
    ("–í–æ—Å—Å—Ç–∞–Ω–∏—è, 15", "res_V15"), ("–û–¥–æ–µ–≤—Å–∫–æ–≥–æ, 34", "res_O34"), ("–¢–∏–ø–∞–Ω–æ–≤–∞, 27/39", "res_T27"),
    ("–ú–æ—Å–∫–æ–≤—Å–∫–∏–π, 205", "res_M205"), ("–õ–µ–Ω–∏–Ω—Å–∫–∏–π, 120", "res_L120"), ("–ù–µ–≤—Å–∫–∏–π, 21", "res_N21"),
    ("–†—É–±–∏–Ω—à—Ç–µ–π–Ω–∞, 1/43", "res_R1"), ("–ì—Ä–∏–±–æ–µ–¥–æ–≤–∞ 18-20", "res_G18"), ("–ù–∞—É–∫–∏, 14–ê", "res_N14"),
    ("–≠–Ω–≥–µ–ª—å—Å–∞, 124", "res_E124"), ("–ú–°–ö, –ö–∞–º–µ—Ä–≥–µ—Ä—Å–∫–∏–π", "res_MSK"), ("–ú—É—Ä–∏–Ω–æ", "res_MUR")
]

ONBOARDING_POSITION_OPTIONS: List[InlineButtonOption] = [
    ("–•–æ—Å—Ç–µ—Å", "onboard_pos_Hostess"), ("–û—Ñ–∏—Ü–∏–∞–Ω—Ç", "onboard_pos_Waiter"),
    ("–ë–∞—Ä–º–µ–Ω", "onboard_pos_Bartender"), ("–î—Ä—É–≥–æ–µ", "onboard_pos_Other")
]

EXIT_POSITION_OPTIONS: List[InlineButtonOption] = [
    ("–û—Ñ–∏—Ü–∏–∞–Ω—Ç", "exit_pos_Waiter"), ("–ë–∞—Ä–º–µ–Ω", "exit_pos_Bartender"), ("–ü–æ–≤–∞—Ä", "exit_pos_Cook"),
    ("–•–æ—Å—Ç–µ—Å", "exit_pos_Hostess"), ("–ú–µ–Ω–µ–¥–∂–µ—Ä", "exit_pos_Manager"), ("–ë—Ä–∏–≥–∞–¥–∏—Ä", "exit_pos_Brigadier"),
    ("–ö–∞—Å—Å–∏—Ä", "exit_pos_Cashier"), ("–ú–æ–π–∫–∞/–£–±–æ—Ä–∫–∞", "exit_pos_Cleaner"), ("–ö—É—Ä—å–µ—Ä", "exit_pos_Courier"),
    ("–ú–µ–Ω–µ–¥–∂–µ—Ä –¥–æ—Å—Ç–∞–≤–∫–∏", "exit_pos_DeliveryManager")
]

RECRUITMENT_POSITION_OPTIONS: List[InlineButtonOption] = [
    ("–û—Ñ–∏—Ü–∏–∞–Ω—Ç", "vac_Waiter"), ("–ë–∞—Ä–º–µ–Ω", "vac_Bartender"), ("–ü–æ–≤–∞—Ä", "vac_Cook"),
    ("–•–æ—Å—Ç–µ—Å", "vac_Hostess"), ("–ú–µ–Ω–µ–¥–∂–µ—Ä", "vac_Manager"), ("–ë—Ä–∏–≥–∞–¥–∏—Ä", "vac_Brigadier"),
    ("–ö–∞—Å—Å–∏—Ä", "vac_Cashier"), ("–ú–æ–π–∫–∞/–£–±–æ—Ä–∫–∞", "vac_Cleaner"), ("–ö—É—Ä—å–µ—Ä", "vac_Courier"),
    ("–ú–µ–Ω–µ–¥–∂–µ—Ä –¥–æ—Å—Ç–∞–≤–∫–∏", "vac_DeliveryManager"), ("–î—Ä—É–≥–æ–µ", "vac_Other")
]

DURATION_OPTIONS: List[InlineButtonOption] = [
    ("< 1 –º–µ—Å", "dur_1m"), ("1-6 –º–µ—Å", "dur_6m"), ("6-12 –º–µ—Å", "dur_1y"),
    ("1-2 –≥–æ–¥–∞", "dur_2y"), ("> 2 –ª–µ—Ç", "dur_2y+")
]

RATING_OPTIONS: List[InlineButtonOption] = [
    ("1 (–û—á–µ–Ω—å –ø–ª–æ—Ö–æ)", "rate_1"), ("2 (–ü–ª–æ—Ö–æ)", "rate_2"), ("3 (–ù–æ—Ä–º–∞–ª—å–Ω–æ)", "rate_3"),
    ("4 (–•–æ—Ä–æ—à–æ)", "rate_4"), ("5 (–û—Ç–ª–∏—á–Ω–æ!)", "rate_5")
]

TRAINING_OPTIONS: List[InlineButtonOption] = [
    ("–î–∞, –ø–æ–ª–Ω–æ—Å—Ç—å—é", "train_Full"), ("–í –æ—Å–Ω–æ–≤–Ω–æ–º –¥–∞", "train_Mostly"),
    ("–ß–∞—Å—Ç–∏—á–Ω–æ", "train_Partly"), ("–ù–µ—Ç, –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ", "train_No")
]

FEEDBACK_OPTIONS: List[InlineButtonOption] = [
    ("–†–µ–≥—É–ª—è—Ä–Ω–æ", "feed_Regular"), ("–ò–Ω–æ–≥–¥–∞", "feed_Sometimes"),
    ("–†–µ–¥–∫–æ", "feed_Rarely"), ("–ù–∏–∫–æ–≥–¥–∞", "feed_Never")
]

GENDER_OPTIONS: List[InlineButtonOption] = [("–ú—É–∂—á–∏–Ω–∞ üë®", "climate_gender_male"),
                                            ("–ñ–µ–Ω—â–∏–Ω–∞ üë©", "climate_gender_female")]

YES_NO_OPTIONS: List[InlineButtonOption] = [("–î–∞", "yes"), ("–ù–µ—Ç", "no")]
YES_NO_OPTIONS_CLIMATE: List[InlineButtonOption] = [("–î–∞ üëç", "climate_yes"), ("–ù–µ—Ç üëé", "climate_no")]

YES_NO_MAYBE_OPTIONS: List[InlineButtonOption] = [
    ("‚úÖ –î–∞", "climate_q_yes"), ("‚òëÔ∏è –°–∫–æ—Ä–µ–µ –¥–∞", "climate_q_mostly_yes"),
    ("‚ùå –°–∫–æ—Ä–µ–µ –Ω–µ—Ç", "climate_q_mostly_no"), ("üö´ –ù–µ—Ç", "climate_q_no")
]

CHILDREN_OPTIONS: List[InlineButtonOption] = [
    ("–ù–µ—Ç", "child_0"), ("1", "child_1"), ("2", "child_2"), ("–ë–æ–ª—å—à–µ 2", "child_many")
]

HEALTH_OPTIONS: List[InlineButtonOption] = [
    ("–û—Ç–ª–∏—á–Ω–æ–µ", "health_excellent"), ("–•–æ—Ä–æ—à–µ–µ", "health_good"),
    ("–ù–æ—Ä–º–∞–ª—å–Ω–æ–µ", "health_normal"), ("–ü–ª–æ—Ö–æ–µ", "health_bad")
]

EXPERIENCE_OPTIONS: List[InlineButtonOption] = [
    ("–ù–µ—Ç –æ–ø—ã—Ç–∞", "exp_0"), ("–î–æ 3 –º–µ—Å.", "exp_3m"), ("3-6 –º–µ—Å.", "exp_6m"),
    ("6-12 –º–µ—Å.", "exp_1y"), ("1-3 –≥–æ–¥–∞", "exp_3y"), ("–ë–æ–ª–µ–µ 3 –ª–µ—Ç", "exp_many")
]

INCOME_OPTIONS: List[InlineButtonOption] = [
    ("–¥–æ 60 000 ‚ÇΩ", "inc_60"), ("–¥–æ 80 000 ‚ÇΩ", "inc_80"), ("–¥–æ 100 000 ‚ÇΩ", "inc_100"),
    ("–¥–æ 120 000 ‚ÇΩ", "inc_120"), ("–í—ã—à–µ 120 000 ‚ÇΩ", "inc_more")
]

JOBS_COUNT_OPTIONS: List[InlineButtonOption] = [
    ("1", "jobs_1"), ("2", "jobs_2"), ("3", "jobs_3"), ("4", "jobs_4"), ("–ë–æ–ª–µ–µ 4", "jobs_many")
]

COURSE_OPTIONS: List[InlineButtonOption] = [
    ("1", "course_1"), ("2", "course_2"), ("3", "course_3"), ("4", "course_4"),
    ("5", "course_5"), ("6", "course_6"), ("–ù–µ —É—á—É—Å—å", "course_none")
]

MARITAL_STATUS_OPTIONS: List[InlineButtonOption] = [
    ("üíç –ñ–µ–Ω–∞—Ç/–ó–∞–º—É–∂–µ–º", "m_married"), ("‚ù§Ô∏è –í –æ—Ç–Ω–æ—à–µ–Ω–∏—è—Ö", "m_relation"),
    ("üö∂ –°–≤–æ–±–æ–¥–µ–Ω(–Ω–∞)", "m_single"), ("üíî –†–∞–∑–≤–µ–¥–µ–Ω(–∞)", "m_divorced")
]

ATTITUDE_TO_APPEARANCE_OPTIONS: List[InlineButtonOption] = [
    ("üòç –°—á–∏—Ç–∞—é —Å–µ–±—è –∫—Ä–∞—Å–∏–≤—ã–º(–æ–π)", "app_nice"), ("üôÇ –£ –º–µ–Ω—è –æ–±—ã—á–Ω–∞—è –≤–Ω–µ—à–Ω–æ—Å—Ç—å", "app_normal"),
    ("üòï –°—á–∏—Ç–∞—é —Å–µ–±—è –Ω–µ–ø—Ä–∏–≤–ª–µ–∫–∞—Ç–µ–ª—å–Ω—ã–º(–æ–π)", "app_not_nice")
]

EDUCATION_FORM_OPTIONS: List[InlineButtonOption] = [
    ("‚òÄÔ∏è –û—á–Ω–∞—è", "form_full"), ("üåô –í–µ—á–µ—Ä–Ω—è—è", "form_evening"),
    ("‚úâÔ∏è –ó–∞–æ—á–Ω–∞—è", "form_part"), ("üíª –î–∏—Å—Ç–∞–Ω—Ü–∏–æ–Ω–Ω–∞—è", "form_remote")
]

VACANCY_SOURCE_OPTIONS: List[InlineButtonOption] = [
    ("üåê HeadHunter", "src_hh"), ("‚úàÔ∏è Telegram", "src_tg"),
    ("üó£Ô∏è –ü–æ—Å–æ–≤–µ—Ç–æ–≤–∞–ª–∏", "src_ref"), ("üìù –ê–≤–∏—Ç–æ", "src_avito"),
    ("üö∂ –° —É–ª–∏—Ü—ã", "src_walk"), ("‚ùì –î—Ä—É–≥–æ–µ", "src_other")
]

MANAGER_FEEDBACK_OPTIONS: List[InlineButtonOption] = [
    ("‚úÖ –û–∑–Ω–∞–∫–æ–º–∏—Ç–µ–ª—å–Ω–∞—è —Å–º–µ–Ω–∞", f"{settings.CALLBACK_MGR_FEEDBACK_PREFIX}onboarding"),
    ("ü§î –ü–æ–¥—É–º–∞–µ—Ç", f"{settings.CALLBACK_MGR_FEEDBACK_PREFIX}thinking"),
    ("‚ùå –û—Ç–∫–∞–∑–∞–ª—Å—è", f"{settings.CALLBACK_MGR_FEEDBACK_PREFIX}refused"),
    ("‚õîÔ∏è –ù–µ –ø–æ–¥—Ö–æ–¥–∏—Ç", f"{settings.CALLBACK_MGR_FEEDBACK_PREFIX}unsuitable"),
]

CANDIDATE_FEEDBACK_RATING_OPTIONS: List[InlineButtonOption] = [
    ("üòû 1", "cand_rate_1"), ("üòï 2", "cand_rate_2"), ("üòê 3", "cand_rate_3"),
    ("üôÇ 4", "cand_rate_4"), ("üòÄ 5", "cand_rate_5"),
]

INTEREST_RATING_OPTIONS: List[InlineButtonOption] = [
    (str(i), f"onboard_rate_{i}") for i in range(1, 11)
]

POSITION_LINKS: Dict[str, List[Dict[str, str]]] = {
    "–û—Ñ–∏—Ü–∏–∞–Ω—Ç": [
        {"name": "–ü–æ–¥–ø–∏—à–∏—Å—å –Ω–∞ –∫–∞–Ω–∞–ª, —á—Ç–æ–±—ã –±—ã—Ç—å –≤ –∫—É—Ä—Å–µ —Å–æ–±—ã—Ç–∏–π", "url": "https://t.me/+1c-IyuONGdk0NDEy", "is_critical": True},
        {"name": "–ú–µ–Ω—é –∏ —Å–ª–æ–≤–∞—Ä—å –∏–Ω–≥—Ä–µ–¥–∏–µ–Ω—Ç–æ–≤", "url": "https://docs.google.com/spreadsheets/d/1wb5RszKAdkb9zRgvVijHYrve6K63x5KljCZO_9MokHw/edit?gid=176953636", "is_critical": True},
        {"name": "–°—Ç–∞–Ω–¥–∞—Ä—Ç—ã —Å–µ—Ä–≤–∏—Å–∞ –∏ —Ä–∞–±–æ—Ç—ã –æ—Ñ–∏—Ü–∏–∞–Ω—Ç–∞ (–¥–ª—è –∞—Ç—Ç–µ—Å—Ç–∞—Ü–∏–∏)", "url": "https://docs.google.com/spreadsheets/d/12jxORpWm9zfcA8AN84uGwV1XNJZRQPwX0TcffgabdNs/edit?usp=sharing", "is_critical": True},
        {"name": "–ú–µ—Ç–æ–¥–∏—á–∫–∞, –∫–æ—Ç–æ—Ä–∞—è –ø–æ–º–æ–∂–µ—Ç —Ç–µ–±–µ –Ω–∞ –∞–¥–∞–ø—Ç–∞—Ü–∏–∏", "url": "https://drive.google.com/drive/folders/1dA8QOrcng94GBigEjtkmw6celBsXq-cM?usp=share_link", "is_critical": False},
        {"name": "–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Ñ–∞–π–ª—ã, –∫–æ—Ç–æ—Ä—ã–µ –ø–æ–º–æ–≥—É—Ç –æ—Å–≤–æ–∏—Ç—å—Å—è", "url": "https://drive.google.com/drive/folders/1gcf7Io0hcVdwJuH-KkKXH_5OaUZBrGMD?usp=share_link", "is_critical": False},
        {"additional_message": "–ù–∞–ø–∏—à–∏ —Å–µ–≥–æ–¥–Ω—è –ø–æ–∂–µ–ª–∞–Ω–∏—è –ø–æ –≥—Ä–∞—Ñ–∏–∫—É —Å–≤–æ–µ–º—É –º–µ–Ω–µ–¥–∂–µ—Ä—É!"},
    ],
    "–•–æ—Å—Ç–µ—Å": [
        {"name": "–ü–æ–¥–ø–∏—à–∏—Å—å –Ω–∞ –∫–∞–Ω–∞–ª, —á—Ç–æ–±—ã –±—ã—Ç—å –≤ –∫—É—Ä—Å–µ —Å–æ–±—ã—Ç–∏–π", "url": "https://t.me/+1c-IyuONGdk0NDEy", "is_critical": True},
        {"name": "–°—Ç–∞–Ω–¥–∞—Ä—Ç—ã —Ä–∞–±–æ—Ç—ã —Ö–æ—Å—Ç–µ—Å (–¥–ª—è –∞—Ç—Ç–µ—Å—Ç–∞—Ü–∏–∏)", "url": "https://docs.google.com/spreadsheets/d/11tJyxLR9uYTUXpfvqQ9Nvbnj6TQ7m9mk-_EkN2itt7g/edit", "is_critical": True},
        {"name": "–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Ñ–∞–π–ª—ã, –∫–æ—Ç–æ—Ä—ã–µ –ø–æ–º–æ–≥—É—Ç –æ—Å–≤–æ–∏—Ç—å—Å—è", "url": "https://drive.google.com/drive/folders/15QU-fC3fOezWsKNbRRKlWvooNYm-7P1O?usp=share_link", "is_critical": False},
        {"additional_message": "–ù–∞–ø–∏—à–∏ —Å–µ–≥–æ–¥–Ω—è –ø–æ–∂–µ–ª–∞–Ω–∏—è –ø–æ –≥—Ä–∞—Ñ–∏–∫—É —Å–≤–æ–µ–º—É –º–µ–Ω–µ–¥–∂–µ—Ä—É!"},
    ],
    "–ë–∞—Ä–º–µ–Ω": [
        {"name": "–ü–æ–¥–ø–∏—à–∏—Å—å –Ω–∞ –∫–∞–Ω–∞–ª, —á—Ç–æ–±—ã –±—ã—Ç—å –≤ –∫—É—Ä—Å–µ —Å–æ–±—ã—Ç–∏–π", "url": "https://t.me/+1c-IyuONGdk0NDEy", "is_critical": True},
        {"additional_message": "–ù–∞–ø–∏—à–∏ —Å–µ–≥–æ–¥–Ω—è –ø–æ–∂–µ–ª–∞–Ω–∏—è –ø–æ –≥—Ä–∞—Ñ–∏–∫—É —Å—Ç–∞—Ä—à–µ–º—É –±–∞—Ä–º–µ–Ω—É!"},
    ],
    "–î—Ä—É–≥–æ–µ": [
        {"name": "–ü–æ–¥–ø–∏—à–∏—Å—å –Ω–∞ –∫–∞–Ω–∞–ª, —á—Ç–æ–±—ã –±—ã—Ç—å –≤ –∫—É—Ä—Å–µ —Å–æ–±—ã—Ç–∏–π", "url": "https://t.me/+1c-IyuONGdk0NDEy", "is_critical": True},
        {"additional_message": "–ñ–µ–ª–∞–µ–º —Ç–µ–±–µ —É—Å–ø–µ—à–Ω–æ–≥–æ —Å—Ç–∞—Ä—Ç–∞ –∏ —É–≤–ª–µ–∫–∞—Ç–µ–ª—å–Ω–æ–π –∞–¥–∞–ø—Ç–∞—Ü–∏–∏!"},
    ]
}


def get_admin_menu_keyboard() -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup([
        [InlineKeyboardButton("üìã –°–ø–∏—Å–æ–∫ –º–µ–Ω–µ–¥–∂–µ—Ä–æ–≤", callback_data="admin_list_managers")],
        [InlineKeyboardButton("‚ûï –î–æ–±–∞–≤–∏—Ç—å/‚ûñ –£–¥–∞–ª–∏—Ç—å –º–µ–Ω–µ–¥–∂–µ—Ä–∞", callback_data="admin_manage_managers")],
        [InlineKeyboardButton("üë• –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–∞–º–∏", callback_data="admin_manage_employees")],
        [InlineKeyboardButton("ü§î –ö–∞–Ω–¥–∏–¥–∞—Ç—ã –Ω–∞ —Ä–∞—Å—Å–º–æ—Ç—Ä–µ–Ω–∏–∏", callback_data="admin_pending_candidates")],
        [InlineKeyboardButton("üìä –ó–∞–ø—É—Å—Ç–∏—Ç—å –∑–∞–º–µ—Ä –∫–ª–∏–º–∞—Ç–∞",
                              callback_data="admin_broadcast_climate_start")],
        [InlineKeyboardButton("üìà –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –æ–ø—Ä–æ—Å–æ–≤", callback_data="admin_stats")],
        [InlineKeyboardButton("üí¨ –û–±—Ä–∞—Ç–Ω–∞—è —Å–≤—è–∑—å –ø–æ –±–æ—Ç—É", callback_data="submit_bot_feedback")]
    ])


def get_back_to_admin_menu_keyboard() -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup([[InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é", callback_data=settings.CALLBACK_ADMIN_BACK)]])


def get_manager_menu_keyboard(pending_feedback_count: int = 0) -> InlineKeyboardMarkup:
    feedback_button_text = "üìù –û—Å—Ç–∞–≤–∏—Ç—å –û–° –ø–æ –∫–∞–Ω–¥–∏–¥–∞—Ç–∞–º"
    if pending_feedback_count > 0:
        feedback_button_text += f" ({pending_feedback_count} ‚ùóÔ∏è)"

    buttons = [
        [InlineKeyboardButton(feedback_button_text, callback_data="manager_feedback")],
        [InlineKeyboardButton("üí¨ –û–±—Ä–∞—Ç–Ω–∞—è —Å–≤—è–∑—å –ø–æ –±–æ—Ç—É", callback_data="submit_bot_feedback")]
    ]
    return InlineKeyboardMarkup(buttons)


def get_pending_feedback_keyboard(pending_tasks: List[Dict[str, Any]]) -> InlineKeyboardMarkup:
    buttons = []
    for task in pending_tasks:
        buttons.append([InlineKeyboardButton(f"üë§ {task['name']}", callback_data=f"fb_{task['id']}")])
    buttons.append([InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="main_menu")])
    return InlineKeyboardMarkup(buttons)


def get_shift_date_keyboard() -> InlineKeyboardMarkup:
    buttons = []
    today = get_now().date()
    for i in range(6):
        target_date = today + timedelta(days=i)
        day_name = target_date.strftime("%a").capitalize()
        date_str = target_date.strftime("%d %b")
        text = f"{day_name}, {date_str}"
        callback_data = f"shift_date_{target_date.isoformat()}"
        buttons.append(InlineKeyboardButton(text, callback_data=callback_data))

    keyboard_layout = [buttons[i:i + 2] for i in range(0, len(buttons), 2)]
    keyboard_layout.append([
        InlineKeyboardButton("–î—Ä—É–≥–∞—è –¥–∞—Ç–∞ (–≤–≤–µ—Å—Ç–∏ –≤—Ä—É—á–Ω—É—é)", callback_data="shift_date_other")
    ])

    return InlineKeyboardMarkup(keyboard_layout)

--- FILE: utils/helpers.py ---
import asyncio
import html
import logging
from typing import Optional, Tuple, List, Any
from datetime import datetime
from zoneinfo import ZoneInfo, ZoneInfoNotFoundError

from telegram import (
    Update,
    InlineKeyboardMarkup,
    CallbackQuery,
    MessageOriginUser,
    MessageOriginHiddenUser,
    MessageOriginChannel,
    InlineKeyboardButton,
    Message,
    Bot,
    BotCommand,
    BotCommandScopeChat,
)
from telegram.constants import ParseMode
from telegram.error import BadRequest, Forbidden, TelegramError
from telegram.ext import ContextTypes

from core import settings, database

logger = logging.getLogger(__name__)

try:
    TIMEZONE = ZoneInfo(settings.MOSCOW_TIMEZONE)
except ZoneInfoNotFoundError:
    logger.warning(f"Timezone '{settings.MOSCOW_TIMEZONE}' not found. Falling back to UTC.")
    TIMEZONE = ZoneInfo("UTC")


def get_now() -> datetime:
    return datetime.now(TIMEZONE)


def build_inline_keyboard(buttons: List[Tuple[str, str]], columns: int) -> InlineKeyboardMarkup:
    layout = [buttons[i:i + columns] for i in range(0, len(buttons), columns)]
    keyboard = [[InlineKeyboardButton(text, callback_data=data) for text, data in row] for row in layout]
    return InlineKeyboardMarkup(keyboard)


def get_user_data_from_update(update: Optional[Update]) -> Tuple[int, str, Optional[str]]:
    user = None
    chat_id = 0

    if update:
        if update.effective_user:
            user = update.effective_user
        elif hasattr(update, 'callback_query') and update.callback_query and update.callback_query.from_user:
            user = update.callback_query.from_user
        elif hasattr(update, 'my_chat_member') and update.my_chat_member and update.my_chat_member.from_user:
            user = update.my_chat_member.from_user
        elif hasattr(update, 'chat_member') and update.chat_member and update.chat_member.new_chat_member:
             user = update.chat_member.new_chat_member.user

    if user:
        user_id = user.id
        first_name = user.first_name
        full_name = f"{html.escape(first_name or '')} {html.escape(user.last_name or '')}".strip()
        user_display_name = f"@{user.username}" if user.username else full_name or f"User_{user_id}"
        return user_id, user_display_name, first_name

    if update and update.effective_chat:
        user_id = update.effective_chat.id
        return user_id, f"Chat_{user_id}", None

    logger.warning("Could not determine user or chat ID from update.")
    return 0, "Unknown User", None


async def set_user_commands(user_id: int, bot: Bot):
    if user_id == 0:
        return
    commands = []
    if user_id in settings.ADMIN_IDS:
        commands = [BotCommand("start", "‚≠ê –ü–∞–Ω–µ–ª—å –ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞")]
    elif await database.is_user_a_manager(user_id):
        commands = [BotCommand("start", "üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é –º–µ–Ω–µ–¥–∂–µ—Ä–∞")]

    try:
        current_commands = await bot.get_my_commands(scope=BotCommandScopeChat(chat_id=user_id))
        if [c.to_dict() for c in commands] != [c.to_dict() for c in current_commands]:
            await bot.set_my_commands(commands=commands, scope=BotCommandScopeChat(chat_id=user_id))
            logger.info(f"Updated commands for user {user_id}.")
    except (BadRequest, Forbidden) as e:
        logger.warning(f"Could not set commands for user {user_id}: {e}")


async def add_user_to_interacted(user_id: int, context: ContextTypes.DEFAULT_TYPE):
    if user_id == 0: return
    interacted_set = context.bot_data.setdefault("users_interacted", set())
    if user_id not in interacted_set:
        interacted_set.add(user_id)
        logger.info(f"Added user {user_id} to interacted set. Current size: {len(interacted_set)}")
        if context.application.persistence:
            try:
                await context.application.persistence.flush()
            except Exception as e:
                logger.error(f"Error flushing persistence after adding user: {e}")


async def safe_answer_callback_query(query: Optional[CallbackQuery]):
    if not query: return
    try:
        await query.answer()
    except BadRequest:
        pass
    except Forbidden:
        logger.warning(f"Forbidden to answer callback query {query.id}. Bot might be blocked.")
    except Exception as e:
        logger.error(f"Unexpected error answering callback query {query.id}: {e}", exc_info=True)


async def send_transient_message(context: ContextTypes.DEFAULT_TYPE, chat_id: int, text: str):
    try:
        message = await context.bot.send_message(chat_id=chat_id, text=text)
        transient_msgs = context.user_data.setdefault('transient_messages', [])
        transient_msgs.append(message.message_id)
    except (Forbidden, BadRequest) as e:
        logger.warning(f"Could not send transient message to {chat_id}: {e}")


async def cleanup_transient_messages(context: ContextTypes.DEFAULT_TYPE, chat_id: int):
    transient_msgs = context.user_data.pop('transient_messages', [])
    for msg_id in transient_msgs:
        try:
            await context.bot.delete_message(chat_id=chat_id, message_id=msg_id)
        except (BadRequest, Forbidden) as e:
            if "message to delete not found" not in str(e).lower():
                logger.warning(f"Could not delete transient message {msg_id} in chat {chat_id}: {e}")


async def send_or_edit_message(
    update: Update,
    context: ContextTypes.DEFAULT_TYPE,
    text: str,
    reply_markup: Optional[InlineKeyboardMarkup] = None,
    delete_user_message: bool = True
):
    chat_id = update.effective_chat.id
    active_message_id = context.user_data.get(settings.ACTIVE_MESSAGE_ID_KEY)

    await cleanup_transient_messages(context, chat_id)

    new_message = None
    try:
        if active_message_id:
            new_message = await context.bot.edit_message_text(
                chat_id=chat_id,
                message_id=active_message_id,
                text=text,
                reply_markup=reply_markup,
                parse_mode=ParseMode.HTML
            )
        else:
            new_message = await context.bot.send_message(
                chat_id, text, reply_markup=reply_markup, parse_mode=ParseMode.HTML
            )
    except BadRequest as e:
        if "Message is not modified" not in str(e):
            logger.warning(f"Could not edit message {active_message_id}, sending new one. Error: {e}")
            try:
                new_message = await context.bot.send_message(
                    chat_id, text, reply_markup=reply_markup, parse_mode=ParseMode.HTML
                )
            except (Forbidden, TelegramError) as send_e:
                 logger.error(f"Failed to send new message to chat {chat_id} after edit failed: {send_e}")
                 return
        else:
            pass
    except (Forbidden, TelegramError) as e:
        logger.error(f"Telegram API error for chat {chat_id}: {e}")
        return

    if update.message and delete_user_message:
        try:
            await update.message.delete()
        except (BadRequest, Forbidden):
            pass

    if new_message:
        context.user_data[settings.ACTIVE_MESSAGE_ID_KEY] = new_message.message_id


async def remove_keyboard_from_previous_message(context: ContextTypes.DEFAULT_TYPE, chat_id: int):
    active_message_id = context.user_data.pop(settings.ACTIVE_MESSAGE_ID_KEY, None)
    if active_message_id:
        try:
            await context.bot.edit_message_reply_markup(
                chat_id=chat_id,
                message_id=active_message_id,
                reply_markup=None
            )
        except (BadRequest, Forbidden):
            pass


async def send_new_menu_message(
        context: ContextTypes.DEFAULT_TYPE,
        chat_id: int,
        text: str,
        reply_markup: InlineKeyboardMarkup
):
    await remove_keyboard_from_previous_message(context, chat_id)
    try:
        new_message = await context.bot.send_message(
            chat_id=chat_id,
            text=text,
            reply_markup=reply_markup,
            parse_mode=ParseMode.HTML
        )
        context.user_data[settings.ACTIVE_MESSAGE_ID_KEY] = new_message.message_id
    except (Forbidden, BadRequest) as e:
        logger.error(f"Failed to send new menu message to {chat_id}: {e}")


async def get_id_from_input(update: Update, context: ContextTypes.DEFAULT_TYPE) -> Optional[int]:
    message = update.message

    if message.forward_origin:
        origin = message.forward_origin
        if isinstance(origin, MessageOriginUser):
            return origin.sender_user.id
        if isinstance(origin, MessageOriginChannel):
            await message.reply_text("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–µ—Ä–µ—à–ª–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, –∞ –Ω–µ –∏–∑ –∫–∞–Ω–∞–ª–∞.")
            return None
        if isinstance(origin, MessageOriginHiddenUser):
            await message.reply_text("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å ID, —Ç–∞–∫ –∫–∞–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å–∫—Ä—ã–ª —Å–≤–æ–π –∞–∫–∫–∞—É–Ω—Ç –ø—Ä–∏ –ø–µ—Ä–µ—Å—ã–ª–∫–µ. –ü–æ–ø—Ä–æ—Å–∏—Ç–µ –µ–≥–æ –Ω–∞–ø–∏—Å–∞—Ç—å –±–æ—Ç—É /start –∏ –ø–µ—Ä–µ—Å–ª–∞—Ç—å –µ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏–µ.")
            return None
        await message.reply_text("–≠—Ç–æ—Ç —Ç–∏–ø –ø–µ—Ä–µ—Å–ª–∞–Ω–Ω–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è.")
        return None

    text = message.text
    if not text:
        await message.reply_text("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Ç–µ–∫—Å—Ç: ID, @username –∏–ª–∏ –ø–µ—Ä–µ—à–ª–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ.")
        return None
    if text.isdigit():
        return int(text)
    if text.startswith('@'):
        try:
            chat = await context.bot.get_chat(text)
            if chat.id < 0:
                await message.reply_text(f"–£–∫–∞–∑–∞–Ω–Ω—ã–π {text} —è–≤–ª—è–µ—Ç—Å—è –≥—Ä—É–ø–ø–æ–π –∏–ª–∏ –∫–∞–Ω–∞–ª–æ–º, –∞ –Ω–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º.")
                return None
            return chat.id
        except (BadRequest, Forbidden) as e:
            logger.warning(f"Could not find user by username {text}: {e}")
            await message.reply_text(f"–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Å –Ω–∏–∫–æ–º {text}. –í–æ–∑–º–æ–∂–Ω–æ, –æ–Ω –Ω–µ –∑–∞–ø—É—Å–∫–∞–ª –±–æ—Ç–∞.")
            return None

    await message.reply_text(
        "–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–µ—Ä–µ—à–ª–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ, –≤–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ–≤–æ–π Telegram ID –∏–ª–∏ @username.")
    return None


async def add_to_sheets_queue(queue_name: str, data: List[Any]):
    if not data: return
    try:
        await database.add_to_sheets_db_queue(queue_name, data)
    except Exception as e:
        logger.error(f"Failed to add data to DB queue '{queue_name}': {e}", exc_info=True)


def format_user_for_sheets(user_id: int, full_name: str, username: Optional[str] = None) -> str:
    display_name = full_name
    if username:
        display_name += f" (@{username})"
    return f'=HYPERLINK("tg://user?id={user_id}"; "{display_name}")'

--- FILE: handlers/recruitment.py ---
import html
import logging
import re
import uuid
import asyncio

from telegram import Update, ReplyKeyboardRemove, InlineKeyboardMarkup, InlineKeyboardButton
from telegram.ext import (
    ContextTypes,
    ConversationHandler,
    CommandHandler,
    MessageHandler,
    CallbackQueryHandler,
    filters,
)
from telegram.constants import ParseMode
from telegram.error import BadRequest, Forbidden

from models import RecruitmentState
from core import settings, database, stickers
from utils.helpers import (
    get_user_data_from_update,
    safe_answer_callback_query,
    send_or_edit_message,
    send_transient_message,
    add_to_sheets_queue,
    add_user_to_interacted,
    get_now,
    format_user_for_sheets
)
from utils.keyboards import (
    RECRUITMENT_POSITION_OPTIONS,
    RESTAURANT_OPTIONS,
    YES_NO_OPTIONS,
    MARITAL_STATUS_OPTIONS,
    CHILDREN_OPTIONS,
    HEALTH_OPTIONS,
    ATTITUDE_TO_APPEARANCE_OPTIONS,
    EDUCATION_FORM_OPTIONS,
    COURSE_OPTIONS,
    EXPERIENCE_OPTIONS,
    INCOME_OPTIONS,
    JOBS_COUNT_OPTIONS,
    VACANCY_SOURCE_OPTIONS,
    build_inline_keyboard
)
from handlers.common import cancel, prompt_to_use_button
from handlers.feedback import schedule_candidate_feedback

logger = logging.getLogger(__name__)

TOTAL_QUESTIONS = 34
MIN_ANSWER_LENGTH = 10

WEEKLY_SHIFTS_OPTIONS = [
    ("1-2", "shifts_1_2"), ("2-3", "shifts_2_3"),
    ("3-4", "shifts_3_4"), ("4-5", "shifts_4_5"),
    ("5+", "shifts_5_plus")
]


def get_progress_bar(current_q: int, total_q: int) -> str:
    progress = int((current_q / total_q) * 10)
    filled = '‚ñà' * progress
    empty = '‚ñë' * (10 - progress)
    percent = int((current_q / total_q) * 100)
    return f"[{filled}{empty}] {percent}%"


def get_question_header(context: ContextTypes.DEFAULT_TYPE) -> str:
    current_q = context.user_data.setdefault('current_question_num', 1)
    progress_bar = get_progress_bar(current_q, TOTAL_QUESTIONS)
    return f"<b>–í–æ–ø—Ä–æ—Å {current_q}/{TOTAL_QUESTIONS}</b>\n<code>{progress_bar}</code>\n\n"


async def start_recruitment_flow(update: Update, context: ContextTypes.DEFAULT_TYPE) -> RecruitmentState:
    user = update.effective_user
    logger.info(f"User {user.id} starting RECRUITMENT flow with deeplink.")
    await add_user_to_interacted(user.id, context)
    context.user_data.clear()
    context.user_data['conversations'] = {'recruitment_conv': True} # –§–ª–∞–≥ –¥–ª—è /start

    if update.message:
        try:
            await update.message.delete()
        except (BadRequest, Forbidden):
            pass

    param = context.args[0] if context.args else ""
    if not param or not param.startswith("interview_"):
        await context.bot.send_message(
            update.effective_chat.id,
            "–û–π, –∫–∞–∂–µ—Ç—Å—è, –≤ —Å—Å—ã–ª–∫–µ –∏–ª–∏ QR-–∫–æ–¥–µ –æ—à–∏–±–∫–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ–±—Ä–∞—Ç–∏—Å—å –∫ –º–µ–Ω–µ–¥–∂–µ—Ä—É, —á—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å –∫–æ—Ä—Ä–µ–∫—Ç–Ω—É—é —Å—Å—ã–ª–∫—É."
        )
        return ConversationHandler.END

    restaurant_code_suffix = param.replace("interview_", "")
    restaurant_code = f"res_{restaurant_code_suffix}"
    restaurant_name = next((name for name, code in RESTAURANT_OPTIONS if code == restaurant_code), None)

    if not restaurant_name:
        await context.bot.send_message(
            update.effective_chat.id,
            "–ù–µ —Å–º–æ–≥–ª–∏ –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Ä–µ—Å—Ç–æ—Ä–∞–Ω –ø–æ —ç—Ç–æ–π —Å—Å—ã–ª–∫–µ. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ–±—Ä–∞—Ç–∏—Å—å –∫ –º–µ–Ω–µ–¥–∂–µ—Ä—É –∑–∞ –ø–æ–º–æ—â—å—é."
        )
        return ConversationHandler.END

    context.user_data['preselected_restaurant_code'] = restaurant_code_suffix
    context.user_data['preselected_restaurant_name'] = restaurant_name
    context.user_data['chat_id'] = update.effective_chat.id
    context.user_data['current_question_num'] = 1

    await context.bot.send_sticker(chat_id=user.id, sticker=stickers.get_random_greeting())
    await asyncio.sleep(0.5)

    header = get_question_header(context)
    text = (
        "Ciao! üëã\n\n"
        f"–†–∞–¥—ã, —á—Ç–æ —Ç—ã —Ö–æ—á–µ—à—å —Å—Ç–∞—Ç—å —á–∞—Å—Ç—å—é –∫–æ–º–∞–Ω–¥—ã ¬´–ú–∞—Ä—á–µ–ª–ª–∏—Å¬ª –≤ —Ä–µ—Å—Ç–æ—Ä–∞–Ω–µ –ø–æ –∞–¥—Ä–µ—Å—É: <b>{html.escape(restaurant_name)}</b>.\n\n"
        f"–ß—Ç–æ–±—ã –º—ã –º–æ–≥–ª–∏ –ø–æ–∑–Ω–∞–∫–æ–º–∏—Ç—å—Å—è –ø–æ–±–ª–∏–∂–µ, —è –∑–∞–¥–∞–º {TOTAL_QUESTIONS} –≤–æ–ø—Ä–æ—Å–æ–≤. –≠—Ç–æ –∑–∞–π–º–µ—Ç –æ–∫–æ–ª–æ 10-15 –º–∏–Ω—É—Ç.\n\n"
        "<i>–ü—Ä–æ–¥–æ–ª–∂–∞—è –¥–∏–∞–ª–æ–≥, —Ç—ã –¥–∞–µ—à—å —Å–æ–≥–ª–∞—Å–∏–µ –Ω–∞ –æ–±—Ä–∞–±–æ—Ç–∫—É —Å–≤–æ–∏—Ö –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö. –ú—ã –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ–º –∏—Ö –∫–æ–Ω—Ñ–∏–¥–µ–Ω—Ü–∏–∞–ª—å–Ω–æ—Å—Ç—å.</i>\n\n"
        f"{header}"
        "–ù–∞—á–Ω—ë–º? –ù–∞–ø–∏—à–∏, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, —Å–≤–æ–∏ –§–∞–º–∏–ª–∏—é, –ò–º—è –∏ –û—Ç—á–µ—Å—Ç–≤–æ –ø–æ–ª–Ω–æ—Å—Ç—å—é."
    )

    sent_message = await context.bot.send_message(
        chat_id=update.effective_chat.id,
        text=text,
        parse_mode=ParseMode.HTML,
        reply_markup=ReplyKeyboardRemove()
    )
    context.user_data[settings.ACTIVE_MESSAGE_ID_KEY] = sent_message.message_id

    return RecruitmentState.FULL_NAME


async def full_name_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> RecruitmentState:
    context.user_data.setdefault('current_question_num', 1)
    full_name = update.message.text.strip()
    if len(full_name.split()) < 2:
        await send_transient_message(context, update.effective_chat.id,
                                     "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –∫–∞–∫ –º–∏–Ω–∏–º—É–º –§–∞–º–∏–ª–∏—é –∏ –ò–º—è.")
        return RecruitmentState.FULL_NAME

    context.user_data['full_name'] = full_name
    first_name = full_name.split()[1] if len(full_name.split()) > 1 else full_name.split()[0]
    context.user_data['first_name'] = first_name

    context.user_data['current_question_num'] += 1
    header = get_question_header(context)
    text = (f"–û—Ç–ª–∏—á–Ω–æ, {html.escape(first_name)}, –ø—Ä–∏—è—Ç–Ω–æ –ø–æ–∑–Ω–∞–∫–æ–º–∏—Ç—å—Å—è! ‚ú®\n\n"
            f"{header}"
            '–°–∫–æ–ª—å–∫–æ —Ç–µ–±–µ –ø–æ–ª–Ω—ã—Ö –ª–µ—Ç?')

    await send_or_edit_message(update, context, text)

    return RecruitmentState.AGE


async def age_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int | RecruitmentState:
    context.user_data.setdefault('current_question_num', 2)
    age_text = update.message.text.strip()
    if not age_text.isdigit():
        await send_transient_message(context, update.effective_chat.id, "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ —Å–≤–æ–π –≤–æ–∑—Ä–∞—Å—Ç —Ü–∏—Ñ—Ä–∞–º–∏.")
        await update.message.delete()
        return RecruitmentState.AGE

    age = int(age_text)

    if age < 16:
        await send_or_edit_message(update, context,
                                   "–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, –º—ã –º–æ–∂–µ–º –ø—Ä–∏–Ω—è—Ç—å –Ω–∞ —Ä–∞–±–æ—Ç—É —Ç–æ–ª—å–∫–æ —Å 16 –ª–µ—Ç. –°–ø–∞—Å–∏–±–æ –∑–∞ —Ç–≤–æ–π –∏–Ω—Ç–µ—Ä–µ—Å, –±—É–¥–µ–º —Ä–∞–¥—ã –≤–∏–¥–µ—Ç—å —Ç–µ–±—è –≤ –±—É–¥—É—â–µ–º! üôè"
                                   )
        context.user_data.clear()
        return ConversationHandler.END

    if age > 100:
        await send_transient_message(context, update.effective_chat.id,
                                     "–í–≤–µ–¥–µ–Ω –º–∞–ª–æ–≤–µ—Ä–æ—è—Ç–Ω—ã–π –≤–æ–∑—Ä–∞—Å—Ç. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø—Ä–æ–≤–µ—Ä—å –∏ –≤–≤–µ–¥–∏ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ —á–∏—Å–ª–æ.")
        await update.message.delete()
        return RecruitmentState.AGE

    context.user_data['age'] = age_text
    context.user_data['current_question_num'] += 1
    header = get_question_header(context)
    text = f"–ü—Ä–∏–Ω—è—Ç–æ!\n\n{header}" \
           '–†–∞—Å—Å–∫–∞–∂–∏ –Ω–µ–º–Ω–æ–≥–æ –æ —Å–≤–æ–µ–π —Å–µ–º—å–µ (—Å –∫–µ–º —Ç—ã –∂–∏–≤–µ—à—å, –∫—Ç–æ —Ç–≤–æ–∏ –±–ª–∏–∑–∫–∏–µ).'
    await send_or_edit_message(update, context, text)
    return RecruitmentState.FAMILY_INFO


async def family_info_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> RecruitmentState:
    context.user_data.setdefault('current_question_num', 3)
    answer = update.message.text.strip()
    if len(answer) < MIN_ANSWER_LENGTH:
        await send_transient_message(context, update.effective_chat.id,
                                     f"–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –¥–∞–π –±–æ–ª–µ–µ —Ä–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–π –æ—Ç–≤–µ—Ç (—Ö–æ—Ç—è –±—ã {MIN_ANSWER_LENGTH} —Å–∏–º–≤–æ–ª–æ–≤).")
        return RecruitmentState.FAMILY_INFO

    context.user_data['family_info'] = answer
    context.user_data['current_question_num'] += 1
    header = get_question_header(context)
    keyboard = build_inline_keyboard(VACANCY_SOURCE_OPTIONS, columns=2)
    text = f"–°–ø–∞—Å–∏–±–æ, —á—Ç–æ –ø–æ–¥–µ–ª–∏–ª—Å—è(–∞—Å—å)!\n\n{header}" \
           '–û—Ç–∫—É–¥–∞ —Ç—ã —É–∑–Ω–∞–ª(–∞) –æ –≤–∞–∫–∞–Ω—Å–∏–∏?'
    await send_or_edit_message(update, context, text, keyboard)
    return RecruitmentState.VACANCY_SOURCE


async def vacancy_source_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> RecruitmentState:
    context.user_data.setdefault('current_question_num', 4)
    query = update.callback_query
    await safe_answer_callback_query(query)
    source = next((name for name, data in VACANCY_SOURCE_OPTIONS if data == query.data), "–î—Ä—É–≥–æ–µ")
    context.user_data['vacancy_source'] = source
    context.user_data['current_question_num'] += 1
    header = get_question_header(context)
    context.user_data.setdefault('selected_vacancies', [])
    buttons = [InlineKeyboardButton(f"{'‚úÖ ' if code in context.user_data['selected_vacancies'] else ''}{name}",
                                    callback_data=code) for name, code in RECRUITMENT_POSITION_OPTIONS]
    keyboard_layout = [buttons[i:i + 2] for i in range(0, len(buttons), 2)]
    keyboard_layout.append([InlineKeyboardButton("‚úîÔ∏è –ì–æ—Ç–æ–≤–æ", callback_data="done_vacancies")])
    text = f"{header}–ö–∞–∫–∞—è –≤–∞–∫–∞–Ω—Å–∏—è —Ç–µ–±—è –∏–Ω—Ç–µ—Ä–µ—Å—É–µ—Ç? (–º–æ–∂–Ω–æ –≤—ã–±—Ä–∞—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ)"
    await send_or_edit_message(update, context, text, InlineKeyboardMarkup(keyboard_layout))
    return RecruitmentState.AWAIT_MULTI_VACANCY


async def multi_vacancy_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> RecruitmentState:
    context.user_data.setdefault('current_question_num', 5)
    query = update.callback_query
    await safe_answer_callback_query(query)
    action = query.data
    selected_vacancies = context.user_data.setdefault('selected_vacancies', [])

    if action == "done_vacancies":
        if not selected_vacancies:
            await query.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏ —Ö–æ—Ç—è –±—ã –æ–¥–Ω—É –≤–∞–∫–∞–Ω—Å–∏—é.", show_alert=True)
            return RecruitmentState.AWAIT_MULTI_VACANCY

        if 'vac_Other' in selected_vacancies:
            await send_or_edit_message(update, context,
                                       "–¢—ã –≤—ã–±—Ä–∞–ª(–∞) '–î—Ä—É–≥–æ–µ'. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É—Ç–æ—á–Ω–∏, –∫–∞–∫–∞—è –¥–æ–ª–∂–Ω–æ—Å—Ç—å —Ç–µ–±—è –∏–Ω—Ç–µ—Ä–µ—Å—É–µ—Ç?")
            return RecruitmentState.AWAIT_OTHER_VACANCY

        context.user_data['applied_position'] = ", ".join(
            [next(name for name, code in RECRUITMENT_POSITION_OPTIONS if code == v_code) for v_code in
             selected_vacancies])
        context.user_data['current_question_num'] += 1
        header = get_question_header(context)
        text = f"–í—ã–±—Ä–∞–Ω–æ: <b>{html.escape(context.user_data['applied_position'])}</b>.\n\n{header}–ü–æ—á–µ–º—É –∏–º–µ–Ω–Ω–æ —ç—Ç–∞ —Ä–∞–±–æ—Ç–∞/–≤–∞–∫–∞–Ω—Å–∏—è —Ç–µ–±—è –ø—Ä–∏–≤–ª–µ–∫–∞–µ—Ç?"
        await send_or_edit_message(update, context, text)
        return RecruitmentState.REASON_FOR_CHOICE

    if action in selected_vacancies:
        selected_vacancies.remove(action)
    else:
        selected_vacancies.append(action)

    buttons = [InlineKeyboardButton(f"{'‚úÖ ' if code in selected_vacancies else ''}{name}", callback_data=code) for
               name, code in RECRUITMENT_POSITION_OPTIONS]
    keyboard_layout = [buttons[i:i + 2] for i in range(0, len(buttons), 2)]
    keyboard_layout.append([InlineKeyboardButton("‚úîÔ∏è –ì–æ—Ç–æ–≤–æ", callback_data="done_vacancies")])
    await query.edit_message_reply_markup(reply_markup=InlineKeyboardMarkup(keyboard_layout))
    return RecruitmentState.AWAIT_MULTI_VACANCY


async def other_vacancy_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> RecruitmentState:
    other_position = update.message.text.strip()
    selected_vacancies = context.user_data.get('selected_vacancies', [])

    # –§–æ—Ä–º–∏—Ä—É–µ–º –∏—Ç–æ–≥–æ–≤—ã–π —Å–ø–∏—Å–æ–∫ –¥–æ–ª–∂–Ω–æ—Å—Ç–µ–π
    final_positions = []
    for code in selected_vacancies:
        if code == 'vac_Other':
            final_positions.append(other_position)
        else:
            final_positions.append(next(name for name, c in RECRUITMENT_POSITION_OPTIONS if c == code))

    context.user_data['applied_position'] = ", ".join(final_positions)
    context.user_data['current_question_num'] += 1
    header = get_question_header(context)
    text = f"–í—ã–±—Ä–∞–Ω–æ: <b>{html.escape(context.user_data['applied_position'])}</b>.\n\n{header}–ü–æ—á–µ–º—É –∏–º–µ–Ω–Ω–æ —ç—Ç–∞ —Ä–∞–±–æ—Ç–∞/–≤–∞–∫–∞–Ω—Å–∏—è —Ç–µ–±—è –ø—Ä–∏–≤–ª–µ–∫–∞–µ—Ç?"
    await send_or_edit_message(update, context, text)
    return RecruitmentState.REASON_FOR_CHOICE


async def reason_for_choice_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> RecruitmentState:
    context.user_data.setdefault('current_question_num', 6)
    answer = update.message.text.strip()
    if len(answer) < MIN_ANSWER_LENGTH:
        await send_transient_message(context, update.effective_chat.id,
                                     f"–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –¥–∞–π –±–æ–ª–µ–µ —Ä–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–π –æ—Ç–≤–µ—Ç (—Ö–æ—Ç—è –±—ã {MIN_ANSWER_LENGTH} —Å–∏–º–≤–æ–ª–æ–≤).")
        return RecruitmentState.REASON_FOR_CHOICE

    context.user_data['reason_for_choice'] = answer
    context.user_data['current_question_num'] += 1
    header = get_question_header(context)
    context.user_data.setdefault('preferred_restaurants', [])
    buttons = [
        InlineKeyboardButton(f"{'‚úÖ ' if code in context.user_data.get('preferred_restaurant_codes', []) else ''}{name}",
                             callback_data=code) for name, code in RESTAURANT_OPTIONS]
    keyboard_layout = [buttons[i:i + 2] for i in range(0, len(buttons), 2)]
    keyboard_layout.append([InlineKeyboardButton("‚úîÔ∏è –ì–æ—Ç–æ–≤–æ", callback_data="done_restaurants")])
    text = f"–ò–Ω—Ç–µ—Ä–µ—Å–Ω—ã–π –≤—ã–±–æ—Ä! –°–ø–∞—Å–∏–±–æ.\n\n{header}" \
           '–í –∫–∞–∫–æ–º –∏–∑ –Ω–∞—à–∏—Ö —Ä–µ—Å—Ç–æ—Ä–∞–Ω–æ–≤ —Ç—ã —Ö–æ—Ç–µ–ª(–∞) –±—ã —Ä–∞–±–æ—Ç–∞—Ç—å? (–º–æ–∂–Ω–æ –≤—ã–±—Ä–∞—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ)'
    await send_or_edit_message(update, context, text, InlineKeyboardMarkup(keyboard_layout))
    return RecruitmentState.AWAIT_MULTI_RESTAURANT


async def multi_restaurant_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> RecruitmentState:
    context.user_data.setdefault('current_question_num', 7)
    query = update.callback_query
    await safe_answer_callback_query(query)
    action = query.data
    selected_restaurants_codes = context.user_data.setdefault('preferred_restaurant_codes', [])

    if action == "done_restaurants":
        if not selected_restaurants_codes:
            await query.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏ —Ö–æ—Ç—è –±—ã –æ–¥–∏–Ω —Ä–µ—Å—Ç–æ—Ä–∞–Ω.", show_alert=True)
            return RecruitmentState.AWAIT_MULTI_RESTAURANT

        context.user_data['preferred_restaurant'] = ", ".join(
            [next(name for name, code in RESTAURANT_OPTIONS if code == r_code) for r_code in
             selected_restaurants_codes])
        context.user_data['current_question_num'] += 1
        header = get_question_header(context)
        keyboard = build_inline_keyboard(YES_NO_OPTIONS, columns=2)
        text = f"{header}–¢—ã —É–∂–µ –∑–Ω–∞–∫–æ–º(–∞) —Å —Ä–µ—Å—Ç–æ—Ä–∞–Ω–∞–º–∏ ¬´–ú–∞—Ä—á–µ–ª–ª–∏—Å¬ª –∫–∞–∫ –≥–æ—Å—Ç—å?"
        await send_or_edit_message(update, context, text, keyboard)
        return RecruitmentState.KNOWS_MARCELLIS

    if action in selected_restaurants_codes:
        selected_restaurants_codes.remove(action)
    else:
        selected_restaurants_codes.append(action)

    buttons = [InlineKeyboardButton(f"{'‚úÖ ' if code in selected_restaurants_codes else ''}{name}", callback_data=code)
               for name, code in RESTAURANT_OPTIONS]
    keyboard_layout = [buttons[i:i + 2] for i in range(0, len(buttons), 2)]
    keyboard_layout.append([InlineKeyboardButton("‚úîÔ∏è –ì–æ—Ç–æ–≤–æ", callback_data="done_restaurants")])
    await query.edit_message_reply_markup(reply_markup=InlineKeyboardMarkup(keyboard_layout))
    return RecruitmentState.AWAIT_MULTI_RESTAURANT


async def knows_marcellis_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> RecruitmentState:
    context.user_data.setdefault('current_question_num', 8)
    query = update.callback_query
    await safe_answer_callback_query(query)
    context.user_data['knows_marcellis'] = "–î–∞" if query.data == "yes" else "–ù–µ—Ç"
    context.user_data['current_question_num'] += 1
    header = get_question_header(context)
    keyboard = build_inline_keyboard(YES_NO_OPTIONS, columns=2)
    text = f"{header}üåô –ì–æ—Ç–æ–≤(–∞) –ª–∏ —Ç—ã –∫ –Ω–æ—á–Ω—ã–º —Å–º–µ–Ω–∞–º?"
    await send_or_edit_message(update, context, text, keyboard)
    return RecruitmentState.NIGHT_SHIFTS


async def night_shifts_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> RecruitmentState:
    context.user_data.setdefault('current_question_num', 9)
    query = update.callback_query
    await safe_answer_callback_query(query)
    context.user_data['night_shifts'] = "–î–∞" if query.data == "yes" else "–ù–µ—Ç"
    context.user_data['current_question_num'] += 1
    header = get_question_header(context)
    keyboard = build_inline_keyboard(WEEKLY_SHIFTS_OPTIONS, columns=3)
    text = f"{header}üóìÔ∏è –°–∫–æ–ª—å–∫–æ –ø–æ–ª–Ω—ã—Ö —Å–º–µ–Ω –≤ –Ω–µ–¥–µ–ª—é —Ç—ã –≥–æ—Ç–æ–≤(–∞) –Ω–∞–º —É–¥–µ–ª—è—Ç—å? (–µ—Å–ª–∏ –ø–æ–ª–Ω–∞—è —Å–º–µ–Ω–∞ = 12 —á–∞—Å–æ–≤)"
    await send_or_edit_message(update, context, text, keyboard)
    return RecruitmentState.WEEKLY_SHIFTS


async def weekly_shifts_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> RecruitmentState:
    context.user_data.setdefault('current_question_num', 10)
    query = update.callback_query
    await safe_answer_callback_query(query)
    answer = next((name for name, data in WEEKLY_SHIFTS_OPTIONS if data == query.data), "–ù–µ —É–∫–∞–∑–∞–Ω–æ")
    context.user_data['weekly_shifts'] = answer
    context.user_data['current_question_num'] += 1
    header = get_question_header(context)
    text = f"{header}üì± –û—Å—Ç–∞–≤—å, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, —Å–≤–æ–π –º–æ–±–∏–ª—å–Ω—ã–π —Ç–µ–ª–µ—Ñ–æ–Ω –¥–ª—è —Å–≤—è–∑–∏ (–Ω–∞–ø—Ä–∏–º–µ—Ä, +79991234567):"
    await send_or_edit_message(update, context, text)
    return RecruitmentState.MOBILE_PHONE


async def mobile_phone_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> RecruitmentState:
    context.user_data.setdefault('current_question_num', 11)
    phone_text = update.message.text.strip()
    cleaned_phone = re.sub(r'\D', '', phone_text)
    if len(cleaned_phone) == 11 and cleaned_phone.startswith(('7', '8')):
        cleaned_phone = cleaned_phone[1:]
    if len(cleaned_phone) != 10:
        await send_transient_message(context, update.effective_chat.id,
                                     "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π 10-–∑–Ω–∞—á–Ω—ã–π –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, +7 999 123-45-67).")
        await update.message.delete()
        return RecruitmentState.MOBILE_PHONE
    context.user_data['mobile_phone'] = f"+7{cleaned_phone}"
    context.user_data['current_question_num'] += 1
    header = get_question_header(context)
    text = f"–ó–∞–ø–∏—Å–∞–ª!\n\n{header}üåê –ï—Å—Ç—å —Å—Å—ã–ª–∫–∞ –Ω–∞ —Ç–≤–æ–π –ø—Ä–æ—Ñ–∏–ª—å –≤ —Å–æ—Ü—Å–µ—Ç—è—Ö (VK, Instagram –∏ —Ç.–¥.)? –ï—Å–ª–∏ –Ω–µ—Ç, –ø—Ä–æ—Å—Ç–æ –Ω–∞–ø–∏—à–∏ ¬´–Ω–µ—Ç¬ª."
    await send_or_edit_message(update, context, text)
    return RecruitmentState.SOCIAL_LINK


async def social_link_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> RecruitmentState:
    context.user_data.setdefault('current_question_num', 12)
    context.user_data['social_link'] = update.message.text.strip()
    context.user_data['current_question_num'] += 1
    header = get_question_header(context)
    text = f"–û–∫–µ–π!\n\n{header}üèôÔ∏è –í –∫–∞–∫–æ–º –≥–æ—Ä–æ–¥–µ —Ç—ã —Ä–æ–¥–∏–ª—Å—è(–∞—Å—å)?"
    await send_or_edit_message(update, context, text)
    return RecruitmentState.CITY


async def city_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> RecruitmentState:
    context.user_data.setdefault('current_question_num', 13)
    context.user_data['city'] = update.message.text.strip()
    context.user_data['current_question_num'] += 1
    header = get_question_header(context)
    text = f"–ü–æ–Ω—è—Ç–Ω–æ!\n\n{header}üè† –ê –≥–¥–µ —Ç—ã —Å–µ–π—á–∞—Å –∂–∏–≤–µ—à—å (–≥–æ—Ä–æ–¥, —Ä–∞–π–æ–Ω, –±–ª–∏–∂–∞–π—à–µ–µ –º–µ—Ç—Ä–æ)?"
    await send_or_edit_message(update, context, text)
    return RecruitmentState.ADDRESS


async def address_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> RecruitmentState:
    context.user_data.setdefault('current_question_num', 14)
    context.user_data['address'] = update.message.text.strip()
    context.user_data['current_question_num'] += 1
    header = get_question_header(context)
    keyboard = build_inline_keyboard(MARITAL_STATUS_OPTIONS, columns=2)
    text = f"–ü—Ä–∏–Ω—è—Ç–æ, –¥–≤–∏–≥–∞–µ–º—Å—è –¥–∞–ª—å—à–µ.\n\n{header}–ö–∞–∫–æ–≤–æ —Ç–≤–æ–µ —Å–µ–º–µ–π–Ω–æ–µ –ø–æ–ª–æ–∂–µ–Ω–∏–µ?"
    await send_or_edit_message(update, context, text, keyboard)
    return RecruitmentState.MARITAL_STATUS


async def marital_status_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> RecruitmentState:
    context.user_data.setdefault('current_question_num', 15)
    query = update.callback_query
    await safe_answer_callback_query(query)
    status = next((name for name, data in MARITAL_STATUS_OPTIONS if data == query.data), "–ù–µ —É–∫–∞–∑–∞–Ω–æ")
    context.user_data['marital_status'] = status
    context.user_data['current_question_num'] += 1
    header = get_question_header(context)
    keyboard = build_inline_keyboard(CHILDREN_OPTIONS, columns=4)
    text = f"{header}üë∂ –ï—Å—Ç—å –ª–∏ —É —Ç–µ–±—è –¥–µ—Ç–∏?"
    await send_or_edit_message(update, context, text, keyboard)
    return RecruitmentState.CHILDREN


async def children_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> RecruitmentState:
    context.user_data.setdefault('current_question_num', 16)
    query = update.callback_query
    await safe_answer_callback_query(query)
    answer = next((text for text, data in CHILDREN_OPTIONS if data == query.data), "–ù–µ —É–∫–∞–∑–∞–Ω–æ")
    context.user_data['children'] = answer
    context.user_data['current_question_num'] += 1
    header = get_question_header(context)
    keyboard = build_inline_keyboard(HEALTH_OPTIONS, columns=2)
    text = f"{header}üí™ –ö–∞–∫ —Ç—ã –æ—Ü–µ–Ω–∏–≤–∞–µ—à—å —É—Ä–æ–≤–µ–Ω—å —Å–≤–æ–µ–≥–æ –∑–¥–æ—Ä–æ–≤—å—è?"
    await send_or_edit_message(update, context, text, keyboard)
    return RecruitmentState.HEALTH_ASSESSMENT


async def health_assessment_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> RecruitmentState:
    context.user_data.setdefault('current_question_num', 17)
    query = update.callback_query
    await safe_answer_callback_query(query)
    answer = next((text for text, data in HEALTH_OPTIONS if data == query.data), "–ù–µ —É–∫–∞–∑–∞–Ω–æ")
    context.user_data['health_assessment'] = answer
    context.user_data['current_question_num'] += 1
    header = get_question_header(context)
    keyboard = build_inline_keyboard(ATTITUDE_TO_APPEARANCE_OPTIONS, columns=1)
    text = f"{header}‚ú® –ö–∞–∫ —Ç—ã –æ—Ç–Ω–æ—Å–∏—à—å—Å—è –∫ —Å–≤–æ–µ–π –≤–Ω–µ—à–Ω–æ—Å—Ç–∏?"
    await send_or_edit_message(update, context, text, keyboard)
    return RecruitmentState.ATTITUDE_TO_APPEARANCE


async def attitude_to_appearance_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> RecruitmentState:
    context.user_data.setdefault('current_question_num', 18)
    query = update.callback_query
    await safe_answer_callback_query(query)
    attitude = next((name for name, data in ATTITUDE_TO_APPEARANCE_OPTIONS if data == query.data), "–ù–µ —É–∫–∞–∑–∞–Ω–æ")
    context.user_data['attitude_to_appearance'] = attitude
    context.user_data['current_question_num'] += 1
    header = get_question_header(context)
    text = f"{header}üéì –ù–∞–ø–∏—à–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ —Ç–≤–æ–µ–≥–æ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ —É—á–µ–±–Ω–æ–≥–æ –∑–∞–≤–µ–¥–µ–Ω–∏—è (–ø–æ–ª–Ω–æ—Å—Ç—å—é):"
    await send_or_edit_message(update, context, text)
    return RecruitmentState.EDUCATION_NAME


async def education_name_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> RecruitmentState:
    context.user_data.setdefault('current_question_num', 19)
    context.user_data['education_name'] = update.message.text.strip()
    context.user_data['current_question_num'] += 1
    header = get_question_header(context)
    text = f"–°—É–ø–µ—Ä!\n\n{header}üìÖ –ì–æ–¥ –ø–æ—Å—Ç—É–ø–ª–µ–Ω–∏—è / –≥–æ–¥ –æ–∫–æ–Ω—á–∞–Ω–∏—è:"
    await send_or_edit_message(update, context, text)
    return RecruitmentState.GRADUATION_YEAR


async def graduation_year_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> RecruitmentState:
    context.user_data.setdefault('current_question_num', 20)
    context.user_data['graduation_year'] = update.message.text.strip()
    context.user_data['current_question_num'] += 1
    header = get_question_header(context)
    keyboard = build_inline_keyboard(COURSE_OPTIONS, columns=4)
    text = f"–ó–∞–ø–∏—Å–∞–ª.\n\n{header}üî¢ –ù–∞ –∫–∞–∫–æ–º –∫—É—Ä—Å–µ —É—á–∏—à—å—Å—è —Å–µ–π—á–∞—Å?"
    await send_or_edit_message(update, context, text, keyboard)
    return RecruitmentState.COURSE


async def course_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> RecruitmentState:
    context.user_data.setdefault('current_question_num', 21)
    query = update.callback_query
    await safe_answer_callback_query(query)
    course = next((name for name, data in COURSE_OPTIONS if data == query.data), "–ù–µ —É–∫–∞–∑–∞–Ω–æ")
    context.user_data['course'] = course
    context.user_data['current_question_num'] += 1
    header = get_question_header(context)
    keyboard = build_inline_keyboard(EDUCATION_FORM_OPTIONS, columns=2)
    text = f"–ü—Ä–∏–Ω—è—Ç–æ.\n\n{header}üèõÔ∏è –§–æ—Ä–º–∞ –æ–±—É—á–µ–Ω–∏—è:"
    await send_or_edit_message(update, context, text, keyboard)
    return RecruitmentState.EDUCATION_FORM


async def education_form_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> RecruitmentState:
    context.user_data.setdefault('current_question_num', 22)
    query = update.callback_query
    await safe_answer_callback_query(query)
    form = next((name for name, data in EDUCATION_FORM_OPTIONS if data == query.data), "–ù–µ —É–∫–∞–∑–∞–Ω–æ")
    context.user_data['education_form'] = form
    context.user_data['current_question_num'] += 1
    header = get_question_header(context)
    keyboard = InlineKeyboardMarkup([
        [InlineKeyboardButton("–î–∞, –Ω–∞–ø–∏—à—É", callback_data="courses_yes")],
        [InlineKeyboardButton("–ù–µ—Ç", callback_data="courses_no")]
    ])
    text = f"{header}üìö –ü—Ä–æ—Ö–æ–¥–∏–ª(–∞) –ª–∏ —Ç—ã –∫–∞–∫–∏–µ-–ª–∏–±–æ –∫—É—Ä—Å—ã, —Ç—Ä–µ–Ω–∏–Ω–≥–∏, —Å–µ–º–∏–Ω–∞—Ä—ã?"
    await send_or_edit_message(update, context, text, keyboard)
    return RecruitmentState.AWAIT_ADDITIONAL_COURSES_DECISION


async def additional_courses_decision_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> RecruitmentState:
    context.user_data.setdefault('current_question_num', 23)
    query = update.callback_query
    await safe_answer_callback_query(query)

    if query.data == "courses_yes":
        await send_or_edit_message(update, context, "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–µ—Ä–µ—á–∏—Å–ª–∏ –∏—Ö:")
        return RecruitmentState.ADDITIONAL_COURSES
    else:
        context.user_data['additional_courses'] = "–ù–µ—Ç"
        context.user_data['current_question_num'] += 1
        header = get_question_header(context)
        keyboard = build_inline_keyboard(EXPERIENCE_OPTIONS, columns=2)
        text = f"–ü—Ä–∏–Ω—è—Ç–æ!\n\n{header}üë∑‚Äç‚ôÇÔ∏è –ï—Å—Ç—å –ª–∏ —É —Ç–µ–±—è –æ–ø—ã—Ç —Ä–∞–±–æ—Ç—ã –Ω–∞ —Ç–æ–π –ø–æ–∑–∏—Ü–∏–∏, –Ω–∞ –∫–æ—Ç–æ—Ä—É—é –ø—Ä–µ—Ç–µ–Ω–¥—É–µ—à—å?"
        await send_or_edit_message(update, context, text, keyboard)
        return RecruitmentState.EXPERIENCE_DURATION


async def additional_courses_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> RecruitmentState:
    context.user_data.setdefault('current_question_num', 23)
    context.user_data['additional_courses'] = update.message.text.strip()
    context.user_data['current_question_num'] += 1
    header = get_question_header(context)
    keyboard = build_inline_keyboard(EXPERIENCE_OPTIONS, columns=2)
    text = f"–ü—Ä–∏–Ω—è—Ç–æ!\n\n{header}üë∑‚Äç‚ôÇÔ∏è –ï—Å—Ç—å –ª–∏ —É —Ç–µ–±—è –æ–ø—ã—Ç —Ä–∞–±–æ—Ç—ã –Ω–∞ —Ç–æ–π –ø–æ–∑–∏—Ü–∏–∏, –Ω–∞ –∫–æ—Ç–æ—Ä—É—é –ø—Ä–µ—Ç–µ–Ω–¥—É–µ—à—å?"
    await send_or_edit_message(update, context, text, keyboard)
    return RecruitmentState.EXPERIENCE_DURATION


async def experience_duration_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> RecruitmentState:
    context.user_data.setdefault('current_question_num', 24)
    query = update.callback_query
    await safe_answer_callback_query(query)
    answer = next((text for text, data in EXPERIENCE_OPTIONS if data == query.data), "–ù–µ —É–∫–∞–∑–∞–Ω–æ")
    context.user_data['experience_duration'] = answer
    context.user_data['current_question_num'] += 1

    if query.data == "exp_0":
        context.user_data['experience_details'] = "–ù–µ—Ç"
        context.user_data['current_question_num'] += 1
        header = get_question_header(context)
        keyboard = build_inline_keyboard(INCOME_OPTIONS, columns=2)
        text = f"{header}üí∞ –ù–∞ –∫–∞–∫–æ–π –¥–æ—Ö–æ–¥ –≤ –º–µ—Å—è—Ü —Ç—ã —Ä–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ—à—å?"
        await send_or_edit_message(update, context, text, keyboard)
        return RecruitmentState.EXPECTED_INCOME
    else:
        header = get_question_header(context)
        text = f"{header}üè¢ –û–ø–∏—à–∏ —Å–≤–æ–π –ø–æ—Å–ª–µ–¥–Ω–∏–π –æ–ø—ã—Ç: –Ω–∞–∑–≤–∞–Ω–∏–µ –∫–æ–º–ø–∞–Ω–∏–∏, –¥–∞—Ç—ã —Ä–∞–±–æ—Ç—ã, –¥–æ–ª–∂–Ω–æ—Å—Ç—å –∏ –æ–±—è–∑–∞–Ω–Ω–æ—Å—Ç–∏."
        await send_or_edit_message(update, context, text)
        return RecruitmentState.AWAIT_EXPERIENCE_DETAILS


async def experience_details_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> RecruitmentState:
    context.user_data.setdefault('current_question_num', 25)
    context.user_data['experience_details'] = update.message.text.strip()
    context.user_data['current_question_num'] += 1
    header = get_question_header(context)
    keyboard = build_inline_keyboard(INCOME_OPTIONS, columns=2)
    text = f"–ü–æ–¥—Ä–æ–±–Ω–æ! –°–ø–∞—Å–∏–±–æ.\n\n{header}üí∞ –ù–∞ –∫–∞–∫–æ–π –¥–æ—Ö–æ–¥ –≤ –º–µ—Å—è—Ü —Ç—ã —Ä–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ—à—å?"
    await send_or_edit_message(update, context, text, keyboard)
    return RecruitmentState.EXPECTED_INCOME


async def expected_income_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> RecruitmentState:
    context.user_data.setdefault('current_question_num', 26)
    query = update.callback_query
    await safe_answer_callback_query(query)
    answer = next((text for text, data in INCOME_OPTIONS if data == query.data), "–ù–µ —É–∫–∞–∑–∞–Ω–æ")
    context.user_data['expected_income'] = answer
    context.user_data['current_question_num'] += 1
    header = get_question_header(context)
    text = f"{header}üö∂‚Äç‚ôÇÔ∏è –ö–∞–∫–æ–≤–∞ –±—ã–ª–∞ –Ω–∞—Å—Ç–æ—è—â–∞—è –ø—Ä–∏—á–∏–Ω–∞ —É—Ö–æ–¥–∞ —Å –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –º–µ—Å—Ç–∞ —Ä–∞–±–æ—Ç—ã?"
    await send_or_edit_message(update, context, text)
    return RecruitmentState.REASON_FOR_LEAVING


async def reason_for_leaving_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> RecruitmentState:
    context.user_data.setdefault('current_question_num', 27)
    answer = update.message.text.strip()
    if len(answer) < MIN_ANSWER_LENGTH:
        await send_transient_message(context, update.effective_chat.id,
                                     f"–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –¥–∞–π –±–æ–ª–µ–µ —Ä–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–π –æ—Ç–≤–µ—Ç (—Ö–æ—Ç—è –±—ã {MIN_ANSWER_LENGTH} —Å–∏–º–≤–æ–ª–æ–≤).")
        return RecruitmentState.REASON_FOR_LEAVING
    context.user_data['reason_for_leaving'] = answer
    context.user_data['current_question_num'] += 1
    header = get_question_header(context)
    keyboard = build_inline_keyboard(JOBS_COUNT_OPTIONS, columns=3)
    text = f"–°–ø–∞—Å–∏–±–æ –∑–∞ —á–µ—Å—Ç–Ω–æ—Å—Ç—å.\n\n{header}üè¢ –£–∫–∞–∂–∏ –æ–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–æ–º–ø–∞–Ω–∏–π, –≥–¥–µ —Ç—ã –∫–æ–≥–¥–∞-–ª–∏–±–æ —Ä–∞–±–æ—Ç–∞–ª(–∞):"
    await send_or_edit_message(update, context, text, keyboard)
    return RecruitmentState.PREVIOUS_JOBS_COUNT


async def previous_jobs_count_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> RecruitmentState:
    context.user_data.setdefault('current_question_num', 28)
    query = update.callback_query
    await safe_answer_callback_query(query)
    answer = next((text for text, data in JOBS_COUNT_OPTIONS if data == query.data), "–ù–µ —É–∫–∞–∑–∞–Ω–æ")
    context.user_data['previous_jobs_count'] = answer
    context.user_data['current_question_num'] += 1
    header = get_question_header(context)
    text = f"–û—Ç–ª–∏—á–Ω–æ! –û—Å—Ç–∞–ª–æ—Å—å —Å–æ–≤—Å–µ–º –Ω–µ–º–Ω–æ–≥–æ –≤–æ–ø—Ä–æ—Å–æ–≤ –æ —Ç–µ–±–µ –∫–∞–∫ –æ –ª–∏—á–Ω–æ—Å—Ç–∏.\n\n{header}ü§∏‚Äç‚ôÇÔ∏è –†–∞—Å—Å–∫–∞–∂–∏ –æ —Å–≤–æ–µ–º –æ—Ç–Ω–æ—à–µ–Ω–∏–∏ –∫ —Å–ø–æ—Ä—Ç—É (–∑–∞–Ω–∏–º–∞–µ—à—å—Å—è –ª–∏, —á–µ–º —É–≤–ª–µ–∫–∞–µ—à—å—Å—è):"
    await send_or_edit_message(update, context, text)
    return RecruitmentState.ATTITUDE_TO_SPORT


async def attitude_to_sport_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> RecruitmentState:
    context.user_data.setdefault('current_question_num', 29)
    context.user_data['attitude_to_sport'] = update.message.text.strip()
    context.user_data['current_question_num'] += 1
    header = get_question_header(context)
    text = f"–ó–¥–æ—Ä–æ–≤–æ!\n\n{header}‚ú® –ü–µ—Ä–µ—á–∏—Å–ª–∏ —Ç—Ä–∏ —Å–∞–º—ã—Ö —Ü–µ–Ω–Ω—ã—Ö –¥–ª—è —Ç–µ–±—è –∫–∞—á–µ—Å—Ç–≤–∞ –≤ —Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª–µ."
    await send_or_edit_message(update, context, text)
    return RecruitmentState.LIFE_VALUES


async def life_values_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> RecruitmentState:
    context.user_data.setdefault('current_question_num', 30)
    context.user_data['life_values'] = update.message.text.strip()
    context.user_data['current_question_num'] += 1
    header = get_question_header(context)
    text = f"–ò–Ω—Ç–µ—Ä–µ—Å–Ω—ã–π –≤–∑–≥–ª—è–¥!\n\n{header}ü™® –ù–∞–∑–æ–≤–∏ —Å–≤–æ–∏ –≥–ª–∞–≤–Ω—ã–µ –¥–æ—Å—Ç–æ–∏–Ω—Å—Ç–≤–∞ –∫–∞–∫ —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–∞."
    await send_or_edit_message(update, context, text)
    return RecruitmentState.LIFE_WEAKNESSES


async def life_weaknesses_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> RecruitmentState:
    context.user_data.setdefault('current_question_num', 31)
    context.user_data['life_weaknesses'] = update.message.text.strip()
    context.user_data['current_question_num'] += 1
    header = get_question_header(context)
    text = f"–°–ø–∞—Å–∏–±–æ!\n\n{header}üéØ –í –∫–∞–∫–æ–π —Å—Ñ–µ—Ä–µ —Ç—ã —Ö–æ—Ç–µ–ª(–∞) –±—ã —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å—Å—è –≤ –∂–∏–∑–Ω–∏?"
    await send_or_edit_message(update, context, text)
    return RecruitmentState.LIFE_GOAL


async def life_goal_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> RecruitmentState:
    context.user_data.setdefault('current_question_num', 32)
    context.user_data['life_goal'] = update.message.text.strip()
    context.user_data['current_question_num'] += 1
    header = get_question_header(context)
    text = f"–•–æ—Ä–æ—à–∞—è —Ü–µ–ª—å!\n\n{header}üìñ –ö–∞–∫—É—é –∫–Ω–∏–≥—É —Ç—ã —Å–µ–π—á–∞—Å —á–∏—Ç–∞–µ—à—å –∏–ª–∏ –∫–∞–∫–æ–π –∫—É—Ä—Å –ø—Ä–æ—Ö–æ–¥–∏—à—å?"
    await send_or_edit_message(update, context, text)
    return RecruitmentState.READING_NOW


async def reading_now_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> RecruitmentState:
    context.user_data.setdefault('current_question_num', 33)
    context.user_data['reading_now'] = update.message.text.strip()
    context.user_data['current_question_num'] += 1
    header = get_question_header(context)
    keyboard = build_inline_keyboard(YES_NO_OPTIONS, columns=2)
    text = f"–ò –ø–æ—Å–ª–µ–¥–Ω–∏–π –≤–æ–ø—Ä–æ—Å, —Ñ–∏–Ω–∏—à–Ω–∞—è –ø—Ä—è–º–∞—è!\n\n{header}‚öñÔ∏è –ï—Å—Ç—å –ª–∏ —É —Ç–µ–±—è —Å—É–¥–∏–º–æ—Å—Ç—å?"
    await send_or_edit_message(update, context, text, keyboard)
    return RecruitmentState.JUDGED_BEFORE


async def judged_before_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    context.user_data.setdefault('current_question_num', 34)
    query = update.callback_query
    await safe_answer_callback_query(query)
    context.user_data['judged_before'] = "–î–∞" if query.data == "yes" else "–ù–µ—Ç"
    await send_or_edit_message(update, context,
                               "–û—Ç–ª–∏—á–Ω–æ! –≠—Ç–æ –±—ã–ª –ø–æ—Å–ª–µ–¥–Ω–∏–π –≤–æ–ø—Ä–æ—Å. üöÄ\n\n–°–ø–∞—Å–∏–±–æ –∑–∞ —É–¥–µ–ª–µ–Ω–Ω–æ–µ –≤—Ä–µ–º—è! –ú—ã –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Ç–≤–æ—é –∞–Ω–∫–µ—Ç—É...")
    await send_recruitment_results(context)

    first_name = context.user_data.get('first_name', '–∫–∞–Ω–¥–∏–¥–∞—Ç')
    final_text = f"–°–ø–∞—Å–∏–±–æ, {html.escape(first_name)}! –¢–≤–æ—è –∞–Ω–∫–µ—Ç–∞ –ø—Ä–∏–Ω—è—Ç–∞. –ú–µ–Ω–µ–¥–∂–µ—Ä —Å–∫–æ—Ä–æ —Å–≤—è–∂–µ—Ç—Å—è —Å —Ç–æ–±–æ–π. –•–æ—Ä–æ—à–µ–≥–æ –¥–Ω—è!"
    await send_or_edit_message(update, context, final_text, None)

    context.user_data.clear()
    return ConversationHandler.END


async def send_recruitment_results(context: ContextTypes.DEFAULT_TYPE):
    user_data = context.user_data
    chat_id = user_data.get('chat_id')
    user_full_name = user_data.get('full_name', f'–ö–∞–Ω–¥–∏–¥–∞—Ç_{chat_id}')
    user = await context.bot.get_chat(chat_id)

    timestamp = get_now().strftime("%Y-%m-%d %H:%M:%S")
    interview_restaurant_code_suffix = user_data.get("preselected_restaurant_code")

    report_fields_for_sheets = [
        "preselected_restaurant_name", "full_name", "age", "family_info", "vacancy_source",
        "applied_position", "reason_for_choice", "preferred_restaurant", "knows_marcellis",
        "night_shifts", "weekly_shifts", "mobile_phone", "social_link", "city", "address", "marital_status",
        "children", "health_assessment", "attitude_to_appearance", "education_name",
        "graduation_year", "course", "education_form", "additional_courses",
        "experience_duration", "experience_details", "expected_income", "reason_for_leaving",
        "previous_jobs_count", "attitude_to_sport", "life_values", "life_weaknesses",
        "life_goal", "reading_now", "judged_before"
    ]

    user_link = format_user_for_sheets(chat_id, user_full_name, user.username)
    row_data = [timestamp, user_link]

    for key in report_fields_for_sheets:
        row_data.append(user_data.get(key, "N/A"))

    await add_to_sheets_queue(settings.INTERVIEW_SHEET_NAME, row_data)
    await database.log_survey_completion('recruitment', chat_id, interview_restaurant_code_suffix)
    await database.log_candidate_restaurant(chat_id, interview_restaurant_code_suffix)

    def clean_text(key, default="‚Äî"):
        text = str(user_data.get(key, default))
        text = text.replace('üíç ', '').replace('‚ù§Ô∏è ', '').replace('üö∂ ', '').replace('üíî ', '')
        text = text.replace('üòç ', '').replace('üôÇ ', '').replace('üòï ', '')
        text = text.replace('‚òÄÔ∏è ', '').replace('üåô ', '').replace('‚úâÔ∏è ', '').replace('üíª ', '')
        return html.escape(text)

    full_report_parts = [
        f"<b>–ö–∞–Ω–¥–∏–¥–∞—Ç:</b> <code>{clean_text('full_name')}</code>, {clean_text('age')} –ª–µ—Ç",
        f"<b>–í–∞–∫–∞–Ω—Å–∏—è:</b> {clean_text('applied_position')}",
        f"<b>–†–µ—Å—Ç–æ—Ä–∞–Ω:</b> {clean_text('preselected_restaurant_name')}",
        f"<b>–¢–µ–ª–µ—Ñ–æ–Ω:</b> <code>{clean_text('mobile_phone')}</code>",
        f"<b>–°–æ—Ü. —Å–µ—Ç—å:</b> <code>{clean_text('social_link')}</code>",
        "",
        "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ",
        "<b>–ö–õ–Æ–ß–ï–í–´–ï –î–ê–ù–ù–´–ï</b>",
        "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ",
        f"<b>–û–∂–∏–¥–∞–Ω–∏—è –ø–æ –¥–æ—Ö–æ–¥—É:</b> {clean_text('expected_income')}",
        f"<b>–û–ø—ã—Ç:</b> {clean_text('experience_duration')}",
        f"<b>–ü—Ä–µ–¥—ã–¥—É—â–∏–µ –º–µ—Å—Ç–∞ —Ä–∞–±–æ—Ç—ã:</b> {clean_text('previous_jobs_count')}",
        f"<b>–ù–æ—á–Ω—ã–µ —Å–º–µ–Ω—ã:</b> {clean_text('night_shifts')}",
        f"<b>–°–º–µ–Ω –≤ –Ω–µ–¥–µ–ª—é:</b> {clean_text('weekly_shifts')}",
        f"<b>–ó–Ω–∞–∫–æ–º—Å—Ç–≤–æ —Å –±—Ä–µ–Ω–¥–æ–º:</b> {clean_text('knows_marcellis')}",
        f"<b>–°—É–¥–∏–º–æ—Å—Ç—å:</b> {clean_text('judged_before')}",
        f"<b>–°–æ—Å—Ç–æ—è–Ω–∏–µ –∑–¥–æ—Ä–æ–≤—å—è:</b> {clean_text('health_assessment')}",
        f"<b>–î–µ—Ç–∏:</b> {clean_text('children')}",
        "",
        "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ",
        "<b>–†–ê–ó–í–ï–†–ù–£–¢–´–ï –û–¢–í–ï–¢–´</b>",
        "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ",
        "",
        "ü§î <b>–ú–æ—Ç–∏–≤–∞—Ü–∏—è –∏ —Ü–µ–ª–∏</b>",
        f"<i>{clean_text('reason_for_choice')}</i>",
        "",
        "üö∂‚Äç‚ôÇÔ∏è <b>–ü—Ä–∏—á–∏–Ω–∞ —É—Ö–æ–¥–∞ —Å –ø—Ä–æ—à–ª–æ–≥–æ –º–µ—Å—Ç–∞</b>",
        f"<i>{clean_text('reason_for_leaving')}</i>",
        "",
        "üìã <b>–î–µ—Ç–∞–ª–∏ –æ–ø—ã—Ç–∞ —Ä–∞–±–æ—Ç—ã</b>",
        f"<i>{clean_text('experience_details')}</i>",
        "",
        "üí™ <b>–°–∏–ª—å–Ω—ã–µ —Å—Ç–æ—Ä–æ–Ω—ã –∏ —Ü–µ–Ω–Ω–æ—Å—Ç–∏</b>",
        f"<i>–°–∏–ª—å–Ω—ã–µ —Å—Ç–æ—Ä–æ–Ω—ã: {clean_text('life_weaknesses')}\n–ö–∞—á–µ—Å—Ç–≤–∞ –≤ —Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª–µ: {clean_text('life_values')}</i>",
        "",
        "üéì <b>–û–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ</b>",
        f"<i>–£—á–µ–±–Ω–æ–µ –∑–∞–≤–µ–¥–µ–Ω–∏–µ: {clean_text('education_name')} ({clean_text('education_form')})\n–ì–æ–¥—ã/–ö—É—Ä—Å: {clean_text('graduation_year')} / {clean_text('course')}\n–î–æ–ø. –∫—É—Ä—Å—ã: {clean_text('additional_courses')}</i>",
        "",
        "üë§ <b>–õ–∏—á–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è</b>",
        f"<i>–ü—Ä–æ–∂–∏–≤–∞–Ω–∏–µ: {clean_text('address')}\n–°–µ–º–µ–π–Ω–æ–µ –ø–æ–ª–æ–∂–µ–Ω–∏–µ: {clean_text('marital_status')}\n–°–µ–º—å—è: {clean_text('family_info')}\n–°–ø–æ—Ä—Ç: {clean_text('attitude_to_sport')}\n–ö–Ω–∏–≥–∏/–ö—É—Ä—Å—ã: {clean_text('reading_now')}\n–í–Ω–µ—à–Ω–æ—Å—Ç—å: {clean_text('attitude_to_appearance')}</i>",
    ]
    full_report_text = "\n".join(full_report_parts)

    summary_text = (
        f"‚ö°Ô∏è –ù–æ–≤–∞—è –∞–Ω–∫–µ—Ç–∞!\n\n"
        f"–ö–∞–Ω–¥–∏–¥–∞—Ç: <b>{clean_text('full_name')}</b> ({clean_text('age')})\n"
        f"–ü–æ–∑–∏—Ü–∏—è: <b>{clean_text('applied_position')}</b>\n"
        f"–†–µ—Å—Ç–æ—Ä–∞–Ω: <b>{clean_text('preselected_restaurant_name')}</b>\n\n"
        f"üíµ {clean_text('expected_income')}\n"
        f"üïí –û–ø—ã—Ç: {clean_text('experience_duration')}\n"
        f"üåô –ù–æ—á–∏: {clean_text('night_shifts')}"
    )

    recipients = set(settings.ADMIN_IDS)
    if interview_restaurant_code_suffix:
        manager_ids = await database.get_managers_for_restaurant(interview_restaurant_code_suffix)
        recipients.update(manager_ids)

    job_context_for_managers = {
        "candidate_id": chat_id,
        "candidate_name": user_data.get('full_name', '–ö–∞–Ω–¥–∏–¥–∞—Ç'),
        "position": user_data.get('applied_position', '‚Äî'),
        "full_name": user_data.get('full_name', '‚Äî'),
        "address": user_data.get('address', '‚Äî'),
        "phone": user_data.get('mobile_phone', '‚Äî'),
        "interview_restaurant_code": interview_restaurant_code_suffix,
        "interview_restaurant_name": user_data.get('preselected_restaurant_name', '–ù–µ —É–∫–∞–∑–∞–Ω'),
        "preferred_restaurant_codes": user_data.get('preferred_restaurant_codes', []),
        "recruitment_report": full_report_text
    }

    # --- –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –∫–∞–Ω–¥–∏–¥–∞—Ç–∞ –≤ –ë–î –∫–∞–∫ –ù–ï–ê–ö–¢–ò–í–ù–û–ì–û ---
    # –ü–†–ò–ú–ï–ß–ê–ù–ò–ï: –í–∞–º –ø–æ—Ç—Ä–µ–±—É–µ—Ç—Å—è —Å–æ–∑–¥–∞—Ç—å —ç—Ç—É —Ñ—É–Ω–∫—Ü–∏—é –≤ core/database.py
    # –û–Ω–∞ –¥–æ–ª–∂–Ω–∞ –¥–æ–±–∞–≤–ª—è—Ç—å –∑–∞–ø–∏—Å—å –≤ —Ç–∞–±–ª–∏—Ü—É employees —Å–æ —Å—Ç–∞—Ç—É—Å–æ–º is_active = 0
    await database.register_candidate(
        user_id=chat_id,
        full_name=user_full_name,
        restaurant_code=interview_restaurant_code_suffix
    )
    logger.info(f"Candidate {chat_id} registered in the system as inactive.")

    for recipient_id in recipients:
        try:
            feedback_id = str(uuid.uuid4())
            keyboard = InlineKeyboardMarkup([[
                InlineKeyboardButton("üìÑ –ü–æ—Å–º–æ—Ç—Ä–µ—Ç—å –ø–æ–ª–Ω—É—é –∞–Ω–∫–µ—Ç—É", callback_data=f"show_full_report_{feedback_id}")
            ]])

            sent_message = await context.bot.send_message(recipient_id, summary_text, parse_mode=ParseMode.HTML,
                                                          reply_markup=keyboard)

            await database.add_pending_feedback(
                feedback_id=feedback_id,
                manager_id=recipient_id,
                message_id=sent_message.message_id,
                candidate_id=chat_id,
                candidate_name=user_data.get('full_name', '–ö–∞–Ω–¥–∏–¥–∞—Ç'),
                job_data=job_context_for_managers,
                created_at=get_now().timestamp()
            )
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –∞–Ω–∫–µ—Ç—ã –∏ —Å–æ–∑–¥–∞–Ω–∏—è –∑–∞–¥–∞—á–∏ –¥–ª—è –ø–æ–ª—É—á–∞—Ç–µ–ª—è {recipient_id}: {e}")

    if context.job_queue:
        job_context_for_candidate = {"candidate_id": chat_id}
        context.job_queue.run_once(schedule_candidate_feedback, when=settings.FEEDBACK_DELAY_SECONDS,
                                   data=job_context_for_candidate, name=f"cand_feedback_{chat_id}")

        logger.info(f"Scheduled candidate feedback for candidate {chat_id}")


async def show_full_recruitment_report(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    await safe_answer_callback_query(query)
    feedback_id = query.data.replace("show_full_report_", "")

    # –°–Ω–∞—á–∞–ª–∞ –∏—â–µ–º –≤ –∞–∫—Ç–∏–≤–Ω—ã—Ö –∑–∞–¥–∞—á–∞—Ö
    feedback_task = await database.get_pending_feedback_by_id(feedback_id)
    # –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏, –∏—â–µ–º –≤ –∏—Å—Ç–æ—Ä–∏–∏
    if not feedback_task:
        feedback_task = await database.get_feedback_from_history(feedback_id)

    if not feedback_task:
        await query.edit_message_text(
            f"{query.message.text}\n\n<i>(–ê–Ω–∫–µ—Ç–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –≤ –∞–∫—Ç–∏–≤–Ω—ã—Ö –∑–∞–¥–∞—á–∞—Ö –∏–ª–∏ –∏—Å—Ç–æ—Ä–∏–∏.)</i>",
            parse_mode=ParseMode.HTML,
            reply_markup=None
        )
        return

    full_report = feedback_task.get("job_data", {}).get("recruitment_report", "–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –ø–æ–ª–Ω—É—é –∞–Ω–∫–µ—Ç—É.")

    try:
        await query.edit_message_text(
            text=full_report,
            parse_mode=ParseMode.HTML,
            reply_markup=None
        )
    except BadRequest as e:
        if "Message is not modified" not in str(e):
            logger.error(f"Error editing message to full report: {e}")
            await query.message.reply_text(text=full_report, parse_mode=ParseMode.HTML)


async def send_candidate_check_info(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    await safe_answer_callback_query(query)
    candidate_id = int(query.data.replace("check_candidate_", ""))
    check_data = context.bot_data.get('candidate_check_info', {}).get(candidate_id)

    if not check_data:
        await query.edit_message_text("–î–∞–Ω–Ω—ã–µ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã (–≤–æ–∑–º–æ–∂–Ω–æ, –æ–Ω–∏ —É—Å—Ç–∞—Ä–µ–ª–∏).")
        return

    check_message_parts = [
        f"<b>1.</b> {html.escape(check_data['position'])}",
        f"<b>2.</b> <code>{html.escape(check_data['full_name'])}</code>",
        "<b>3. –í –ø—Ä–æ–µ–∫—Ç–µ –Ω–µ —Ä–∞–±–æ—Ç–∞–ª</b>",
        f"<b>4.</b> {html.escape(check_data['address'])}",
        f"<b>5.</b> <code>{html.escape(check_data['phone'])}</code>",
    ]
    check_message = "\n".join(check_message_parts)
    await query.message.reply_text(text=check_message, parse_mode=ParseMode.HTML)
    await query.edit_message_reply_markup(reply_markup=None)


recruitment_conversation_handler = ConversationHandler(
    entry_points=[CommandHandler("start", start_recruitment_flow, filters=filters.Regex(r'interview_'))],
    states={
        RecruitmentState.FULL_NAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, full_name_received)],
        RecruitmentState.AGE: [MessageHandler(filters.TEXT & ~filters.COMMAND, age_received)],
        RecruitmentState.FAMILY_INFO: [MessageHandler(filters.TEXT & ~filters.COMMAND, family_info_received)],
        RecruitmentState.VACANCY_SOURCE: [CallbackQueryHandler(vacancy_source_received, pattern="^src_"),
                                          MessageHandler(filters.TEXT & ~filters.COMMAND, prompt_to_use_button)],
        RecruitmentState.AWAIT_MULTI_VACANCY: [
            CallbackQueryHandler(multi_vacancy_handler, pattern="^vac_|done_vacancies$"),
            MessageHandler(filters.TEXT & ~filters.COMMAND, prompt_to_use_button)],
        RecruitmentState.AWAIT_OTHER_VACANCY: [MessageHandler(filters.TEXT & ~filters.COMMAND, other_vacancy_received)],
        RecruitmentState.REASON_FOR_CHOICE: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, reason_for_choice_received)],
        RecruitmentState.AWAIT_MULTI_RESTAURANT: [
            CallbackQueryHandler(multi_restaurant_handler, pattern="^res_|done_restaurants$"),
            MessageHandler(filters.TEXT & ~filters.COMMAND, prompt_to_use_button)],
        RecruitmentState.KNOWS_MARCELLIS: [CallbackQueryHandler(knows_marcellis_received, pattern="^(yes|no)$"),
                                           MessageHandler(filters.TEXT & ~filters.COMMAND, prompt_to_use_button)],
        RecruitmentState.NIGHT_SHIFTS: [CallbackQueryHandler(night_shifts_received, pattern="^(yes|no)$"),
                                        MessageHandler(filters.TEXT & ~filters.COMMAND, prompt_to_use_button)],
        RecruitmentState.WEEKLY_SHIFTS: [CallbackQueryHandler(weekly_shifts_received, pattern="^shifts_"),
                                         MessageHandler(filters.TEXT & ~filters.COMMAND, prompt_to_use_button)],
        RecruitmentState.MOBILE_PHONE: [MessageHandler(filters.TEXT & ~filters.COMMAND, mobile_phone_received)],
        RecruitmentState.SOCIAL_LINK: [MessageHandler(filters.TEXT & ~filters.COMMAND, social_link_received)],
        RecruitmentState.CITY: [MessageHandler(filters.TEXT & ~filters.COMMAND, city_received)],
        RecruitmentState.ADDRESS: [MessageHandler(filters.TEXT & ~filters.COMMAND, address_received)],
        RecruitmentState.MARITAL_STATUS: [CallbackQueryHandler(marital_status_received, pattern="^m_"),
                                          MessageHandler(filters.TEXT & ~filters.COMMAND, prompt_to_use_button)],
        RecruitmentState.CHILDREN: [CallbackQueryHandler(children_received, pattern="^child_"),
                                    MessageHandler(filters.TEXT & ~filters.COMMAND, prompt_to_use_button)],
        RecruitmentState.HEALTH_ASSESSMENT: [CallbackQueryHandler(health_assessment_received, pattern="^health_"),
                                             MessageHandler(filters.TEXT & ~filters.COMMAND, prompt_to_use_button)],
        RecruitmentState.ATTITUDE_TO_APPEARANCE: [
            CallbackQueryHandler(attitude_to_appearance_received, pattern="^app_"),
            MessageHandler(filters.TEXT & ~filters.COMMAND, prompt_to_use_button)],
        RecruitmentState.EDUCATION_NAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, education_name_received)],
        RecruitmentState.GRADUATION_YEAR: [MessageHandler(filters.TEXT & ~filters.COMMAND, graduation_year_received)],
        RecruitmentState.COURSE: [CallbackQueryHandler(course_received, pattern="^course_"),
                                  MessageHandler(filters.TEXT & ~filters.COMMAND, prompt_to_use_button)],
        RecruitmentState.EDUCATION_FORM: [CallbackQueryHandler(education_form_received, pattern="^form_"),
                                          MessageHandler(filters.TEXT & ~filters.COMMAND, prompt_to_use_button)],
        RecruitmentState.AWAIT_ADDITIONAL_COURSES_DECISION: [
            CallbackQueryHandler(additional_courses_decision_received, pattern="^courses_"),
            MessageHandler(filters.TEXT & ~filters.COMMAND, prompt_to_use_button)],
        RecruitmentState.ADDITIONAL_COURSES: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, additional_courses_received)],
        RecruitmentState.EXPERIENCE_DURATION: [CallbackQueryHandler(experience_duration_received, pattern="^exp_"),
                                               MessageHandler(filters.TEXT & ~filters.COMMAND, prompt_to_use_button)],
        RecruitmentState.AWAIT_EXPERIENCE_DETAILS: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, experience_details_received)],
        RecruitmentState.EXPECTED_INCOME: [CallbackQueryHandler(expected_income_received, pattern="^inc_"),
                                           MessageHandler(filters.TEXT & ~filters.COMMAND, prompt_to_use_button)],
        RecruitmentState.REASON_FOR_LEAVING: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, reason_for_leaving_received)],
        RecruitmentState.PREVIOUS_JOBS_COUNT: [CallbackQueryHandler(previous_jobs_count_received, pattern="^jobs_"),
                                               MessageHandler(filters.TEXT & ~filters.COMMAND, prompt_to_use_button)],
        RecruitmentState.ATTITUDE_TO_SPORT: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, attitude_to_sport_received)],
        RecruitmentState.LIFE_VALUES: [MessageHandler(filters.TEXT & ~filters.COMMAND, life_values_received)],
        RecruitmentState.LIFE_WEAKNESSES: [MessageHandler(filters.TEXT & ~filters.COMMAND, life_weaknesses_received)],
        RecruitmentState.LIFE_GOAL: [MessageHandler(filters.TEXT & ~filters.COMMAND, life_goal_received)],
        RecruitmentState.READING_NOW: [MessageHandler(filters.TEXT & ~filters.COMMAND, reading_now_received)],
        RecruitmentState.JUDGED_BEFORE: [CallbackQueryHandler(judged_before_received, pattern="^(yes|no)$"),
                                         MessageHandler(filters.TEXT & ~filters.COMMAND, prompt_to_use_button)],
    },
    fallbacks=[CommandHandler("cancel", cancel)],
    name="recruitment_conv",
    persistent=True,
    per_message=False,
    conversation_timeout=settings.CONVERSATION_TIMEOUT_SECONDS
)

--- FILE: handlers/main_menu.py ---
import html
import logging
import asyncio

from telegram import Update, ReplyKeyboardRemove
from telegram.ext import (
    ContextTypes,
    ConversationHandler,
)
from telegram.constants import ParseMode
from telegram.error import Forbidden

from models import MainMenuState, AdminState, FeedbackState, ManagerFeedbackState
from core import settings, database, stickers
from utils.helpers import (
    safe_answer_callback_query, add_user_to_interacted,
    get_user_data_from_update, send_new_menu_message, send_or_edit_message,
    set_user_commands
)
from utils.keyboards import get_manager_menu_keyboard, get_pending_feedback_keyboard
from handlers.admin import admin_panel_start
from handlers.manager_feedback_flow import start_manager_feedback_flow
from handlers.common import handle_blocked_user

logger = logging.getLogger(__name__)


async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    user = update.effective_user
    if not user:
        return ConversationHandler.END

    active_conv_names = [
        'recruitment_conv', 'onboarding_conv', 'exit_interview_conv',
        'climate_survey_conv', 'manager_reg_conv', 'admin_conv'
    ]
    current_conversations = context.user_data.get('conversations', {})
    is_in_another_conv = any(current_conversations.get(name) is not None for name in active_conv_names)

    if is_in_another_conv:
        logger.info(f"User {user.id} tried to use /start while in an active conversation.")
        if update.effective_message:
            await update.effective_message.reply_text(
                "–ö–∞–∂–µ—Ç—Å—è, –≤—ã —Å–µ–π—á–∞—Å –≤ –ø—Ä–æ—Ü–µ—Å—Å–µ –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è –∞–Ω–∫–µ—Ç—ã. "
                "–ß—Ç–æ–±—ã –ø—Ä–µ—Ä–≤–∞—Ç—å –∏ –Ω–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É /cancel.",
                reply_markup=ReplyKeyboardRemove()
            )
        return ConversationHandler.END

    try:
        await set_user_commands(user.id, context.bot)
        await add_user_to_interacted(user.id, context)

        is_manager = await database.is_user_a_manager(user.id)

        if update.callback_query:
            await safe_answer_callback_query(update.callback_query)

        if is_manager:
            return await show_manager_menu(update, context)

        await context.bot.send_sticker(chat_id=user.id, sticker=stickers.get_random_greeting())
        await update.effective_message.reply_text(
            "Ciao! üëã –Ø –±–æ—Ç-–ø–æ–º–æ—â–Ω–∏–∫ –∫–æ–º–∞–Ω–¥—ã ¬´–ú–∞—Ä—á–µ–ª–ª–∏—Å¬ª.\n\n"
            "–ï—Å–ª–∏ –≤—ã –∫–∞–Ω–¥–∏–¥–∞—Ç, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–æ—Å–ø–æ–ª—å–∑—É–π—Ç–µ—Å—å —Å–ø–µ—Ü–∏–∞–ª—å–Ω–æ–π —Å—Å—ã–ª–∫–æ–π –∏–ª–∏ QR-–∫–æ–¥–æ–º –æ—Ç –º–µ–Ω–µ–¥–∂–µ—Ä–∞, —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å –∞–Ω–∫–µ—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ.\n\n"
            "–ï—Å–ª–∏ —É –≤–∞—Å –µ—Å—Ç—å –≤–æ–ø—Ä–æ—Å, –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ –∏–ª–∏ –≤—ã —Ö–æ—Ç–∏—Ç–µ –æ—Å—Ç–∞–≤–∏—Ç—å –æ—Ç–∑—ã–≤ ‚Äî –ø—Ä–æ—Å—Ç–æ –Ω–∞–ø–∏—à–∏—Ç–µ –µ–≥–æ –≤ —Å–ª–µ–¥—É—é—â–µ–º —Å–æ–æ–±—â–µ–Ω–∏–∏.",
            reply_markup=ReplyKeyboardRemove()
        )
        return ConversationHandler.END

    except Forbidden:
        return await handle_blocked_user(user.id, context)


async def show_manager_menu(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    user = update.effective_user
    await context.bot.send_sticker(chat_id=user.id, sticker=stickers.GREETING_WAITER)

    pending_feedback = await database.get_pending_feedback_for_manager(user.id)
    keyboard = get_manager_menu_keyboard(len(pending_feedback))
    text = f"Ciao, {html.escape(user.first_name)}! üëã\n\n–≠—Ç–æ —Ç–≤–æ–µ –º–µ–Ω—é –º–µ–Ω–µ–¥–∂–µ—Ä–∞."

    await send_new_menu_message(context, user.id, text, keyboard)
    return MainMenuState.MAIN


async def handle_manager_feedback_button(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await safe_answer_callback_query(query)
    user_id = query.from_user.id

    pending_tasks = await database.get_pending_feedback_for_manager(user_id)
    if not pending_tasks:
        await query.answer("–£ —Ç–µ–±—è –Ω–µ—Ç –∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤, –æ–∂–∏–¥–∞—é—â–∏—Ö –æ–±—Ä–∞—Ç–Ω–æ–π —Å–≤—è–∑–∏.", show_alert=True)
        return MainMenuState.MAIN

    keyboard = get_pending_feedback_keyboard(pending_tasks)
    await send_or_edit_message(update, context, "–í—ã–±–µ—Ä–∏ –∫–∞–Ω–¥–∏–¥–∞—Ç–∞, –ø–æ –∫–æ—Ç–æ—Ä–æ–º—É —Ö–æ—á–µ—à—å –æ—Å—Ç–∞–≤–∏—Ç—å –æ–±—Ä–∞—Ç–Ω—É—é —Å–≤—è–∑—å:",
                               keyboard)

    return MainMenuState.AWAITING_FEEDBACK_CHOICE


async def handle_feedback_candidate_selection(update: Update,
                                              context: ContextTypes.DEFAULT_TYPE) -> ManagerFeedbackState:
    query = update.callback_query
    await safe_answer_callback_query(query)

    feedback_id = query.data.replace("fb_", "")
    context.user_data['feedback_id'] = feedback_id

    return await start_manager_feedback_flow(update, context)


async def start_feedback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    user = update.effective_user
    if not user:
        return ConversationHandler.END

    logger.info(f"User {user.id} triggered /start or text message. Routing to general FEEDBACK flow.")

    if update.effective_chat:
        context.user_data['chat_id'] = update.effective_chat.id

    text = ("–ü—Ä–∏–≤–µ—Ç! üëã –Ø –±–æ—Ç-–ø–æ–º–æ—â–Ω–∏–∫ –∫–æ–º–∞–Ω–¥—ã ¬´–ú–∞—Ä—á–µ–ª–ª–∏—Å¬ª.\n\n"
            "–ï—Å–ª–∏ —É —Ç–µ–±—è –µ—Å—Ç—å –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ, –≤–æ–ø—Ä–æ—Å –∏–ª–∏ –∂–∞–ª–æ–±–∞ ‚Äî –ø—Ä–æ—Å—Ç–æ –Ω–∞–ø–∏—à–∏ —ç—Ç–æ –≤ —Å–ª–µ–¥—É—é—â–µ–º —Å–æ–æ–±—â–µ–Ω–∏–∏, –∏ —è –ø–µ—Ä–µ–¥–∞–º –≤—Å—ë –Ω–∞—à–µ–π –∫–æ–º–∞–Ω–¥–µ.\n\n"
            "–ß—Ç–æ–±—ã –æ—Ç–º–µ–Ω–∏—Ç—å, –æ—Ç–ø—Ä–∞–≤—å –∫–æ–º–∞–Ω–¥—É /cancel.")

    try:
        await context.bot.send_sticker(chat_id=user.id, sticker=stickers.QUESTION_DOG)
        await asyncio.sleep(0.5)

        sent_message = await update.effective_message.reply_text(text, reply_markup=ReplyKeyboardRemove())
        context.user_data[settings.ACTIVE_MESSAGE_ID_KEY] = sent_message.message_id

        return FeedbackState.AWAITING_FEEDBACK
    except Forbidden:
        return await handle_blocked_user(user.id, context)


async def receive_and_forward_feedback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    feedback_text = update.message.text
    user_id, user_name, _ = get_user_data_from_update(update)
    logger.info(f"Received general feedback from {user_name}")

    if settings.ADMIN_IDS:
        message = f"üì© <b>–ù–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è</b> üì©\n\n<b>–û—Ç:</b> {html.escape(user_name)}\n<b>–°–æ–æ–±—â–µ–Ω–∏–µ:</b>\n<pre>{html.escape(feedback_text)}</pre>"
        for admin_id in settings.ADMIN_IDS:
            try:
                await context.bot.send_message(admin_id, message, parse_mode=ParseMode.HTML)
            except Exception as e:
                logger.error(f"Failed to forward feedback to admin {admin_id}: {e}")

        await send_or_edit_message(update, context, "–°–ø–∞—Å–∏–±–æ! –ú—ã –ø–æ–ª—É—á–∏–ª–∏ —Ç–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –∏ –ø–µ—Ä–µ–¥–∞–ª–∏ –∫–æ–º–∞–Ω–¥–µ. üôè")
        await asyncio.sleep(0.5)
        await context.bot.send_sticker(chat_id=user_id, sticker=stickers.FEEDBACK_SENT_DOG)
    else:
        await send_or_edit_message(update, context,
                                   "–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —Ñ—É–Ω–∫—Ü–∏—è –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏–π —Å–µ–π—á–∞—Å –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç. –ü–æ–ø—Ä–æ–±—É–π, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–∑–∂–µ."
                                   )

    context.user_data.clear()
    return ConversationHandler.END

--- FILE: handlers/feedback.py ---
import html
import logging
from datetime import timedelta

from telegram import Update, InlineKeyboardMarkup, InlineKeyboardButton
from telegram.ext import (
    ContextTypes,
    ConversationHandler,
    CommandHandler,
    CallbackQueryHandler,
    MessageHandler,
    filters,
)
from telegram.constants import ParseMode

from models import CandidateFeedbackState, OnboardingFollowupState
from core import settings, database
from utils.helpers import (
    safe_answer_callback_query,
    send_or_edit_message,
    add_to_sheets_queue,
    build_inline_keyboard,
    get_now,
    get_user_data_from_update,
    send_new_menu_message
)
from utils.keyboards import CANDIDATE_FEEDBACK_RATING_OPTIONS, YES_NO_OPTIONS, RESTAURANT_OPTIONS
from handlers.common import cancel, prompt_to_use_button
from handlers.onboarding import start_onboarding_flow

logger = logging.getLogger(__name__)

async def schedule_candidate_feedback(context: ContextTypes.DEFAULT_TYPE):
    job_data = context.job.data
    candidate_id = job_data["candidate_id"]

    text = "–ü—Ä–∏–≤–µ—Ç –µ—â–µ —Ä–∞–∑! üëã –ü—Ä–æ—à–ª–æ –Ω–µ–º–Ω–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏ –ø–æ—Å–ª–µ —Ç–≤–æ–µ–≥–æ –≤–∏–∑–∏—Ç–∞. –ë—É–¥–µ–º –æ—á–µ–Ω—å –±–ª–∞–≥–æ–¥–∞—Ä–Ω—ã, –µ—Å–ª–∏ —Ç—ã –æ—Ç–≤–µ—Ç–∏—à—å –Ω–∞ 4 –∫–æ—Ä–æ—Ç–∫–∏—Ö –≤–æ–ø—Ä–æ—Å–∞ –æ –≤—Å—Ç—Ä–µ—á–µ. –≠—Ç–æ –ø–æ–º–æ–∂–µ—Ç –Ω–∞–º —Å—Ç–∞—Ç—å –ª—É—á—à–µ."
    keyboard = InlineKeyboardMarkup(
        [[InlineKeyboardButton("‚úçÔ∏è –ü—Ä–æ–π—Ç–∏ –æ–ø—Ä–æ—Å (1 –º–∏–Ω—É—Ç–∞)",
                               callback_data=settings.CALLBACK_START_CANDIDATE_FEEDBACK)]])

    try:
        await context.bot.send_message(candidate_id, text, reply_markup=keyboard)
    except Exception as e:
        logger.error(f"Failed to send candidate feedback poll to {candidate_id}: {e}")


async def schedule_onboarding_noshow_check(context: ContextTypes.DEFAULT_TYPE):
    job_data = context.job.data
    candidate_id = job_data.get("candidate_id")

    if not candidate_id:
        logger.error("No candidate_id in schedule_onboarding_noshow_check job.")
        return

    if await database.is_survey_completed("onboarding", candidate_id):
        logger.info(f"Candidate {candidate_id} has completed onboarding survey. No-show check cancelled.")
        return

    logger.info(f"Starting onboarding NO-SHOW check for candidate {candidate_id}.")
    keyboard = InlineKeyboardMarkup([
        [InlineKeyboardButton("–î–∞, –≤—Å–µ –≤ —Å–∏–ª–µ / —Å–º–µ–Ω–∞ –ø–µ—Ä–µ–Ω–µ—Å–ª–∞—Å—å", callback_data=settings.CALLBACK_ONBOARDING_FOLLOWUP_YES)],
        [InlineKeyboardButton("–ù–µ—Ç, —è –ø–µ—Ä–µ–¥—É–º–∞–ª(–∞) / –Ω–µ –º–æ–≥—É –≤—ã–π—Ç–∏", callback_data=settings.CALLBACK_ONBOARDING_FOLLOWUP_NO)],
    ])
    text = ("–ü—Ä–∏–≤–µ—Ç! üëã –ù–∞ —Å–≤—è–∑–∏ –∫–æ–º–∞–Ω–¥–∞ ¬´–ú–∞—Ä—á–µ–ª–ª–∏—Å¬ª.\n\n"
            "–ó–∞–º–µ—Ç–∏–ª–∏, —á—Ç–æ —Ç—ã –Ω–µ –ø—Ä–æ—à–µ–ª(-–ª–∞) –æ–ø—Ä–æ—Å –ø–æ—Å–ª–µ –æ–∑–Ω–∞–∫–æ–º–∏—Ç–µ–ª—å–Ω–æ–π —Å–º–µ–Ω—ã. "
            "–•–æ—Ç–µ–ª–∏ –±—ã —É—Ç–æ—á–Ω–∏—Ç—å —Ç–≤–æ–π —Å—Ç–∞—Ç—É—Å: —Ç–≤–æ–∏ –ø–ª–∞–Ω—ã –ø–æ —Ä–∞–±–æ—Ç–µ —É –Ω–∞—Å –µ—â–µ –∞–∫—Ç—É–∞–ª—å–Ω—ã?")

    try:
        sent_message = await context.bot.send_message(candidate_id, text, reply_markup=keyboard)
        context.user_data[settings.ACTIVE_MESSAGE_ID_KEY] = sent_message.message_id
        context.user_data['candidate_id_for_noshow'] = candidate_id
    except Exception as e:
        logger.error(f"Failed to send onboarding no-show check to {candidate_id}: {e}")


async def start_onboarding_followup(update: Update,
                                    context: ContextTypes.DEFAULT_TYPE) -> OnboardingFollowupState | int:
    query = update.callback_query
    await safe_answer_callback_query(query)

    if query.data == settings.CALLBACK_ONBOARDING_FOLLOWUP_YES:
        await send_or_edit_message(update, context,
                                   "–û—Ç–ª–∏—á–Ω–æ! –†–∞–¥—ã, —á—Ç–æ —Ç—ã —Å –Ω–∞–º–∏. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–µ –∑–∞–±—É–¥—å –ø—Ä–æ–π—Ç–∏ –æ–ø—Ä–æ—Å –ø–æ—Å–ª–µ —Å–≤–æ–µ–π –ø–µ—Ä–≤–æ–π —Å–º–µ–Ω—ã (—Å—Å—ã–ª–∫—É —Ç–µ–±–µ –¥–∞–≤–∞–ª –º–µ–Ω–µ–¥–∂–µ—Ä).")
        return ConversationHandler.END

    elif query.data == settings.CALLBACK_ONBOARDING_FOLLOWUP_NO:
        await send_or_edit_message(update, context,
                                   "–û—á–µ–Ω—å –∂–∞–ª—å —ç—Ç–æ —Å–ª—ã—à–∞—Ç—å. –ï—Å–ª–∏ –Ω–µ —Å–ª–æ–∂–Ω–æ, –Ω–∞–ø–∏—à–∏, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, —á—Ç–æ –ø–æ–≤–ª–∏—è–ª–æ –Ω–∞ —Ç–≤–æ–µ —Ä–µ—à–µ–Ω–∏–µ?")
        return OnboardingFollowupState.AWAITING_LEAVING_REASON

    return ConversationHandler.END


async def leaving_reason_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    reason = update.message.text
    user_id, user_name, _ = get_user_data_from_update(update)
    timestamp = get_now().strftime("%Y-%m-%d %H:%M:%S")

    restaurant_code = await database.get_candidate_restaurant(user_id)
    restaurant_name = "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ"
    if restaurant_code:
         restaurant_name = next((name for name, r_code in RESTAURANT_OPTIONS if r_code.endswith(restaurant_code)), restaurant_code)

    row_data = [timestamp, user_name, user_id, restaurant_name, reason]
    await add_to_sheets_queue(settings.CANDIDATE_NOSHOW_SHEET_NAME, row_data)

    manager_ids = []
    if restaurant_code:
        manager_ids = await database.get_managers_for_restaurant(restaurant_code)

    recipients = set(settings.ADMIN_IDS).union(set(manager_ids))
    notification_tasks = await database.get_all_pending_feedback_for_candidate(user_id)

    if notification_tasks and recipients:
        message = (f"‚ùóÔ∏èüó£Ô∏è <b>–ö–∞–Ω–¥–∏–¥–∞—Ç –ø–µ—Ä–µ–¥—É–º–∞–ª –≤—ã—Ö–æ–¥–∏—Ç—å –Ω–∞ —Å–º–µ–Ω—É</b>\n\n"
                   f"<b>–ö–∞–Ω–¥–∏–¥–∞—Ç:</b> {html.escape(user_name)}\n"
                   f"<b>–†–µ—Å—Ç–æ—Ä–∞–Ω:</b> {html.escape(restaurant_name)}\n\n"
                   f"<b>–ü—Ä–∏—á–∏–Ω–∞, —É–∫–∞–∑–∞–Ω–Ω–∞—è –∫–∞–Ω–¥–∏–¥–∞—Ç–æ–º:</b>\n<pre>{html.escape(reason)}</pre>\n\n"
                   f"<i>–ó–∞–¥–∞—á–∏ –ø–æ —ç—Ç–æ–º—É –∫–∞–Ω–¥–∏–¥–∞—Ç—É –∑–∞–∫—Ä—ã—Ç—ã.</i>")

        for task in notification_tasks:
            if task['manager_id'] in recipients:
                try:
                    await context.bot.send_message(
                        chat_id=task['manager_id'],
                        text=message,
                        reply_to_message_id=task['message_id'],
                        parse_mode=ParseMode.HTML,
                        allow_sending_without_reply=True
                    )
                except Exception as e:
                    logger.error(f"Failed to send leaving reason to manager/admin {task['manager_id']}: {e}")

    # –í–º–µ—Å—Ç–æ –ø–æ–ª–Ω–æ–≥–æ —É–¥–∞–ª–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö, –ø—Ä–æ—Å—Ç–æ —É–¥–∞–ª—è–µ–º –µ–≥–æ –∏–∑ –æ—á–µ—Ä–µ–¥–∏ –Ω–∞ —Ä–∞—Å—Å–º–æ—Ç—Ä–µ–Ω–∏–µ
    await database.remove_all_pending_feedback_for_candidate(user_id)
    # –°—Ç–∞—Ç—É—Å is_active –æ—Å—Ç–∞–µ—Ç—Å—è 0, —á—Ç–æ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ –¥–ª—è –æ—Ç–∫–∞–∑–∞–≤—à–µ–≥–æ—Å—è –∫–∞–Ω–¥–∏–¥–∞—Ç–∞
    logger.info(f"User {user_id} changed their mind. Reason recorded, pending feedback cleared. User data retained as inactive.")

    await send_or_edit_message(update, context,
                               "–°–ø–∞—Å–∏–±–æ –∑–∞ —á–µ—Å—Ç–Ω—ã–π –æ—Ç–≤–µ—Ç. –≠—Ç–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –ø–æ–º–æ–∂–µ—Ç –Ω–∞–º —Å—Ç–∞—Ç—å –ª—É—á—à–µ. –£–¥–∞—á–∏ –≤ –¥–∞–ª—å–Ω–µ–π—à–∏—Ö –ø–æ–∏—Å–∫–∞—Ö!")
    return ConversationHandler.END


onboarding_followup_conversation_handler = ConversationHandler(
    entry_points=[
        CallbackQueryHandler(start_onboarding_followup,
                             pattern=f"^{settings.CALLBACK_ONBOARDING_FOLLOWUP_YES}$|^{settings.CALLBACK_ONBOARDING_FOLLOWUP_NO}$")
    ],
    states={
        OnboardingFollowupState.AWAITING_LEAVING_REASON: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, leaving_reason_received)],
    },
    fallbacks=[CommandHandler('cancel', cancel)],
    name="onboarding_followup_conv",
    persistent=True,
    per_message=False
)


async def start_candidate_feedback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> CandidateFeedbackState:
    query = update.callback_query
    await safe_answer_callback_query(query)
    context.user_data.clear()
    context.user_data[settings.ACTIVE_MESSAGE_ID_KEY] = query.message.message_id

    keyboard = build_inline_keyboard(CANDIDATE_FEEDBACK_RATING_OPTIONS, columns=5)
    text = "<b>–í–æ–ø—Ä–æ—Å 1/4:</b> –ö–∞–∫ –≤ —Ü–µ–ª–æ–º –ø—Ä–æ—à–ª–æ –∏–Ω—Ç–µ—Ä–≤—å—é? –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ü–µ–Ω–∏ –æ—Ç 1 (–ø–ª–æ—Ö–æ) –¥–æ 5 (–æ—Ç–ª–∏—á–Ω–æ)."
    await send_or_edit_message(update, context, text, keyboard)
    return CandidateFeedbackState.AWAITING_IMPRESSION


async def impression_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> CandidateFeedbackState:
    query = update.callback_query
    await safe_answer_callback_query(query)
    context.user_data["impression_rating"] = query.data.split("_")[-1]
    context.user_data["candidate_name"] = update.effective_user.full_name
    context.user_data["candidate_id"] = update.effective_user.id

    keyboard = build_inline_keyboard(YES_NO_OPTIONS, columns=2)
    text = "<b>–í–æ–ø—Ä–æ—Å 2/4:</b> –†–∞—Å—Å–∫–∞–∑–∞–ª –ª–∏ —Ç–µ–±–µ –º–µ–Ω–µ–¥–∂–µ—Ä –æ–±–æ –≤—Å–µ—Ö —É—Å–ª–æ–≤–∏—è—Ö —Ä–∞–±–æ—Ç—ã (–≥—Ä–∞—Ñ–∏–∫, –∑–∞—Ä–ø–ª–∞—Ç–∞, –æ–±—è–∑–∞–Ω–Ω–æ—Å—Ç–∏)?"
    await send_or_edit_message(update, context, text, keyboard)
    return CandidateFeedbackState.AWAITING_CONDITIONS_MET


async def conditions_met_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> CandidateFeedbackState:
    query = update.callback_query
    await safe_answer_callback_query(query)
    context.user_data["conditions_met"] = "–î–∞" if query.data == "yes" else "–ù–µ—Ç"

    keyboard = build_inline_keyboard(YES_NO_OPTIONS, columns=2)
    text = "<b>–í–æ–ø—Ä–æ—Å 3/4:</b> –ë—ã–ª–∏ –ª–∏ —Ç–µ–±–µ –ø–æ–Ω—è—Ç–Ω—ã —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è –∫ –∫–∞–Ω–¥–∏–¥–∞—Ç—É –Ω–∞ —ç—Ç—É –¥–æ–ª–∂–Ω–æ—Å—Ç—å?"
    await send_or_edit_message(update, context, text, keyboard)
    return CandidateFeedbackState.AWAITING_REQUIREMENTS_CLEAR


async def requirements_clear_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> CandidateFeedbackState:
    query = update.callback_query
    await safe_answer_callback_query(query)
    context.user_data["requirements_clear"] = "–î–∞" if query.data == "yes" else "–ù–µ—Ç"

    text = "<b>–í–æ–ø—Ä–æ—Å 4/4:</b> –ú–æ–∂–µ—Ç –±—ã—Ç—å, —É —Ç–µ–±—è –µ—Å—Ç—å –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ –∏–ª–∏ –ø–æ–∂–µ–ª–∞–Ω–∏—è –¥–ª—è –Ω–∞—Å? (–ï—Å–ª–∏ –Ω–µ—Ç, –Ω–∞–ø–∏—à–∏ ¬´–Ω–µ—Ç¬ª)"
    await send_or_edit_message(update, context, text, None)
    return CandidateFeedbackState.AWAITING_ADDITIONAL_COMMENTS


async def additional_comments_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    context.user_data["additional_comments"] = update.message.text

    user_data = context.user_data
    candidate_id = user_data["candidate_id"]
    candidate_name = user_data["candidate_name"]
    timestamp = get_now().strftime("%Y-%m-%d %H:%M:%S")

    restaurant_code = await database.get_candidate_restaurant(candidate_id)

    impression_rating_str = user_data.get("impression_rating")
    conditions_met = user_data.get("conditions_met")
    requirements_clear = user_data.get("requirements_clear")
    additional_comments = user_data.get("additional_comments", '–ù–µ—Ç')

    row_data = [timestamp, candidate_name, candidate_id, impression_rating_str, conditions_met, requirements_clear,
                additional_comments]
    await add_to_sheets_queue(settings.CANDIDATE_FEEDBACK_SHEET_NAME, row_data)

    await database.log_survey_completion('candidate_feedback', candidate_id, restaurant_code)

    flags = []
    message_title = "üìù <b>–û–° –æ—Ç –∫–∞–Ω–¥–∏–¥–∞—Ç–∞ –ø–æ—Å–ª–µ —Å–æ–±–µ—Å–µ–¥–æ–≤–∞–Ω–∏—è</b>"

    try:
        if impression_rating_str and int(impression_rating_str) < 3:
            flags.append(f"üö© <b>–ù–∏–∑–∫–∞—è –æ—Ü–µ–Ω–∫–∞ –∏–Ω—Ç–µ—Ä–≤—å—é: {impression_rating_str}/5</b>")
    except (ValueError, TypeError):
        pass

    if conditions_met == "–ù–µ—Ç":
        flags.append("‚ö†Ô∏è <b>–£—Å–ª–æ–≤–∏—è —Ä–∞–±–æ—Ç—ã –±—ã–ª–∏ –Ω–µ –æ–∑–≤—É—á–µ–Ω—ã –∏–ª–∏ –Ω–µ –ø–æ–Ω—è—Ç–Ω—ã.</b>")
    if requirements_clear == "–ù–µ—Ç":
        flags.append("‚ö†Ô∏è <b>–¢—Ä–µ–±–æ–≤–∞–Ω–∏—è –∫ –∫–∞–Ω–¥–∏–¥–∞—Ç—É –±—ã–ª–∏ –Ω–µ —è—Å–Ω—ã.</b>")

    if flags:
        message_title = "‚ùóÔ∏èüö© <b>–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –û–° –æ—Ç –∫–∞–Ω–¥–∏–¥–∞—Ç–∞!</b> üö©‚ùóÔ∏è"

    admin_message_parts = [message_title]
    admin_message_parts.append(f"\n<b>–ö–∞–Ω–¥–∏–¥–∞—Ç:</b> {html.escape(candidate_name)} (ID: <code>{candidate_id}</code>)")

    if flags:
        admin_message_parts.append("\n<b>–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –º–æ–º–µ–Ω—Ç—ã:</b>")
        admin_message_parts.extend(flags)
        admin_message_parts.append("\n" + "=" * 20 + "\n")

    admin_message_parts.append("<b>–ü–æ–ª–Ω—ã–π –æ—Ç–∑—ã–≤:</b>")
    admin_message_parts.append(f"<b>–û—Ü–µ–Ω–∫–∞ –∏–Ω—Ç–µ—Ä–≤—å—é:</b> {impression_rating_str}/5")
    admin_message_parts.append(f"<b>–£—Å–ª–æ–≤–∏—è –æ–∑–≤—É—á–µ–Ω—ã:</b> {conditions_met}")
    admin_message_parts.append(f"<b>–¢—Ä–µ–±–æ–≤–∞–Ω–∏—è –ø–æ–Ω—è—Ç–Ω—ã:</b> {requirements_clear}")
    admin_message_parts.append(f"<b>–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π:</b> {html.escape(additional_comments)}")

    admin_message = "\n".join(admin_message_parts)

    admin_tasks = await database.get_all_pending_feedback_for_candidate(candidate_id)
    for task in admin_tasks:
        if task['manager_id'] in settings.ADMIN_IDS:
            try:
                await context.bot.send_message(
                    chat_id=task['manager_id'],
                    text=admin_message,
                    parse_mode=ParseMode.HTML,
                    reply_to_message_id=task['message_id'],
                    allow_sending_without_reply=True
                )
            except Exception as e:
                logger.error(f"Failed to send candidate feedback to admin {task['manager_id']}: {e}")

    await send_or_edit_message(update, context, "–°–ø–∞—Å–∏–±–æ –±–æ–ª—å—à–æ–µ –∑–∞ –æ–±—Ä–∞—Ç–Ω—É—é —Å–≤—è–∑—å! –û–Ω–∞ –ø–æ–º–æ–∂–µ—Ç –Ω–∞–º —Å—Ç–∞—Ç—å –ª—É—á—à–µ. üôè")

    return ConversationHandler.END


candidate_feedback_conversation_handler = ConversationHandler(
    entry_points=[
        CallbackQueryHandler(start_candidate_feedback, pattern=f"^{settings.CALLBACK_START_CANDIDATE_FEEDBACK}$")],
    states={
        CandidateFeedbackState.AWAITING_IMPRESSION: [CallbackQueryHandler(impression_received, pattern="^cand_rate_"),
                                                     MessageHandler(filters.TEXT, prompt_to_use_button)],
        CandidateFeedbackState.AWAITING_CONDITIONS_MET: [
            CallbackQueryHandler(conditions_met_received, pattern="^(yes|no)$"),
            MessageHandler(filters.TEXT, prompt_to_use_button)],
        CandidateFeedbackState.AWAITING_REQUIREMENTS_CLEAR: [
            CallbackQueryHandler(requirements_clear_received, pattern="^(yes|no)$"),
            MessageHandler(filters.TEXT, prompt_to_use_button)],
        CandidateFeedbackState.AWAITING_ADDITIONAL_COMMENTS: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, additional_comments_received)],
    },
    fallbacks=[CommandHandler("cancel", cancel)],
    name="candidate_feedback_conv",
    persistent=True,
    per_message=False,
)

--- FILE: handlers/onboarding.py ---
import html
import logging
import asyncio

from telegram import Update, ReplyKeyboardRemove
from telegram.ext import (
    ContextTypes,
    ConversationHandler,
    CommandHandler,
    MessageHandler,
    CallbackQueryHandler,
    filters,
)
from telegram.constants import ParseMode

from models import OnboardingState
from core import settings, database, stickers
from utils.helpers import (
    get_user_data_from_update,
    safe_answer_callback_query,
    send_or_edit_message,
    add_to_sheets_queue,
    add_user_to_interacted,
    get_now,
    format_user_for_sheets,
    remove_keyboard_from_previous_message
)
from utils.keyboards import (
    RESTAURANT_OPTIONS,
    ONBOARDING_POSITION_OPTIONS,
    POSITION_LINKS,
    INTEREST_RATING_OPTIONS,
    build_inline_keyboard
)
from handlers.common import cancel, prompt_to_use_button

logger = logging.getLogger(__name__)


async def start_onboarding_flow(update: Update, context: ContextTypes.DEFAULT_TYPE) -> OnboardingState:
    user_id, user_name, _ = get_user_data_from_update(update)
    await add_user_to_interacted(user_id, context)
    context.user_data.clear()

    logger.info(f"User {user_name} ({user_id}) started onboarding flow.")

    restaurant_code = ""
    restaurant_name = "–ù–µ —É–∫–∞–∑–∞–Ω"

    if update.callback_query:
        restaurant_code = await database.get_candidate_restaurant(user_id) or ""
        restaurant_name = next((name for name, code in RESTAURANT_OPTIONS if code.endswith(restaurant_code)),
                               "–ù–µ —É–∫–∞–∑–∞–Ω")
    else:
        param = context.args[0] if context.args else ""
        if not param or not param.startswith("onboard_"):
            if update.message:
                await update.message.reply_text("–û—à–∏–±–∫–∞ –≤ —Å—Å—ã–ª–∫–µ. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –º–µ–Ω–µ–¥–∂–µ—Ä—É.")
            return ConversationHandler.END
        restaurant_code = param.replace("onboard_", "")
        restaurant_name = next((name for name, r_code in RESTAURANT_OPTIONS if r_code.endswith(restaurant_code)),
                               "–ù–µ —É–∫–∞–∑–∞–Ω")

    if restaurant_name == "–ù–µ —É–∫–∞–∑–∞–Ω":
        if update.effective_message:
            await update.effective_message.reply_text(
                "–ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Ä–µ—Å—Ç–æ—Ä–∞–Ω. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –º–µ–Ω–µ–¥–∂–µ—Ä—É.")
        return ConversationHandler.END

    context.user_data['onboarding_restaurant'] = restaurant_name
    context.user_data['onboarding_restaurant_code'] = restaurant_code
    context.user_data['chat_id'] = update.effective_chat.id

    if not update.callback_query:
        await context.bot.send_sticker(chat_id=user_id, sticker=stickers.GREETING_TEAM)
        await asyncio.sleep(0.5)

    keyboard = build_inline_keyboard(ONBOARDING_POSITION_OPTIONS, columns=2)
    message_text = (
        f"–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º —Å –ø–µ—Ä–≤–æ–π —Å–º–µ–Ω–æ–π –≤ ¬´–ú–∞—Ä—á–µ–ª–ª–∏—Å¬ª! üéâ\n\n"
        f"–¢—ã –Ω–∞—á–∏–Ω–∞–µ—à—å —Å–≤–æ–π –ø—É—Ç—å –≤ —Ä–µ—Å—Ç–æ—Ä–∞–Ω–µ: <b>{html.escape(restaurant_name)}</b>.\n\n"
        "–ü–µ—Ä–≤–æ–µ –≤–ø–µ—á–∞—Ç–ª–µ–Ω–∏–µ ‚Äî —Å–∞–º–æ–µ –≤–∞–∂–Ω–æ–µ, –∏ –º—ã –æ—á–µ–Ω—å —Ö–æ—Ç–∏–º –µ–≥–æ —É–∑–Ω–∞—Ç—å!\n\n"
        "<b>–®–∞–≥ 1/4:</b> –ù–∞–ø–æ–º–Ω–∏, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞ –∫–∞–∫—É—é –¥–æ–ª–∂–Ω–æ—Å—Ç—å —Ç—ã –∫ –Ω–∞–º –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏–ª—Å—è(–∞—Å—å)?"
    )

    sent_message = await update.effective_message.reply_text(message_text, parse_mode=ParseMode.HTML,
                                                             reply_markup=keyboard)
    context.user_data[settings.ACTIVE_MESSAGE_ID_KEY] = sent_message.message_id

    return OnboardingState.POSITION


async def position_selected(update: Update, context: ContextTypes.DEFAULT_TYPE) -> OnboardingState:
    query = update.callback_query
    await safe_answer_callback_query(query)

    if query.data == "onboard_pos_Other":
        await send_or_edit_message(update, context, "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞–ø–∏—à–∏ —Å–≤–æ—é –¥–æ–ª–∂–Ω–æ—Å—Ç—å:")
        return OnboardingState.AWAIT_OTHER_POSITION

    chosen_button = next((b for b in ONBOARDING_POSITION_OPTIONS if b[1] == query.data), None)
    position = chosen_button[0] if chosen_button else "–ù–µ —É–∫–∞–∑–∞–Ω–∞"
    context.user_data["onboarding_position"] = position

    message_text = (
        f"–ü–æ–∑–∏—Ü–∏—è: <b>{html.escape(position)}</b>. ‚ú®\n\n"
        "<b>–®–∞–≥ 2/4:</b>\n"
        "–ü–æ–¥–µ–ª–∏—Å—å —Å–≤–æ–∏–º <b>–ø–µ—Ä–≤—ã–º –≤–ø–µ—á–∞—Ç–ª–µ–Ω–∏–µ–º</b> –ø–æ—Å–ª–µ –æ–∑–Ω–∞–∫–æ–º–∏—Ç–µ–ª—å–Ω–æ–π —Å–º–µ–Ω—ã! –ß—Ç–æ –ø–æ–Ω—Ä–∞–≤–∏–ª–æ—Å—å, —á—Ç–æ —É–¥–∏–≤–∏–ª–æ?"
    )
    await send_or_edit_message(update, context, message_text)
    return OnboardingState.IMPRESSION


async def other_position_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> OnboardingState:
    position = update.message.text.strip()
    context.user_data["onboarding_position"] = position
    context.user_data["onboarding_position_is_other"] = True

    message_text = (
        f"–ü–æ–∑–∏—Ü–∏—è: <b>{html.escape(position)}</b>. ‚ú®\n\n"
        "<b>–®–∞–≥ 2/4:</b>\n"
        "–ü–æ–¥–µ–ª–∏—Å—å —Å–≤–æ–∏–º <b>–ø–µ—Ä–≤—ã–º –≤–ø–µ—á–∞—Ç–ª–µ–Ω–∏–µ–º</b> –ø–æ—Å–ª–µ –æ–∑–Ω–∞–∫–æ–º–∏—Ç–µ–ª—å–Ω–æ–π —Å–º–µ–Ω—ã! –ß—Ç–æ –ø–æ–Ω—Ä–∞–≤–∏–ª–æ—Å—å, —á—Ç–æ —É–¥–∏–≤–∏–ª–æ?"
    )
    await send_or_edit_message(update, context, message_text)
    return OnboardingState.IMPRESSION


async def impression_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> OnboardingState:
    context.user_data["onboarding_impression"] = update.message.text.strip()
    keyboard = build_inline_keyboard(INTEREST_RATING_OPTIONS, columns=5)
    text = (
        "–°–ø–∞—Å–∏–±–æ –∑–∞ –æ—Ç–∑—ã–≤!\n\n"
        "<b>–®–∞–≥ 3/4:</b>\n"
        "–ê —Ç–µ–ø–µ—Ä—å –æ—Ü–µ–Ω–∏ —Å–≤–æ—é <b>–∑–∞–∏–Ω—Ç–µ—Ä–µ—Å–æ–≤–∞–Ω–Ω–æ—Å—Ç—å</b> –≤ –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–∏ —Å—Ç–∞–∂–∏—Ä–æ–≤–∫–∏ —É –Ω–∞—Å –ø–æ —à–∫–∞–ª–µ –æ—Ç 1 (—Å–æ–≤—Å–µ–º –Ω–µ –∏–Ω—Ç–µ—Ä–µ—Å–Ω–æ) –¥–æ 10 (–æ—á–µ–Ω—å —Ö–æ—á—É –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å)."
    )
    await send_or_edit_message(update, context, text, keyboard)
    return OnboardingState.INTEREST_RATING


async def interest_rating_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> OnboardingState:
    query = update.callback_query
    await safe_answer_callback_query(query)
    rating = query.data.replace("onboard_rate_", "")
    context.user_data["onboarding_interest_level"] = rating
    text = (
        f"–¢–≤–æ—è –æ—Ü–µ–Ω–∫–∞: <b>{rating}</b>. –ü—Ä–∏–Ω—è—Ç–æ!\n\n"
        "<b>–®–∞–≥ 4/4:</b>\n"
        "–ß—Ç–æ –±–æ–ª—å—à–µ –≤—Å–µ–≥–æ <b>–ø–æ–≤–ª–∏—è–ª–æ –Ω–∞ —Ç–≤–æ—é –æ—Ü–µ–Ω–∫—É</b>?"
    )
    await send_or_edit_message(update, context, text, None)
    return OnboardingState.INTEREST_REASON


async def interest_reason_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    context.user_data["onboarding_interest_reason"] = update.message.text.strip()
    user_id, user_name, _ = get_user_data_from_update(update)
    user = update.effective_user
    data = context.user_data
    restaurant_code = data.get("onboarding_restaurant_code")
    is_other_position = data.get("onboarding_position_is_other", False)
    user_link = format_user_for_sheets(user_id, user_name, user.username)

    row_data = [
        get_now().strftime("%Y-%m-%d %H:%M:%S"),
        user_link,
        data.get("onboarding_restaurant"),
        data.get("onboarding_position"),
        data.get("onboarding_impression"),
        data.get("onboarding_interest_level"),
        data.get("onboarding_interest_reason")
    ]
    await add_to_sheets_queue(settings.ONBOARDING_SHEET_NAME, row_data)
    await database.log_survey_completion('onboarding', user_id, restaurant_code)

    # --- Start: Notify Admins ---
    interest_level_str = data.get("onboarding_interest_level", "0")
    message_title = "üìù <b>–ù–æ–≤—ã–π –æ—Ç–∑—ã–≤ –ø–æ—Å–ª–µ –æ–∑–Ω–∞–∫–æ–º–∏—Ç–µ–ª—å–Ω–æ–π —Å–º–µ–Ω—ã</b>"
    try:
        if int(interest_level_str) < 6:
            message_title = f"‚ùóÔ∏èüö© <b>–ù–∏–∑–∫–∞—è –∑–∞–∏–Ω—Ç–µ—Ä–µ—Å–æ–≤–∞–Ω–Ω–æ—Å—Ç—å –ø–æ—Å–ª–µ —Å–º–µ–Ω—ã! ({interest_level_str}/10)</b>"
    except (ValueError, TypeError):
        pass  # If conversion fails, use the default title

    admin_message = (
        f"{message_title}\n\n"
        f"<b>–ö–∞–Ω–¥–∏–¥–∞—Ç:</b> {html.escape(user_name)}\n"
        f"<b>–†–µ—Å—Ç–æ—Ä–∞–Ω:</b> {html.escape(data.get('onboarding_restaurant', 'N/A'))}\n"
        f"<b>–î–æ–ª–∂–Ω–æ—Å—Ç—å:</b> {html.escape(data.get('onboarding_position', 'N/A'))}\n\n"
        f"<b>‚≠ê –£—Ä–æ–≤–µ–Ω—å –∏–Ω—Ç–µ—Ä–µ—Å–∞:</b> {interest_level_str}/10\n"
        f"<b>üí¨ –ü—Ä–∏—á–∏–Ω–∞ –æ—Ü–µ–Ω–∫–∏:</b>\n<pre>{html.escape(data.get('onboarding_interest_reason', 'N/A'))}</pre>\n\n"
        f"<b>üìù –í–ø–µ—á–∞—Ç–ª–µ–Ω–∏–µ –æ—Ç —Å–º–µ–Ω—ã:</b>\n<pre>{html.escape(data.get('onboarding_impression', 'N/A'))}</pre>"
    )

    if settings.ADMIN_IDS:
        for admin_id in settings.ADMIN_IDS:
            try:
                await context.bot.send_message(
                    chat_id=admin_id,
                    text=admin_message,
                    parse_mode=ParseMode.HTML
                )
            except Exception as e:
                logger.error(f"Failed to send onboarding feedback summary to admin {admin_id}: {e}")
    # --- End: Notify Admins ---


    await send_or_edit_message(update, context, "–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Ç–≤–æ–π –æ—Ç–≤–µ—Ç...")
    await remove_keyboard_from_previous_message(context, user_id)

    position = "–î—Ä—É–≥–æ–µ" if is_other_position else data.get("onboarding_position", "—Å–æ—Ç—Ä—É–¥–Ω–∏–∫–∞")
    links_data = POSITION_LINKS.get(position, [])
    critical_links = [item for item in links_data if item.get("is_critical")]
    other_links = [item for item in links_data if not item.get("is_critical") and "url" in item]
    additional_message = next((item.get("additional_message") for item in links_data if "additional_message" in item),
                              "–ñ–µ–ª–∞–µ–º —Ç–µ–±–µ —É—Å–ø–µ—à–Ω–æ–≥–æ —Å—Ç–∞—Ä—Ç–∞ –∏ —É–≤–ª–µ–∫–∞—Ç–µ–ª—å–Ω–æ–π –∞–¥–∞–ø—Ç–∞—Ü–∏–∏!")
    final_position_text = data.get("onboarding_position")

    final_message_parts = [
        f"üéâ <b>–°–ø–∞—Å–∏–±–æ –∑–∞ –æ–±—Ä–∞—Ç–Ω—É—é —Å–≤—è–∑—å! –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –∫–æ–º–∞–Ω–¥—É!</b>\n\n"
        f"–í–æ—Ç –Ω–µ—Å–∫–æ–ª—å–∫–æ –ø–æ–ª–µ–∑–Ω—ã—Ö —Å—Å—ã–ª–æ–∫ –¥–ª—è –ø–æ–∑–∏—Ü–∏–∏ '<b>{html.escape(final_position_text)}</b>':\n"
    ]

    if critical_links:
        final_message_parts.append("\n<b>‚ùóÔ∏è –û–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –∫ –∏–∑—É—á–µ–Ω–∏—é:</b>")
        for link in critical_links:
            final_message_parts.append(f"üîó <a href='{link['url']}'>{html.escape(link['name'])}</a>")

    if other_links:
        final_message_parts.append("\n<b>–ü–æ–ª–µ–∑–Ω—ã–µ –º–∞—Ç–µ—Ä–∏–∞–ª—ã:</b>")
        for link in other_links:
            final_message_parts.append(f"üîó <a href='{link['url']}'>{html.escape(link['name'])}</a>")

    final_message_parts.append(f"\n\nüîî <b>–í–∞–∂–Ω—ã–π –º–æ–º–µ–Ω—Ç:</b> {html.escape(additional_message)}\n\n")

    final_message = "\n".join(final_message_parts)

    await context.bot.send_sticker(chat_id=user_id, sticker=stickers.ONBOARDING_INFO_DOG)
    await asyncio.sleep(0.5)
    await context.bot.send_message(
        user_id,
        final_message,
        parse_mode=ParseMode.HTML,
        disable_web_page_preview=True
    )

    context.user_data.clear()
    return ConversationHandler.END


onboarding_conversation_handler = ConversationHandler(
    entry_points=[CommandHandler("start", start_onboarding_flow, filters=filters.Regex(r'onboard_'))],
    states={
        OnboardingState.POSITION: [
            CallbackQueryHandler(position_selected, pattern="^onboard_pos_"),
            MessageHandler(filters.TEXT & ~filters.COMMAND, prompt_to_use_button)
        ],
        OnboardingState.AWAIT_OTHER_POSITION: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, other_position_received)],
        OnboardingState.IMPRESSION: [MessageHandler(filters.TEXT & ~filters.COMMAND, impression_received)],
        OnboardingState.INTEREST_RATING: [
            CallbackQueryHandler(interest_rating_received, pattern="^onboard_rate_"),
            MessageHandler(filters.TEXT & ~filters.COMMAND, prompt_to_use_button)
        ],
        OnboardingState.INTEREST_REASON: [MessageHandler(filters.TEXT & ~filters.COMMAND, interest_reason_received)],
    },
    fallbacks=[CommandHandler("cancel", cancel)],
    name="onboarding_conv",
    persistent=True,
    per_message=False,
    conversation_timeout=settings.CONVERSATION_TIMEOUT_SECONDS
)

--- FILE: handlers/bot_feedback.py ---
import html
import logging

from telegram import Update, InlineKeyboardMarkup, InlineKeyboardButton
from telegram.ext import (
    ContextTypes,
    ConversationHandler,
    CallbackQueryHandler,
    MessageHandler,
    CommandHandler,
    filters,
)
from telegram.constants import ParseMode

from models import MainMenuState
from core import settings
from utils.helpers import get_user_data_from_update, add_to_sheets_queue, get_now, safe_answer_callback_query, \
    send_or_edit_message
from handlers.common import cancel

logger = logging.getLogger(__name__)

SELECT_TYPE, AWAIT_DESCRIPTION = range(2)

FEEDBACK_TYPES = {
    "fb_bug": "–û—à–∏–±–∫–∞ (–ë–∞–≥)",
    "fb_suggestion": "–ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ",
    "fb_other": "–î—Ä—É–≥–æ–µ"
}


async def start_feedback_submission(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await safe_answer_callback_query(query)
    context.user_data[settings.ACTIVE_MESSAGE_ID_KEY] = query.message.message_id

    keyboard = [
        [InlineKeyboardButton("üêû –û—à–∏–±–∫–∞ (–ë–∞–≥)", callback_data="fb_bug")],
        [InlineKeyboardButton("üí° –ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ", callback_data="fb_suggestion")],
        [InlineKeyboardButton("üìã –î—Ä—É–≥–æ–µ", callback_data="fb_other")],
    ]

    text = ("–°–ø–∞—Å–∏–±–æ, —á—Ç–æ –ø–æ–º–æ–≥–∞–µ—Ç–µ –Ω–∞–º —Å—Ç–∞—Ç—å –ª—É—á—à–µ! üôè\n\n"
            "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø –≤–∞—à–µ–π –æ–±—Ä–∞—Ç–Ω–æ–π —Å–≤—è–∑–∏:")

    await send_or_edit_message(update, context, text, InlineKeyboardMarkup(keyboard))
    return SELECT_TYPE


async def type_selected(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await safe_answer_callback_query(query)

    feedback_type_code = query.data
    feedback_type_text = FEEDBACK_TYPES.get(feedback_type_code, "–ù–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–æ")
    context.user_data['feedback_type'] = feedback_type_text

    text = (f"–í—ã –≤—ã–±—Ä–∞–ª–∏: <b>{feedback_type_text}</b>.\n\n"
            "–¢–µ–ø–µ—Ä—å, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ–ø–∏—à–∏—Ç–µ –ø–æ–¥—Ä–æ–±–Ω–æ –≤–∞—à—É –º—ã—Å–ª—å –≤ –æ–¥–Ω–æ–º —Å–æ–æ–±—â–µ–Ω–∏–∏. "
            "–ï—Å–ª–∏ —ç—Ç–æ –æ—à–∏–±–∫–∞, –æ–ø–∏—à–∏—Ç–µ —à–∞–≥–∏ –¥–ª—è –µ–µ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è.")

    await send_or_edit_message(update, context, text)
    return AWAIT_DESCRIPTION


async def description_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    description = update.message.text
    feedback_type = context.user_data.get('feedback_type', '–ù–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–æ')
    user_id, user_name, _ = get_user_data_from_update(update)
    timestamp = get_now().strftime("%Y-%m-%d %H:%M:%S")

    row_data = [timestamp, user_name, user_id, feedback_type, description, "–ù–æ–≤–æ–µ"]
    await add_to_sheets_queue(settings.BOT_FEEDBACK_SHEET_NAME, row_data)

    text = "‚úÖ –í–∞—à–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –ø—Ä–∏–Ω—è—Ç–æ! –°–ø–∞—Å–∏–±–æ –∑–∞ –≤–∞—à –≤–∫–ª–∞–¥. –ú—ã —Ä–∞—Å—Å–º–æ—Ç—Ä–∏–º –µ–≥–æ –≤ –±–ª–∏–∂–∞–π—à–µ–µ –≤—Ä–µ–º—è."
    await send_or_edit_message(update, context, text)

    context.user_data.clear()
    return ConversationHandler.END


feedback_submission_handler = ConversationHandler(
    entry_points=[CallbackQueryHandler(start_feedback_submission, pattern="^submit_bot_feedback$")],
    states={
        SELECT_TYPE: [CallbackQueryHandler(type_selected, pattern="^fb_")],
        AWAIT_DESCRIPTION: [MessageHandler(filters.TEXT & ~filters.COMMAND, description_received)],
    },
    fallbacks=[CommandHandler('cancel', cancel)],
    name="bot_feedback_conv",
    per_user=True,
    per_chat=True,
    per_message=False,
)

--- FILE: handlers/exit_interview.py ---
import html
import time
import logging
import asyncio
from datetime import timedelta

from telegram import Update, ReplyKeyboardRemove, InlineKeyboardMarkup, InlineKeyboardButton
from telegram.ext import (
    ContextTypes,
    ConversationHandler,
    CommandHandler,
    MessageHandler,
    CallbackQueryHandler,
    ChatMemberHandler,
    filters,
)
from telegram.constants import ParseMode, ChatMemberStatus
from telegram.error import Forbidden, BadRequest

from models import ExitState
from core import settings, database, stickers
from utils.helpers import (
    get_user_data_from_update,
    safe_answer_callback_query,
    send_or_edit_message,
    add_to_sheets_queue,
    get_now,
    remove_keyboard_from_previous_message
)
from utils.keyboards import (
    RESTAURANT_OPTIONS,
    EXIT_POSITION_OPTIONS,
    DURATION_OPTIONS,
    RATING_OPTIONS,
    TRAINING_OPTIONS,
    FEEDBACK_OPTIONS,
    build_inline_keyboard
)
from handlers.common import cancel

logger = logging.getLogger(__name__)


async def schedule_exit_interview_reminder(context: ContextTypes.DEFAULT_TYPE):
    job_data = context.job.data
    user_id = job_data["user_id"]
    first_check = job_data.get("first_check", True)

    if await database.is_survey_completed("exit", user_id):
        logger.info(f"User {user_id} has already completed the exit interview. Reminder job cancelled.")
        return

    if first_check:
        logger.info(f"User {user_id} did not complete exit interview after 3 days. Sending reminder.")
        try:
            keyboard = InlineKeyboardMarkup(
                [[InlineKeyboardButton("üëã –î–∞, –≥–æ—Ç–æ–≤(–∞) –ø–æ–º–æ—á—å", callback_data=settings.CALLBACK_START_EXIT)]])
            await context.bot.send_message(
                user_id,
                "–ü—Ä–∏–≤–µ—Ç! –ù–∞–ø–æ–º–∏–Ω–∞–µ–º –æ –Ω–∞—à–µ–π –ø—Ä–æ—Å—å–±–µ –ø—Ä–æ–π—Ç–∏ –Ω–µ–±–æ–ª—å—à–æ–π –æ–ø—Ä–æ—Å –ø–æ—Å–ª–µ —É–≤–æ–ª—å–Ω–µ–Ω–∏—è. –¢–≤–æ–π –æ–ø—ã—Ç –æ—á–µ–Ω—å –≤–∞–∂–µ–Ω –¥–ª—è –Ω–∞—Å! üôè",
                reply_markup=keyboard
            )
            context.job_queue.run_once(
                schedule_exit_interview_reminder,
                when=timedelta(days=3),
                data={"user_id": user_id, "first_check": False},
                name=f"exit_delete_check_{user_id}"
            )
        except (Forbidden, BadRequest):
            logger.warning(f"Could not send exit interview reminder to {user_id}. Deleting user data now.")
            await database.delete_user_data(user_id)
    else:
        logger.warning(f"User {user_id} did not complete exit interview after another 3 days. Deleting user data.")
        await database.delete_user_data(user_id)


async def handle_chat_member(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not update.chat_member or not update.chat_member.new_chat_member or not update.chat_member.new_chat_member.user:
        return

    member_update = update.chat_member
    target_user = member_update.new_chat_member.user

    if not target_user or target_user.id == context.bot.id:
        return

    new_status = member_update.new_chat_member.status
    if new_status not in (ChatMemberStatus.LEFT, ChatMemberStatus.BANNED):
        return

    target_user_id = target_user.id
    target_user_name = target_user.full_name

    logger.info(f"User {target_user_name} ({target_user_id}) left or was banned from chat {member_update.chat.title}.")

    users_interacted = context.bot_data.get("users_interacted", set())
    if target_user_id not in users_interacted:
        logger.info(f"User {target_user_id} has not interacted with the bot before. Skipping exit interview invite.")
        return

    if context.job_queue.get_jobs_by_name(f"exit_reminder_{target_user_id}"):
        logger.info(f"Exit interview flow is already active for user {target_user_id}. Ignoring new event.")
        return

    try:
        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("–î–∞, —ç—Ç–æ —Å–≤—è–∑–∞–Ω–æ —Å —É–≤–æ–ª—å–Ω–µ–Ω–∏–µ–º", callback_data=settings.CALLBACK_CONFIRM_QUIT)],
            [InlineKeyboardButton("–ù–µ—Ç, –ø—Ä–æ—Å—Ç–æ –≤—ã—à–µ–ª(–∞) –∏–∑ —á–∞—Ç–∞", callback_data=settings.CALLBACK_DECLINE_QUIT)],
        ])
        await context.bot.send_message(
            chat_id=target_user_id,
            text="–ü—Ä–∏–≤–µ—Ç! üëã –ó–∞–º–µ—Ç–∏–ª–∏, —á—Ç–æ —Ç—ã –ø–æ–∫–∏–Ω—É–ª(–∞) –Ω–∞—à —Ä–∞–±–æ—á–∏–π —á–∞—Ç.\n\n"
                 "–ï—Å–ª–∏ —ç—Ç–æ —Å–≤—è–∑–∞–Ω–æ —Å —É–≤–æ–ª—å–Ω–µ–Ω–∏–µ–º, –º—ã –±—É–¥–µ–º –æ—á–µ–Ω—å –±–ª–∞–≥–æ–¥–∞—Ä–Ω—ã –∑–∞ –æ–±—Ä–∞—Ç–Ω—É—é —Å–≤—è–∑—å. –ï—Å–ª–∏ –Ω–µ—Ç ‚Äî –ø—Ä–æ—Å—Ç–æ –Ω–∞–∂–º–∏ –≤—Ç–æ—Ä—É—é –∫–Ω–æ–ø–∫—É.",
            reply_markup=keyboard
        )
        logger.info(f"Sent exit clarification to user {target_user_name} (ID: {target_user_id}).")

        context.job_queue.run_once(
            schedule_exit_interview_reminder,
            when=timedelta(days=3),
            data={"user_id": target_user_id, "first_check": True},
            name=f"exit_reminder_{target_user_id}"
        )

    except (Forbidden, BadRequest):
        logger.warning(f"Failed to send exit clarification to user {target_user_id} (Forbidden/BadRequest).")
    except Exception as e:
        logger.error(f"Error sending exit clarification to user {target_user_id}: {e}", exc_info=True)


async def remove_exit_jobs(user_id: int, context: ContextTypes.DEFAULT_TYPE):
    jobs_reminder = context.job_queue.get_jobs_by_name(f"exit_reminder_{user_id}")
    jobs_delete = context.job_queue.get_jobs_by_name(f"exit_delete_check_{user_id}")
    for job in jobs_reminder + jobs_delete:
        job.schedule_removal()
    logger.info(f"Removed exit interview reminder/deletion jobs for user {user_id}.")


async def handle_quit_clarification(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await safe_answer_callback_query(query)
    if not query.message:
        return

    user_id = query.from_user.id
    context.user_data[settings.ACTIVE_MESSAGE_ID_KEY] = query.message.message_id

    if query.data == settings.CALLBACK_CONFIRM_QUIT:
        keyboard = InlineKeyboardMarkup(
            [[InlineKeyboardButton("üëã –î–∞, –≥–æ—Ç–æ–≤(–∞) –ø–æ–º–æ—á—å", callback_data=settings.CALLBACK_START_EXIT)]])
        text = ("–ù–∞–º –±—É–¥–µ—Ç —Ç–µ–±—è –Ω–µ —Ö–≤–∞—Ç–∞—Ç—å... üôè\n\n"
                "–õ—é–±–æ–µ –ø—Ä–æ—â–∞–Ω–∏–µ ‚Äî —ç—Ç–æ –Ω–µ–º–Ω–æ–≥–æ –≥—Ä—É—Å—Ç–Ω–æ, –Ω–æ –º—ã —É–≤–∞–∂–∞–µ–º —Ç–≤–æ–π –≤—ã–±–æ—Ä –∏ –∂–µ–ª–∞–µ–º –æ–≥—Ä–æ–º–Ω–æ–π —É–¥–∞—á–∏ –Ω–∞ –Ω–æ–≤–æ–º –ø—É—Ç–∏! "
                "–°–ø–∞—Å–∏–±–æ –∑–∞ –≤—Å—ë, —á—Ç–æ —Ç—ã —Å–¥–µ–ª–∞–ª(–∞) –¥–ª—è –∫–æ–º–∞–Ω–¥—ã ¬´–ú–∞—Ä—á–µ–ª–ª–∏—Å¬ª. –¢–≤–æ–π –æ–ø—ã—Ç –æ—á–µ–Ω—å —Ü–µ–Ω–µ–Ω –¥–ª—è –Ω–∞—Å.\n\n"
                "–ï—Å–ª–∏ –Ω–µ —Å–ª–æ–∂–Ω–æ, —É–¥–µ–ª–∏, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, <b>–ø–∞—Ä—É –º–∏–Ω—É—Ç</b> –∏ –æ—Ç–≤–µ—Ç—å –Ω–∞ 9 –∞–Ω–æ–Ω–∏–º–Ω—ã—Ö –≤–æ–ø—Ä–æ—Å–æ–≤. –≠—Ç–æ –ø–æ–º–æ–∂–µ—Ç –Ω–∞–º —Å—Ç–∞—Ç—å –ª—É—á—à–µ –¥–ª—è –±—É–¥—É—â–∏—Ö –∫–æ–ª–ª–µ–≥ ‚ú®\n\n"
                "–ì–æ—Ç–æ–≤(–∞) –Ω–∞—á–∞—Ç—å?")
        await send_or_edit_message(update, context, text, keyboard)
        context.user_data['chat_id'] = query.message.chat_id

    elif query.data == settings.CALLBACK_DECLINE_QUIT:
        await remove_exit_jobs(user_id, context)
        await send_or_edit_message(update, context, "–ü–æ–Ω—è—Ç–Ω–æ! –°–ø–∞—Å–∏–±–æ –∑–∞ —É—Ç–æ—á–Ω–µ–Ω–∏–µ. –•–æ—Ä–æ—à–µ–≥–æ –¥–Ω—è! üòä")


async def start_exit_interview_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> ExitState:
    query = update.callback_query
    await safe_answer_callback_query(query)
    context.user_data.clear()
    context.user_data['_in_exit_interview'] = True
    context.user_data['chat_id'] = query.message.chat_id

    await send_or_edit_message(update, context, "–°–ø–∞—Å–∏–±–æ —Ç–µ–±–µ –∑–∞ –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç—å –ø–æ–º–æ—á—å! üôè –î–∞–≤–∞–π –Ω–∞—á–Ω–µ–º.", None)

    await asyncio.sleep(1)

    keyboard = build_inline_keyboard(RESTAURANT_OPTIONS, columns=2)
    text = "<b>–í–æ–ø—Ä–æ—Å 1/9</b>\n–í –∫–∞–∫–æ–º <b>—Ä–µ—Å—Ç–æ—Ä–∞–Ω–µ</b> —Ç—ã —Ä–∞–±–æ—Ç–∞–ª(–∞) –≤ –ø–æ—Å–ª–µ–¥–Ω–µ–µ –≤—Ä–µ–º—è?"
    await send_or_edit_message(update, context, text, keyboard)

    return ExitState.RESTAURANT


async def exit_restaurant_chosen(update: Update, context: ContextTypes.DEFAULT_TYPE) -> ExitState:
    query = update.callback_query
    await safe_answer_callback_query(query)
    restaurant = next((b[0] for b in RESTAURANT_OPTIONS if b[1] == query.data), "N/A")
    restaurant_code = query.data.replace("res_", "")
    context.user_data["exit_restaurant"] = restaurant
    context.user_data["exit_restaurant_code"] = restaurant_code
    keyboard = build_inline_keyboard(EXIT_POSITION_OPTIONS, columns=2)
    text = f"–†–µ—Å—Ç–æ—Ä–∞–Ω: <b>{html.escape(restaurant)}</b>.\n\n<b>–í–æ–ø—Ä–æ—Å 2/9</b>\n–ù–∞ –∫–∞–∫–æ–π <b>–¥–æ–ª–∂–Ω–æ—Å—Ç–∏</b> —Ç—ã —Ä–∞–±–æ—Ç–∞–ª(–∞)?"
    await send_or_edit_message(update, context, text, keyboard)
    return ExitState.POSITION


async def exit_position_chosen(update: Update, context: ContextTypes.DEFAULT_TYPE) -> ExitState:
    query = update.callback_query
    await safe_answer_callback_query(query)
    position = next((b[0] for b in EXIT_POSITION_OPTIONS if b[1] == query.data), "N/A")
    context.user_data["exit_position"] = position
    keyboard = build_inline_keyboard(DURATION_OPTIONS, columns=3)
    text = f"–î–æ–ª–∂–Ω–æ—Å—Ç—å: <b>{html.escape(position)}</b>.\n\n<b>–í–æ–ø—Ä–æ—Å 3/9</b>\n–ö–∞–∫ <b>–¥–æ–ª–≥–æ</b> —Ç—ã –ø—Ä–æ—Ä–∞–±–æ—Ç–∞–ª(–∞) –≤ –Ω–∞—à–µ–π –∫–æ–º–ø–∞–Ω–∏–∏?"
    await send_or_edit_message(update, context, text, keyboard)
    return ExitState.DURATION


async def exit_duration_chosen(update: Update, context: ContextTypes.DEFAULT_TYPE) -> ExitState:
    query = update.callback_query
    await safe_answer_callback_query(query)
    duration = next((b[0] for b in DURATION_OPTIONS if b[1] == query.data), "N/A")
    context.user_data["exit_duration"] = duration
    text = f"–°—Ç–∞–∂: <b>{html.escape(duration)}</b>.\n\n<b>–í–æ–ø—Ä–æ—Å 4/9</b>\n–ß—Ç–æ —Å—Ç–∞–ª–æ <b>–æ—Å–Ω–æ–≤–Ω–æ–π –ø—Ä–∏—á–∏–Ω–æ–π</b> —Ç–≤–æ–µ–≥–æ —Ä–µ—à–µ–Ω–∏—è —É–π—Ç–∏? (–ë—É–¥–µ–º –±–ª–∞–≥–æ–¥–∞—Ä–Ω—ã –∑–∞ —á–µ—Å—Ç–Ω—ã–π –æ—Ç–≤–µ—Ç)"
    await send_or_edit_message(update, context, text)
    return ExitState.AWAITING_REASON


async def exit_reason_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> ExitState:
    context.user_data["exit_reason"] = update.message.text.strip()
    text = "–°–ø–∞—Å–∏–±–æ!\n\n" \
           "<b>–í–æ–ø—Ä–æ—Å 5/9</b>\n–ß—Ç–æ, –ø–æ-—Ç–≤–æ–µ–º—É, –º–æ–∂–Ω–æ –±—ã–ª–æ –±—ã <b>—É–ª—É—á—à–∏—Ç—å</b> –≤ –Ω–∞—à–µ–π —Ä–∞–±–æ—Ç–µ –∏–ª–∏ –ø—Ä–æ—Ü–µ—Å—Å–∞—Ö?"
    await send_or_edit_message(update, context, text)
    return ExitState.AWAITING_IMPROVEMENT


async def exit_improvement_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> ExitState:
    context.user_data["exit_improvement"] = update.message.text.strip()
    keyboard = build_inline_keyboard(RATING_OPTIONS, columns=3)
    text = "–û—Ç–ª–∏—á–Ω—ã–µ –∏–¥–µ–∏, —Å–ø–∞—Å–∏–±–æ!\n\n" \
           "<b>–í–æ–ø—Ä–æ—Å 6/9</b>\n–ö–∞–∫ –±—ã —Ç—ã –æ—Ü–µ–Ω–∏–ª(–∞) –≤–∑–∞–∏–º–æ–æ—Ç–Ω–æ—à–µ–Ω–∏—è –∏ <b>–ø–æ–¥–¥–µ—Ä–∂–∫—É</b> —Å–æ —Å—Ç–æ—Ä–æ–Ω—ã —Ç–≤–æ–µ–≥–æ <b>–Ω–µ–ø–æ—Å—Ä–µ–¥—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ —Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª—è</b>?"
    await send_or_edit_message(update, context, text, keyboard)
    return ExitState.LEADERSHIP


async def exit_leadership_rated(update: Update, context: ContextTypes.DEFAULT_TYPE) -> ExitState:
    query = update.callback_query
    await safe_answer_callback_query(query)
    rating = next((b[0] for b in RATING_OPTIONS if b[1] == query.data), "N/A")
    context.user_data["exit_leadership_rating"] = rating
    keyboard = build_inline_keyboard(TRAINING_OPTIONS, columns=2)
    text = f"–û—Ü–µ–Ω–∫–∞ —Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª—é: <b>{html.escape(rating)}</b>.\n\n<b>–í–æ–ø—Ä–æ—Å 7/9</b>\n–ù–∞—Å–∫–æ–ª—å–∫–æ <b>–¥–æ—Å—Ç–∞—Ç–æ—á–Ω—ã–º</b> –±—ã–ª–æ <b>–æ–±—É—á–µ–Ω–∏–µ</b>, –∫–æ—Ç–æ—Ä–æ–µ —Ç—ã –ø–æ–ª—É—á–∏–ª(–∞) –¥–ª—è —Ä–∞–±–æ—Ç—ã?"
    await send_or_edit_message(update, context, text, keyboard)
    return ExitState.TRAINING


async def exit_training_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> ExitState:
    query = update.callback_query
    await safe_answer_callback_query(query)
    training = next((b[0] for b in TRAINING_OPTIONS if b[1] == query.data), "N/A")
    context.user_data["exit_training_rating"] = training
    keyboard = build_inline_keyboard(FEEDBACK_OPTIONS, columns=2)
    text = f"–û—Ü–µ–Ω–∫–∞ –æ–±—É—á–µ–Ω–∏—è: <b>{html.escape(training)}</b>.\n\n<b>–í–æ–ø—Ä–æ—Å 8/9</b>\n–ö–∞–∫ —á–∞—Å—Ç–æ —Ç—ã –ø–æ–ª—É—á–∞–ª(–∞) <b>–æ–±—Ä–∞—Ç–Ω—É—é —Å–≤—è–∑—å</b> –æ —Å–≤–æ–µ–π —Ä–∞–±–æ—Ç–µ?"
    await send_or_edit_message(update, context, text, keyboard)
    return ExitState.FEEDBACK


async def exit_feedback_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> ExitState:
    query = update.callback_query
    await safe_answer_callback_query(query)
    feedback = next((b[0] for b in FEEDBACK_OPTIONS if b[1] == query.data), "N/A")
    context.user_data["exit_feedback_freq"] = feedback
    text = f"–ß–∞—Å—Ç–æ—Ç–∞ –æ–±—Ä–∞—Ç–Ω–æ–π —Å–≤—è–∑–∏: <b>{html.escape(feedback)}</b>. –û—Å—Ç–∞–ª—Å—è –ø–æ—Å–ª–µ–¥–Ω–∏–π —à–∞–≥! üèÅ\n\n<b>–í–æ–ø—Ä–æ—Å 9/9</b>\n–ï—Å—Ç—å –ª–∏ <b>—á—Ç–æ-—Ç–æ –µ—â–µ</b>, —á—Ç–æ —Ç—ã —Ö–æ—Ç–µ–ª(–∞) –±—ã –¥–æ–±–∞–≤–∏—Ç—å –∏–ª–∏ –ø–æ–∂–µ–ª–∞—Ç—å –±—ã–≤—à–∏–º –∫–æ–ª–ª–µ–≥–∞–º?"
    await send_or_edit_message(update, context, text)
    return ExitState.AWAITING_COMMENTS


async def exit_comments_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    context.user_data["exit_comments"] = update.message.text.strip()
    user_id, user_name, _ = get_user_data_from_update(update)
    data = context.user_data
    restaurant_code = data.get("exit_restaurant_code")
    timestamp = get_now().strftime("%Y-%m-%d %H:%M:%S")
    row_data = [
        timestamp, user_name, data.get("exit_restaurant", "N/A"), data.get("exit_position", "N/A"),
        data.get("exit_duration", "N/A"), data.get("exit_reason", "N/A"), data.get("exit_improvement", "N/A"),
        data.get("exit_leadership_rating", "N/A"), data.get("exit_training_rating", "N/A"),
        data.get("exit_feedback_freq", "N/A"), data.get("exit_comments", "N/A")
    ]

    await add_to_sheets_queue(settings.EXIT_INTERVIEW_SHEET_NAME, row_data)
    await database.log_survey_completion('exit', user_id, restaurant_code)
    await database.deactivate_employee(user_id)
    await remove_exit_jobs(user_id, context)

    admin_message = (
        f"üö∂‚Äç‚ôÇÔ∏è <b>–°–æ—Ç—Ä—É–¥–Ω–∏–∫ –ø—Ä–æ—à–µ–ª Exit-–∏–Ω—Ç–µ—Ä–≤—å—é</b>\n\n"
        f"<b>–ò–º—è:</b> {html.escape(user_name)}\n"
        f"<b>–†–µ—Å—Ç–æ—Ä–∞–Ω:</b> {html.escape(data.get('exit_restaurant', 'N/A'))}\n"
        f"<b>–î–æ–ª–∂–Ω–æ—Å—Ç—å:</b> {html.escape(data.get('exit_position', 'N/A'))}\n"
        f"<b>–°—Ç–∞–∂:</b> {html.escape(data.get('exit_duration', 'N/A'))}\n\n"
        f"<b>–û—Å–Ω–æ–≤–Ω–∞—è –ø—Ä–∏—á–∏–Ω–∞ —É—Ö–æ–¥–∞:</b>\n<pre>{html.escape(data.get('exit_reason', 'N/A'))}</pre>\n\n"
        f"<i>–°–æ—Ç—Ä—É–¥–Ω–∏–∫ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø–æ–º–µ—á–µ–Ω –∫–∞–∫ –Ω–µ–∞–∫—Ç–∏–≤–Ω—ã–π. –î–∞–Ω–Ω—ã–µ –∑–∞–ø–∏—Å–∞–Ω—ã –≤ Google-—Ç–∞–±–ª–∏—Ü—É.</i>"
    )
    for admin_id in settings.ADMIN_IDS:
        try:
            await context.bot.send_message(admin_id, admin_message, parse_mode=ParseMode.HTML)
        except Exception as e:
            logger.error(f"Failed to send exit interview summary to admin {admin_id}: {e}")


    final_text = "‚úÖ <b>–û–ø—Ä–æ—Å –∑–∞–≤–µ—Ä—à–µ–Ω!</b>\n\n–ë–æ–ª—å—à–æ–µ —Å–ø–∞—Å–∏–±–æ —Ç–µ–±–µ –∑–∞ —É–¥–µ–ª–µ–Ω–Ω–æ–µ –≤—Ä–µ–º—è –∏ —á–µ—Å—Ç–Ω—ã–µ –æ—Ç–≤–µ—Ç—ã! üôè\n–ñ–µ–ª–∞–µ–º —Ç–µ–±–µ –æ–≥—Ä–æ–º–Ω—ã—Ö —É—Å–ø–µ—Ö–æ–≤ –Ω–∞ –Ω–æ–≤–æ–º –ø—É—Ç–∏! ‚ú®"
    await send_or_edit_message(update, context, final_text)

    await asyncio.sleep(0.5)
    await context.bot.send_sticker(chat_id=user_id, sticker=stickers.SUCCESS_DOG)

    context.user_data.clear()
    return ConversationHandler.END


chat_member_handler = ChatMemberHandler(handle_chat_member, ChatMemberHandler.CHAT_MEMBER)
quit_clarification_handler = CallbackQueryHandler(
    handle_quit_clarification, pattern=f"^({settings.CALLBACK_CONFIRM_QUIT}|{settings.CALLBACK_DECLINE_QUIT})$"
)

exit_interview_conversation_handler = ConversationHandler(
    entry_points=[CallbackQueryHandler(start_exit_interview_callback, pattern=f"^{settings.CALLBACK_START_EXIT}$")],
    states={
        ExitState.RESTAURANT: [CallbackQueryHandler(exit_restaurant_chosen, pattern="^res_")],
        ExitState.POSITION: [CallbackQueryHandler(exit_position_chosen, pattern="^exit_pos_")],
        ExitState.DURATION: [CallbackQueryHandler(exit_duration_chosen, pattern="^dur_")],
        ExitState.AWAITING_REASON: [MessageHandler(filters.TEXT & ~filters.COMMAND, exit_reason_received)],
        ExitState.AWAITING_IMPROVEMENT: [MessageHandler(filters.TEXT & ~filters.COMMAND, exit_improvement_received)],
        ExitState.LEADERSHIP: [CallbackQueryHandler(exit_leadership_rated, pattern="^rate_")],
        ExitState.TRAINING: [CallbackQueryHandler(exit_training_received, pattern="^train_")],
        ExitState.FEEDBACK: [CallbackQueryHandler(exit_feedback_received, pattern="^feed_")],
        ExitState.AWAITING_COMMENTS: [MessageHandler(filters.TEXT & ~filters.COMMAND, exit_comments_received)],
    },
    fallbacks=[CommandHandler("cancel", cancel)],
    name="exit_interview_conv",
    persistent=True,
    per_message=False,
    conversation_timeout=settings.CONVERSATION_TIMEOUT_SECONDS
)

--- FILE: handlers/admin.py ---
import asyncio
import html
import logging
import math
from collections import defaultdict

from telegram import Update, InlineKeyboardMarkup, InlineKeyboardButton
from telegram.ext import (
    ContextTypes,
    CallbackQueryHandler,
    MessageHandler,
    filters,
    ConversationHandler
)
from telegram.constants import ParseMode
from telegram.error import BadRequest, Forbidden

from models import AdminState, MainMenuState
from core import settings, database
from utils.helpers import (
    safe_answer_callback_query,
    get_id_from_input,
    send_new_menu_message,
    send_or_edit_message,
    set_user_commands
)
from utils.keyboards import (
    RESTAURANT_OPTIONS,
    get_admin_menu_keyboard,
)

logger = logging.getLogger(__name__)


async def edit_admin_message(query: Update.callback_query, text: str, reply_markup: InlineKeyboardMarkup):
    try:
        await query.edit_message_text(text=text, reply_markup=reply_markup, parse_mode=ParseMode.HTML)
    except BadRequest as e:
        if "Message is not modified" not in str(e):
            logger.warning(f"Failed to edit admin message: {e}")


async def admin_panel_start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> AdminState:
    user = update.effective_user
    keyboard = get_admin_menu_keyboard()
    text = f"Ciao, {html.escape(user.first_name)}! üëã\n\n–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –ø–∞–Ω–µ–ª—å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞. –í—ã–±–µ—Ä–∏ –¥–µ–π—Å—Ç–≤–∏–µ:"
    if update.callback_query:
        await safe_answer_callback_query(update.callback_query)
        await edit_admin_message(update.callback_query, text, keyboard)
    else:
        await send_new_menu_message(context, user.id, text, keyboard)
    return AdminState.MENU


async def manage_managers_start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> AdminState:
    query = update.callback_query
    await safe_answer_callback_query(query)
    keyboard = InlineKeyboardMarkup([
        [InlineKeyboardButton("‚ûï –î–æ–±–∞–≤–∏—Ç—å –º–µ–Ω–µ–¥–∂–µ—Ä–∞", callback_data="admin_add_manager_start")],
        [InlineKeyboardButton("‚ûñ –£–¥–∞–ª–∏—Ç—å –º–µ–Ω–µ–¥–∂–µ—Ä–∞", callback_data="admin_remove_manager_start")],
        [InlineKeyboardButton("üìã –ü–æ–∫–∞–∑–∞—Ç—å —Å–ø–∏—Å–æ–∫", callback_data="admin_list_managers")],
        [InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data=settings.CALLBACK_ADMIN_BACK)],
    ])
    text = "–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –º–µ–Ω–µ–¥–∂–µ—Ä–∞–º–∏:"
    await edit_admin_message(query, text, keyboard)
    return AdminState.MANAGE_MANAGERS


async def manage_employees_start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> AdminState:
    query = update.callback_query
    await safe_answer_callback_query(query)
    button_rows_data = [RESTAURANT_OPTIONS[i:i + 2] for i in range(0, len(RESTAURANT_OPTIONS), 2)]
    keyboard_layout = [
        [InlineKeyboardButton(text, callback_data=f"list_emp_{data}_page_0") for text, data in row_data]
        for row_data in button_rows_data
    ]
    keyboard_layout.append([InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é", callback_data=settings.CALLBACK_ADMIN_BACK)])
    keyboard = InlineKeyboardMarkup(keyboard_layout)
    text = "üë• –í—ã–±–µ—Ä–∏—Ç–µ —Ä–µ—Å—Ç–æ—Ä–∞–Ω –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Å–ø–∏—Å–∫–æ–º —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–æ–≤:"
    await edit_admin_message(query, text, keyboard)
    return AdminState.CHOOSE_EMPLOYEE_RESTAURANT


async def show_employees_paginated(update: Update, context: ContextTypes.DEFAULT_TYPE) -> AdminState:
    query = update.callback_query
    await safe_answer_callback_query(query)
    parts = query.data.split('_')
    res_code_suffix = parts[3]
    page = int(parts[5])

    total_employees = await database.count_employees_in_restaurant(res_code_suffix)
    if total_employees == 0 and page == 0:
        await query.answer("–í —ç—Ç–æ–º —Ä–µ—Å—Ç–æ—Ä–∞–Ω–µ –Ω–µ—Ç —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–æ–≤.", show_alert=True)
        return await manage_employees_start(update, context)

    employees = await database.get_employees_paginated(res_code_suffix, page, settings.EMPLOYEES_PER_PAGE)
    res_name = next((name for name, code in RESTAURANT_OPTIONS if code.endswith(res_code_suffix)), res_code_suffix)
    total_pages = math.ceil(total_employees / settings.EMPLOYEES_PER_PAGE) if total_employees > 0 else 1

    buttons = []
    text = f"<b>–°–æ—Ç—Ä—É–¥–Ω–∏–∫–∏ ¬´{html.escape(res_name)}¬ª</b> (–°—Ç—Ä. {page + 1}/{total_pages})"
    for emp in employees:
        status_icon = "‚úÖ" if emp['is_active'] else "‚ö™Ô∏è"
        button_text = f"{status_icon} {html.escape(emp['full_name'] or f'User {emp['user_id']}')}"
        callback_data = f"adm_tgl_emp_{emp['user_id']}_res_{res_code_suffix}_page_{page}"
        buttons.append([InlineKeyboardButton(button_text, callback_data=callback_data)])
    nav_buttons = []
    if page > 0:
        nav_buttons.append(InlineKeyboardButton("<< 1", callback_data=f"list_emp_res_{res_code_suffix}_page_0"))
        nav_buttons.append(
            InlineKeyboardButton(f"< {page}", callback_data=f"list_emp_res_{res_code_suffix}_page_{page - 1}"))
    if page + 1 < total_pages:
        nav_buttons.append(
            InlineKeyboardButton(f"{page + 2} >", callback_data=f"list_emp_res_{res_code_suffix}_page_{page + 1}"))
        nav_buttons.append(InlineKeyboardButton(f"{total_pages} >>",
                                                callback_data=f"list_emp_res_{res_code_suffix}_page_{total_pages - 1}"))

    if nav_buttons:
        buttons.append(nav_buttons)
    buttons.append([InlineKeyboardButton("‚¨ÖÔ∏è –ö –≤—ã–±–æ—Ä—É —Ä–µ—Å—Ç–æ—Ä–∞–Ω–∞", callback_data="admin_manage_employees")])
    await edit_admin_message(query, text, InlineKeyboardMarkup(buttons))
    return AdminState.LIST_EMPLOYEES_PAGINATED


async def toggle_employee_status_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> AdminState:
    query = update.callback_query
    await safe_answer_callback_query(query)
    parts = query.data.split('_')
    user_id = int(parts[3])
    await database.toggle_employee_status(user_id)
    await query.answer("–°—Ç–∞—Ç—É—Å —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–∞ –∏–∑–º–µ–Ω–µ–Ω.")
    return await show_employees_paginated(update, context)


async def get_manager_info_text() -> str:
    managers_map = await database.get_all_managers_by_restaurant()
    if not managers_map: return "–°–ø–∏—Å–æ–∫ –º–µ–Ω–µ–¥–∂–µ—Ä–æ–≤ –ø—É—Å—Ç."
    report_parts = ["<b>üìã –ê–∫—Ç—É–∞–ª—å–Ω—ã–π —Å–ø–∏—Å–æ–∫ –º–µ–Ω–µ–¥–∂–µ—Ä–æ–≤:</b>\n"]
    for res_code_suffix, managers in sorted(managers_map.items()):
        res_name = next((name for name, code in RESTAURANT_OPTIONS if code.endswith(res_code_suffix)), res_code_suffix)
        report_parts.append(f"\n<b>üìç {html.escape(res_name)}:</b>")
        for manager in managers:
            user_mention = manager.get('full_name', '–ò–º—è –Ω–µ —É–∫–∞–∑–∞–Ω–æ')
            if manager.get('username'): user_mention += f" (@{manager['username']})"
            report_parts.append(f"  - <a href='tg://user?id={manager['user_id']}'>{html.escape(user_mention)}</a>")
    return "\n".join(report_parts)


async def list_managers(update: Update, context: ContextTypes.DEFAULT_TYPE) -> AdminState:
    query = update.callback_query
    await safe_answer_callback_query(query)
    await edit_admin_message(query, "–ó–∞–≥—Ä—É–∑–∫–∞...", None)
    keyboard = InlineKeyboardMarkup([
        [InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="admin_manage_managers")]
    ])
    await edit_admin_message(query, await get_manager_info_text(), keyboard)
    return AdminState.MANAGE_MANAGERS


async def remove_manager_start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> AdminState:
    query = update.callback_query
    await safe_answer_callback_query(query)
    await edit_admin_message(query, "–ó–∞–≥—Ä—É–∑–∫–∞...", None)
    managers_map = await database.get_all_managers_by_restaurant()
    if not managers_map:
        await query.answer("–°–ø–∏—Å–æ–∫ –º–µ–Ω–µ–¥–∂–µ—Ä–æ–≤ –ø—É—Å—Ç.", show_alert=True)
        return await manage_managers_start(update, context)

    buttons = []
    for res_code_suffix, managers in sorted(managers_map.items()):
        res_name = next((name for name, code in RESTAURANT_OPTIONS if code.endswith(res_code_suffix)), res_code_suffix)
        for manager in managers:
            user_mention = manager.get('full_name', f"User {manager['user_id']}")
            button_text = f"‚ùå {html.escape(user_mention)} ({html.escape(res_name)})"
            buttons.append([InlineKeyboardButton(button_text,
                                                 callback_data=f"admin_remove_mgr_{manager['user_id']}_{res_code_suffix}")])
    buttons.append([
        InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="admin_manage_managers"),
    ])
    await edit_admin_message(query, "–í—ã–±–µ—Ä–∏—Ç–µ –º–µ–Ω–µ–¥–∂–µ—Ä–∞ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è:", InlineKeyboardMarkup(buttons))
    return AdminState.AWAIT_REMOVAL_ID


async def remove_manager_selected(update: Update, context: ContextTypes.DEFAULT_TYPE) -> AdminState:
    query = update.callback_query
    await safe_answer_callback_query(query)
    _, _, _, user_id_str, res_code = query.data.split('_')
    await database.remove_manager(int(user_id_str), res_code)
    await set_user_commands(int(user_id_str), context.bot)
    await query.answer("–ú–µ–Ω–µ–¥–∂–µ—Ä —É–¥–∞–ª–µ–Ω.", show_alert=True)
    return await remove_manager_start(update, context)


async def add_manager_start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> AdminState:
    query = update.callback_query
    await safe_answer_callback_query(query)
    button_rows = [[InlineKeyboardButton(text, callback_data=data) for text, data in RESTAURANT_OPTIONS[i:i + 2]] for i
                   in range(0, len(RESTAURANT_OPTIONS), 2)]
    button_rows.append([
        InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="admin_manage_managers"),
    ])
    await edit_admin_message(query, "–®–∞–≥ 1: –í—ã–±–µ—Ä–∏—Ç–µ —Ä–µ—Å—Ç–æ—Ä–∞–Ω:", InlineKeyboardMarkup(button_rows))
    return AdminState.CHOOSE_ADD_RESTAURANT


async def add_restaurant_chosen(update: Update, context: ContextTypes.DEFAULT_TYPE) -> AdminState:
    query = update.callback_query
    await safe_answer_callback_query(query)
    context.user_data['admin_add_res_code'] = query.data.replace("res_", "")
    context.user_data['admin_add_res_name'] = next((n for n, c in RESTAURANT_OPTIONS if c == query.data), "?")
    text = (f"–†–µ—Å—Ç–æ—Ä–∞–Ω: ¬´{context.user_data['admin_add_res_name']}¬ª.\n\n"
            f"<b>–®–∞–≥ 2:</b> –ü–µ—Ä–µ—à–ª–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ, –≤–≤–µ–¥–∏—Ç–µ ID –∏–ª–∏ @username.\n\n"
            f"<i>–ü—Ä–∏–º–µ—á–∞–Ω–∏–µ: –ø–æ–∏—Å–∫ –ø–æ @username —Å—Ä–∞–±–æ—Ç–∞–µ—Ç, —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Ä–∞–Ω–µ–µ —É–∂–µ –∑–∞–ø—É—Å–∫–∞–ª –±–æ—Ç–∞.</i>")

    keyboard = InlineKeyboardMarkup([
        [InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –∫ –≤—ã–±–æ—Ä—É —Ä–µ—Å—Ç–æ—Ä–∞–Ω–∞", callback_data="admin_add_manager_start")],
    ])
    await edit_admin_message(query, text, keyboard)
    return AdminState.AWAIT_ADD_ID


async def add_id_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    await send_or_edit_message(update, context, "–ó–∞–≥—Ä—É–∑–∫–∞...")

    user_id_to_add = await get_id_from_input(update, context)

    if update.message:
        try:
            await update.message.delete()
        except (BadRequest, Forbidden):
            pass

    if user_id_to_add is None:
        return AdminState.AWAIT_ADD_ID

    res_code = context.user_data.get('admin_add_res_code')
    res_name = context.user_data.get('admin_add_res_name')

    if not res_code:
        await admin_panel_start(update, context)
        return ConversationHandler.END

    if await database.is_manager_in_restaurant(user_id_to_add, res_code):
        await send_or_edit_message(update, context, "‚ö†Ô∏è –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–∂–µ —è–≤–ª—è–µ—Ç—Å—è –º–µ–Ω–µ–¥–∂–µ—Ä–æ–º —ç—Ç–æ–≥–æ —Ä–µ—Å—Ç–æ—Ä–∞–Ω–∞.",
                                   get_back_to_admin_menu_keyboard())
        return AdminState.MENU

    try:
        user_chat = await context.bot.get_chat(user_id_to_add)
        full_name = f"{user_chat.first_name or ''} {user_chat.last_name or ''}".strip() or "–ò–º—è –Ω–µ –ø–æ–ª—É—á–µ–Ω–æ"
        await database.add_manager(user_id_to_add, res_code, full_name, user_chat.username)
        await set_user_commands(user_id_to_add, context.bot)
        text = f"‚úÖ <b>{html.escape(full_name)}</b> –¥–æ–±–∞–≤–ª–µ–Ω –≤ –º–µ–Ω–µ–¥–∂–µ—Ä—ã ¬´{res_name}¬ª."
        keyboard = InlineKeyboardMarkup(
            [[InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é", callback_data=settings.CALLBACK_ADMIN_BACK)]])
        await send_or_edit_message(update, context, text, keyboard)
        logger.info(f"Admin {update.effective_user.id} –¥–æ–±–∞–≤–∏–ª –º–µ–Ω–µ–¥–∂–µ—Ä–∞ {user_id_to_add} –≤ —Ä–µ—Å—Ç–æ—Ä–∞–Ω {res_code}")
    except (BadRequest, Forbidden) as e:
        await send_or_edit_message(update, context, f"–û—à–∏–±–∫–∞: –Ω–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id_to_add}. {e}",
                                   get_back_to_admin_menu_keyboard())

    context.user_data.clear()
    return AdminState.MENU


async def _get_pending_candidates_content(context: ContextTypes.DEFAULT_TYPE) -> tuple[str, InlineKeyboardMarkup]:
    pending_tasks = await database.get_all_pending_feedback()
    if not pending_tasks:
        keyboard = InlineKeyboardMarkup(
            [[InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data=settings.CALLBACK_ADMIN_BACK)]])
        return "–ù–µ—Ç –∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤ –Ω–∞ —Ä–∞—Å—Å–º–æ—Ç—Ä–µ–Ω–∏–∏.", keyboard

    candidates_by_restaurant = defaultdict(list)
    for task in pending_tasks:
        candidates_by_restaurant[task['restaurant_name']].append(task)

    context.application.bot_data['admin_pending_tasks'] = {task['id']: task for task in pending_tasks}

    text_parts = ["<b>–ö–∞–Ω–¥–∏–¥–∞—Ç—ã –Ω–∞ —Ä–∞—Å—Å–º–æ—Ç—Ä–µ–Ω–∏–∏:</b>\n–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞–Ω–¥–∏–¥–∞—Ç–∞, —á—Ç–æ–±—ã –≤—ã–ø–æ–ª–Ω–∏—Ç—å –¥–µ–π—Å—Ç–≤–∏–µ."]
    buttons = []
    for restaurant_name, candidates in sorted(candidates_by_restaurant.items()):
        text_parts.append(f"\n<b>üìç {html.escape(restaurant_name)}:</b>")
        for candidate in candidates:
            button = InlineKeyboardButton(f"üë§ {candidate['name']}", callback_data=f"cand_act_{candidate['id']}")
            buttons.append([button])

    buttons.append([InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data=settings.CALLBACK_ADMIN_BACK)])
    return "\n".join(text_parts), InlineKeyboardMarkup(buttons)


async def admin_list_pending_candidates(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await safe_answer_callback_query(query)
    text, keyboard = await _get_pending_candidates_content(context)
    await edit_admin_message(query, text, keyboard)
    return AdminState.AWAIT_CANDIDATE_ACTION


async def handle_candidate_action_menu(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await safe_answer_callback_query(query)
    feedback_id = query.data.replace("cand_act_", "")

    all_tasks = context.application.bot_data.get('admin_pending_tasks', {})
    task = all_tasks.get(feedback_id)

    if not task:
        await query.answer("–ó–∞–¥–∞—á–∞ —ç—Ç–æ–≥–æ –∫–∞–Ω–¥–∏–¥–∞—Ç–∞ —É–∂–µ –Ω–µ–∞–∫—Ç—É–∞–ª—å–Ω–∞.", show_alert=True)
        return await admin_list_pending_candidates(update, context)

    candidate_name = task.get('candidate_name', '–∫–∞–Ω–¥–∏–¥–∞—Ç–∞')
    text = f"–î–µ–π—Å—Ç–≤–∏—è –¥–ª—è –∫–∞–Ω–¥–∏–¥–∞—Ç–∞:\n<b>{html.escape(candidate_name)}</b>"

    keyboard = InlineKeyboardMarkup([
        [InlineKeyboardButton("‚úçÔ∏è –û—Å—Ç–∞–≤–∏—Ç—å –û–°", callback_data=f"fb_{feedback_id}")],
        [InlineKeyboardButton("‚ùå –£–¥–∞–ª–∏—Ç—å", callback_data=f"cand_del_{feedback_id}")],
        [InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –∫ —Å–ø–∏—Å–∫—É", callback_data="admin_pending_candidates")]
    ])
    await edit_admin_message(query, text, keyboard)
    return AdminState.AWAIT_CANDIDATE_ACTION


async def handle_admin_delete_candidate(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await safe_answer_callback_query(query)
    feedback_id = query.data.replace("cand_del_", "")

    all_tasks = context.application.bot_data.get('admin_pending_tasks', {})
    task = all_tasks.get(feedback_id)

    if not task or 'candidate_id' not in task['job_data']:
        await query.answer("–ö–∞–Ω–¥–∏–¥–∞—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω.", show_alert=True)
        return AdminState.AWAIT_CANDIDATE_ACTION

    candidate_id = task['job_data']['candidate_id']
    keyboard = InlineKeyboardMarkup([
        [InlineKeyboardButton("‚úÖ –î–∞, —É–¥–∞–ª–∏—Ç—å", callback_data=f"cand_del_confirm_{candidate_id}")],
        [InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∞", callback_data="admin_pending_candidates")]])
    await edit_admin_message(query, f"–£–¥–∞–ª–∏—Ç—å –∫–∞–Ω–¥–∏–¥–∞—Ç–∞ ID {candidate_id}?", keyboard)
    return AdminState.AWAIT_CANDIDATE_ACTION


async def handle_admin_delete_confirmation(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    await safe_answer_callback_query(query)
    candidate_id = int(query.data.replace("cand_del_confirm_", ""))

    await database.move_pending_feedback_to_history(
        candidate_id=candidate_id,
        decision_by_id=query.from_user.id,
        status="–£–¥–∞–ª–µ–Ω–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º"
    )

    logger.info(f"Admin {query.from_user.id} deleted feedback for candidate {candidate_id}.")
    await query.answer("–ö–∞–Ω–¥–∏–¥–∞—Ç —É–¥–∞–ª–µ–Ω –∏ –ø–µ—Ä–µ–º–µ—â–µ–Ω –≤ –∞—Ä—Ö–∏–≤.", show_alert=True)
    await admin_list_pending_candidates(update, context)


async def show_stats(update: Update, context: ContextTypes.DEFAULT_TYPE) -> AdminState:
    query = update.callback_query
    await safe_answer_callback_query(query)
    await edit_admin_message(query, "–ó–∞–≥—Ä—É–∑–∫–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏...", None)
    stats_by_res = await database.get_survey_counts_by_restaurant()
    if not stats_by_res:
        await edit_admin_message(query, "–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø—É—Å—Ç–∞.", get_back_to_admin_menu_keyboard())
        return AdminState.MENU
    res_map = {code.split('_')[-1]: name for name, code in RESTAURANT_OPTIONS};
    res_map['N/A'] = "–ù–µ —É–∫–∞–∑–∞–Ω"
    survey_names = {'recruitment': '–ê–Ω–∫–µ—Ç—ã', 'onboarding': '–û–Ω–±–æ—Ä–¥–∏–Ω–≥', 'manager_feedback': '–û–° –º–µ–Ω–µ–¥–∂–µ—Ä–∞',
                    'candidate_feedback': '–û–° –∫–∞–Ω–¥–∏–¥–∞—Ç–∞', 'exit': 'Exit-–∏–Ω—Ç–µ—Ä–≤—å—é', 'climate': '–ó–∞–º–µ—Ä –∫–ª–∏–º–∞—Ç–∞'}
    report = ["<b>üìà –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–æ –æ–ø—Ä–æ—Å–∞–º:</b>\n"]
    totals = defaultdict(int)
    for res_code in sorted(stats_by_res.keys(), key=lambda x: res_map.get(x, x)):
        report.append(f"\n<b>üìç {html.escape(res_map.get(res_code, res_code))}:</b>")
        for key, count in stats_by_res[res_code].items():
            if count > 0:
                report.append(f"  - {survey_names.get(key, key)}: <b>{count}</b>")
                totals[key] += count
    report.append("\n\n<b>üìä –ò—Ç–æ–≥–æ:</b>")
    for key, total in totals.items(): report.append(f"  - {survey_names.get(key, key)}: <b>{total}</b>")
    await edit_admin_message(query, "\n".join(report), get_back_to_admin_menu_keyboard())
    return AdminState.MENU


async def broadcast_climate_start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> AdminState:
    query = update.callback_query
    await safe_answer_callback_query(query)

    if context.bot_data.get('broadcast_in_progress', False):
        await query.answer("‚ùóÔ∏è –†–∞—Å—Å—ã–ª–∫–∞ —É–∂–µ –∑–∞–ø—É—â–µ–Ω–∞ –¥—Ä—É–≥–∏–º –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º.", show_alert=True)
        return AdminState.MENU

    active_ids = await database.get_active_employees()
    if not active_ids:
        await edit_admin_message(query, "–ù–µ –Ω–∞–π–¥–µ–Ω–æ –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–æ–≤.", get_back_to_admin_menu_keyboard())
        return AdminState.MENU
    context.user_data['broadcast_list'] = active_ids
    keyboard = InlineKeyboardMarkup([
        [InlineKeyboardButton(f"‚úÖ –î–∞, –∑–∞–ø—É—Å—Ç–∏—Ç—å ({len(active_ids)} —á–µ–ª.)", callback_data="admin_broadcast_confirm")],
        [InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∞", callback_data="admin_broadcast_cancel")]])
    await edit_admin_message(query,
                             f"–ó–∞–ø—É—Å—Ç–∏—Ç—å –æ–ø—Ä–æ—Å ¬´–ó–∞–º–µ—Ä –∫–ª–∏–º–∞—Ç–∞¬ª –¥–ª—è <b>{len(active_ids)}</b> –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–æ–≤?",
                             keyboard)
    return AdminState.BROADCAST_CONFIRM


async def handle_broadcast_confirmation(update: Update, context: ContextTypes.DEFAULT_TYPE) -> AdminState:
    query = update.callback_query
    await safe_answer_callback_query(query)
    if query.data == "admin_broadcast_cancel":
        await edit_admin_message(query, "–†–∞—Å—Å—ã–ª–∫–∞ –æ—Ç–º–µ–Ω–µ–Ω–∞.", None)
        await asyncio.sleep(1)
        return await admin_panel_start(update, context)

    if context.bot_data.get('broadcast_in_progress', False):
        await query.answer("‚ùóÔ∏è –†–∞—Å—Å—ã–ª–∫–∞ —É–∂–µ –±—ã–ª–∞ –∑–∞–ø—É—â–µ–Ω–∞.", show_alert=True)
        return await admin_panel_start(update, context)

    context.bot_data['broadcast_in_progress'] = True
    users = context.user_data.get('broadcast_list', [])
    if not users:
        await edit_admin_message(query, "–û—à–∏–±–∫–∞: —Å–ø–∏—Å–æ–∫ –ø—É—Å—Ç.", get_back_to_admin_menu_keyboard())
        context.bot_data['broadcast_in_progress'] = False
        return AdminState.MENU

    await edit_admin_message(query, f"–ù–∞—á–∏–Ω–∞—é —Ä–∞—Å—Å—ã–ª–∫—É –¥–ª—è {len(users)} —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–æ–≤...", None)
    success, fail = 0, 0
    keyboard = InlineKeyboardMarkup(
        [[InlineKeyboardButton("üìä –ü—Ä–æ–π—Ç–∏ –æ–ø—Ä–æ—Å", callback_data=settings.CALLBACK_START_CLIMATE)]])
    text = "–ü—Ä–∏–≤–µ—Ç! üëã –ü—Ä–µ–¥–ª–∞–≥–∞–µ–º –ø—Ä–æ–π—Ç–∏ –∞–Ω–æ–Ω–∏–º–Ω—ã–π –æ–ø—Ä–æ—Å, —á—Ç–æ–±—ã –º—ã –ª—É—á—à–µ –ø–æ–Ω–∏–º–∞–ª–∏ –∫–ª–∏–º–∞—Ç –≤ –∫–æ–º–∞–Ω–¥–µ."
    for user_id in users:
        try:
            await context.bot.send_message(user_id, text, reply_markup=keyboard)
            success += 1
            await asyncio.sleep(0.1)
        except Exception:
            fail += 1
    report = f"‚úÖ –†–∞—Å—Å—ã–ª–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞.\n\n–£—Å–ø–µ—à–Ω–æ: {success}\n–ù–µ—É—Å–ø–µ—à–Ω–æ: {fail}"
    await context.bot.send_message(update.effective_chat.id, report)
    logger.info(f"Climate survey broadcast finished. Success: {success}, Failed: {fail}")
    context.bot_data['broadcast_in_progress'] = False
    return await admin_panel_start(update, context)

--- FILE: handlers/common.py ---
import html
import logging
import time
import traceback

logger = logging.getLogger(__name__)

from telegram import Update, ReplyKeyboardRemove
from telegram.ext import ContextTypes, ConversationHandler
from telegram.constants import ParseMode
from telegram.error import BadRequest, Forbidden

from core import settings, database
from utils.helpers import (
    get_user_data_from_update,
    add_user_to_interacted,
    remove_keyboard_from_previous_message,
    send_transient_message,
    safe_answer_callback_query,
    send_new_menu_message
)


async def handle_blocked_user(user_id: int, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handles logic when a user has blocked the bot."""
    logger.warning(f"User {user_id} has blocked the bot. Aborting interaction and cleaning up data.")
    await database.delete_user_data(user_id)
    interacted_set = context.bot_data.setdefault("users_interacted", set())
    interacted_set.discard(user_id)
    return ConversationHandler.END


async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    user_id, user_name, _ = get_user_data_from_update(update)
    logger.info(f"User {user_name} ({user_id}) cancelled the conversation.")

    if context.user_data:
        context.user_data.clear()

    try:
        await remove_keyboard_from_previous_message(context, user_id)
        if update.effective_message:
            await update.effective_message.reply_text(
                "–î–µ–π—Å—Ç–≤–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ.", reply_markup=ReplyKeyboardRemove()
            )
    except Forbidden:
        return await handle_blocked_user(user_id, context)
    except Exception as e:
        logger.warning(f"Could not properly execute cancel for user {user_id}: {e}")

    return ConversationHandler.END


async def error_handler(update: object, context: ContextTypes.DEFAULT_TYPE) -> None:
    if isinstance(context.error, Forbidden):
        logger.warning(f"Caught a Forbidden error in the global error handler: {context.error}")
        if update and isinstance(update, Update) and update.effective_user:
            await handle_blocked_user(update.effective_user.id, context)
        return

    logger.error("Exception while handling an update:", exc_info=context.error)

    if update and isinstance(update, Update) and update.effective_chat:
        try:
            await context.bot.send_message(
                chat_id=update.effective_chat.id,
                text="–û–π, —á—Ç–æ-—Ç–æ –ø–æ—à–ª–æ –Ω–µ –ø–æ –ø–ª–∞–Ω—É... üõ†Ô∏è\n\n–ù–∞—à–∞ –∫–æ–º–∞–Ω–¥–∞ —É–∂–µ –ø–æ–ª—É—á–∏–ª–∞ —Å–∏–≥–Ω–∞–ª –∏ —Ä–∞–∑–±–∏—Ä–∞–µ—Ç—Å—è –≤ —Å–∏—Ç—É–∞—Ü–∏–∏. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π –Ω–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ —á–µ—Ä–µ–∑ –ø–∞—Ä—É –º–∏–Ω—É—Ç.\n\n–ï—Å–ª–∏ –ø—Ä–æ–±–ª–µ–º–∞ –ø–æ–≤—Ç–æ—Ä—è–µ—Ç—Å—è, –º–æ–∂–Ω–æ –æ—Ç–º–µ–Ω–∏—Ç—å –¥–µ–π—Å—Ç–≤–∏–µ –∫–æ–º–∞–Ω–¥–æ–π /cancel."
            )
        except Exception as e:
            logger.error(f"Failed to send user-facing error message: {e}")

    tb_list = traceback.format_exception(None, context.error, context.error.__traceback__)
    update_str = update.to_json() if isinstance(update, Update) else str(update)
    user_info = "N/A"
    if context.user_data and 'chat_id' in context.user_data:
        user_info = f"User/Chat ID: {context.user_data['chat_id']}"

    message = (
        f"üÜò <b>–û–π, –≤ –±–æ—Ç–µ —á—Ç–æ-—Ç–æ —Å–ª–æ–º–∞–ª–æ—Å—å!</b> üÜò\n\n"
        f"<b>–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å:</b> {html.escape(user_info)}\n"
        f"<b>–¢–∏–ø –æ—à–∏–±–∫–∏:</b> <code>{html.escape(type(context.error).__name__)}</code>\n"
        f"<b>–°–æ–æ–±—â–µ–Ω–∏–µ:</b>\n<pre>{html.escape(str(context.error))}</pre>\n\n"
        f"<b>–¢—Ä–∞—Å—Å–∏—Ä–æ–≤–∫–∞ (–∫—Ä–∞—Ç–∫–æ):</b>\n"
        f"<pre>{html.escape(''.join(tb_list[-3:]))[:1000]}</pre>\n\n"
        f"<b>Update (—Å–æ–∫—Ä–∞—â–µ–Ω–Ω–æ):</b>\n"
        f"<pre>{html.escape(update_str)[:1000]}</pre>"
    )

    if settings.ADMIN_IDS:
        for admin_id in settings.ADMIN_IDS:
            try:
                await context.bot.send_message(chat_id=admin_id, text=message, parse_mode=ParseMode.HTML)
            except Exception as e:
                logger.critical(f"CRITICAL: Failed to send error notification to admin {admin_id}: {e}")


async def update_timestamp_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if hasattr(context.application, "bot_data") and 'last_telegram_update_ts' in context.application.bot_data:
        context.application.bot_data['last_telegram_update_ts'] = time.time()


async def prompt_to_use_button(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.message:
        try:
            await update.message.delete()
        except (BadRequest, Forbidden):
            pass
    await send_transient_message(context, update.effective_chat.id,
                                 "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∏—Å–ø–æ–ª—å–∑—É–π –∫–Ω–æ–ø–∫–∏ –¥–ª—è –æ—Ç–≤–µ—Ç–∞. –û–Ω–∏ —á—É—Ç—å –≤—ã—à–µ ‚¨ÜÔ∏è")

--- FILE: handlers/manager_feedback_flow.py ---
import html
import logging
import time
from datetime import datetime, timedelta

from telegram import Update, InlineKeyboardMarkup, InlineKeyboardButton, User
from telegram.ext import (
    ContextTypes,
    ConversationHandler,
)
from telegram.constants import ParseMode
from telegram.error import BadRequest

from models import ManagerFeedbackState, MainMenuState
from core import settings, database
from utils.helpers import (
    safe_answer_callback_query,
    add_to_sheets_queue,
    get_now,
    send_or_edit_message,
    send_transient_message,
    format_user_for_sheets,
    TIMEZONE
)
from utils.keyboards import (
    MANAGER_FEEDBACK_OPTIONS,
    get_shift_date_keyboard,
    build_inline_keyboard
)
from handlers.common import cancel
from handlers.feedback import schedule_onboarding_noshow_check

logger = logging.getLogger(__name__)


async def start_manager_feedback_flow(update: Update, context: ContextTypes.DEFAULT_TYPE) -> ManagerFeedbackState:
    query = update.callback_query
    await safe_answer_callback_query(query)

    feedback_id = context.user_data.get('feedback_id')
    if not feedback_id:
        await query.answer("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞, –Ω–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ –∑–∞–¥–∞—á—É. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.", show_alert=True)
        return MainMenuState.MAIN

    feedback_task = await database.get_pending_feedback_by_id(feedback_id)
    if not feedback_task:
        await query.answer("–≠—Ç–∞ –∑–∞–¥–∞—á–∞ —É–∂–µ –Ω–µ–∞–∫—Ç—É–∞–ª—å–Ω–∞.", show_alert=True)
        return MainMenuState.MAIN

    context.user_data["job_data"] = feedback_task.get("job_data", {})
    context.user_data["candidate_id"] = feedback_task.get("candidate_id")
    candidate_name = feedback_task.get("candidate_name", "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –∫–∞–Ω–¥–∏–¥–∞—Ç")

    keyboard = build_inline_keyboard(MANAGER_FEEDBACK_OPTIONS, 1)

    text = f"–û—Ü–µ–Ω–∫–∞ –∫–∞–Ω–¥–∏–¥–∞—Ç–∞: <b>{html.escape(candidate_name)}</b>.\n\n–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–¥–µ–ª–∏—Å—å —Å–≤–æ–∏–º —Ä–µ—à–µ–Ω–∏–µ–º:"
    await send_or_edit_message(update, context, text, keyboard)

    return ManagerFeedbackState.AWAITING_DECISION


async def decision_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> ManagerFeedbackState:
    query = update.callback_query
    await safe_answer_callback_query(query)

    base_callback = query.data
    status_text = next((name for name, data in MANAGER_FEEDBACK_OPTIONS if data == base_callback), "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ")
    status_code_part = base_callback.replace(settings.CALLBACK_MGR_FEEDBACK_PREFIX, "")

    context.user_data["feedback_status_code"] = status_code_part
    context.user_data["feedback_status_text"] = status_text.strip("‚úÖü§î‚ùå‚õîÔ∏è ")

    if status_code_part == "onboarding":
        keyboard = get_shift_date_keyboard()
        text = (f"–û—Ç–ª–∏—á–Ω–æ! –°—Ç–∞—Ç—É—Å –∫–∞–Ω–¥–∏–¥–∞—Ç–∞: <b>{context.user_data['feedback_status_text']}</b>.\n\n"
                "–¢–µ–ø–µ—Ä—å —É–∫–∞–∂–∏ –¥–∞—Ç—É –ø–µ—Ä–≤–æ–≥–æ –¥–Ω—è –æ–∑–Ω–∞–∫–æ–º–∏—Ç–µ–ª—å–Ω–æ–π —Å–º–µ–Ω—ã:")
        await send_or_edit_message(update, context, text, keyboard)
        return ManagerFeedbackState.AWAITING_SHIFT_DATE
    else:
        text = (f"–¢–≤–æ–π –≤—ã–±–æ—Ä: <b>{context.user_data['feedback_status_text']}</b>.\n\n"
                "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞–ø–∏—à–∏ –∫—Ä–∞—Ç–∫—É—é –ø—Ä–∏—á–∏–Ω—É —Ç–∞–∫–æ–≥–æ —Ä–µ—à–µ–Ω–∏—è. –≠—Ç–æ –æ—á–µ–Ω—å –≤–∞–∂–Ω–æ –¥–ª—è –Ω–∞—Å.")
        await send_or_edit_message(update, context, text, None)
        return ManagerFeedbackState.AWAITING_REASON


async def shift_date_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> ManagerFeedbackState:
    query = update.callback_query
    await safe_answer_callback_query(query)

    if query.data == "shift_date_other":
        text = "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏ –¥–∞—Ç—É –≤ —Ñ–æ—Ä–º–∞—Ç–µ –î–î.–ú–ú.–ì–ì–ì–ì (–Ω–∞–ø—Ä–∏–º–µ—Ä, 25.12.2024):"
        await send_or_edit_message(update, context, text, None)
        return ManagerFeedbackState.AWAITING_MANUAL_SHIFT_DATE
    else:
        date_str = query.data.replace("shift_date_", "")
        context.user_data["shift_date"] = date_str
        text = (f"–î–∞—Ç–∞ —Å–º–µ–Ω—ã: <b>{datetime.fromisoformat(date_str).strftime('%d %B %Y')}</b>.\n\n"
                "–¢–µ–ø–µ—Ä—å —É–∫–∞–∂–∏ –≤—Ä–µ–º—è —Å–º–µ–Ω—ã (–Ω–∞–ø—Ä–∏–º–µ—Ä, 10-16 –∏–ª–∏ 17-23).")
        await send_or_edit_message(update, context, text, None)
        return ManagerFeedbackState.AWAITING_SHIFT_TIME


async def manual_shift_date_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> ManagerFeedbackState:
    try:
        parsed_date = datetime.strptime(update.message.text, "%d.%m.%Y").date()
        context.user_data["shift_date"] = parsed_date.isoformat()
        text = (f"–î–∞—Ç–∞ —Å–º–µ–Ω—ã: <b>{parsed_date.strftime('%d %B %Y')}</b>.\n\n"
                "–¢–µ–ø–µ—Ä—å —É–∫–∞–∂–∏ –≤—Ä–µ–º—è —Å–º–µ–Ω—ã (–Ω–∞–ø—Ä–∏–º–µ—Ä, 10-16 –∏–ª–∏ 17-23).")
        await send_or_edit_message(update, context, text)
        return ManagerFeedbackState.AWAITING_SHIFT_TIME
    except ValueError:
        await send_transient_message(context, update.effective_chat.id,
                                     "–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞—Ç—ã. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏ –≤ —Ñ–æ—Ä–º–∞—Ç–µ –î–î.–ú–ú.–ì–ì–ì–ì.")
        await update.message.delete()
        return ManagerFeedbackState.AWAITING_MANUAL_SHIFT_DATE


async def shift_time_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> ManagerFeedbackState:
    context.user_data["shift_time"] = update.message.text
    keyboard = InlineKeyboardMarkup([[
        InlineKeyboardButton("–ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π", callback_data="skip_comment")
    ]])
    text = "–û—Ç–ª–∏—á–Ω–æ. –ï—Å–ª–∏ —Ö–æ—á–µ—à—å –æ—Å—Ç–∞–≤–∏—Ç—å –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π, –Ω–∞–ø–∏—à–∏ –µ–≥–æ. " \
           "–ï—Å–ª–∏ –Ω–µ—Ç, –ø—Ä–æ—Å—Ç–æ –Ω–∞–∂–º–∏ /skip –∏–ª–∏ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ."
    await send_or_edit_message(update, context, text, keyboard)
    return ManagerFeedbackState.AWAITING_COMMENT


async def comment_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    context.user_data["feedback_comment"] = update.message.text
    await send_or_edit_message(update, context, "–°–ø–∞—Å–∏–±–æ, —Ç–≤–æ—è –æ–±—Ä–∞—Ç–Ω–∞—è —Å–≤—è–∑—å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞! üôè")
    await process_manager_feedback(context, update.effective_user)
    return ConversationHandler.END


async def skip_comment(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    user = update.effective_user
    if query:
        await safe_answer_callback_query(query)
    context.user_data["feedback_comment"] = "–ù–µ —É–∫–∞–∑–∞–Ω"
    text = "–°–ø–∞—Å–∏–±–æ, —Ç–≤–æ—è –æ–±—Ä–∞—Ç–Ω–∞—è —Å–≤—è–∑—å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞! üôè"
    await send_or_edit_message(update, context, text)
    await process_manager_feedback(context, user)
    return ConversationHandler.END


async def process_manager_feedback(context: ContextTypes.DEFAULT_TYPE, responding_user: User):
    job_data = context.user_data.get("job_data", {})
    restaurant_code = job_data.get("interview_restaurant_code")
    candidate_id = job_data.get("candidate_id")
    candidate_name = job_data.get("candidate_name")
    status = context.user_data.get("feedback_status_text")
    status_code = context.user_data.get("feedback_status_code")
    timestamp = get_now().strftime("%Y-%m-%d %H:%M:%S")

    if not candidate_id:
        logger.error(f"CRITICAL: No candidate_id found in user_data during feedback processing for user {responding_user.id}")
        return

    await database.log_survey_completion('manager_feedback', responding_user.id, restaurant_code)
    all_tasks_for_candidate = await database.get_all_pending_feedback_for_candidate(candidate_id)
    manager_details = await database.get_manager_details(responding_user.id)

    manager_link = format_user_for_sheets(
        responding_user.id,
        manager_details.get('full_name') if manager_details else responding_user.full_name,
        manager_details.get('username') if manager_details else responding_user.username
    )

    reply_text = ""
    is_final_decision = status_code in ["onboarding", "refused", "unsuitable"]

    if status_code == "onboarding":
        shift_date_iso = context.user_data.get("shift_date", "–ù–µ —É–∫–∞–∑–∞–Ω–∞")
        shift_date_str = "–ù–µ —É–∫–∞–∑–∞–Ω–∞"
        if shift_date_iso != "–ù–µ —É–∫–∞–∑–∞–Ω–∞":
            try:
                shift_date_dt = datetime.fromisoformat(shift_date_iso)
                shift_date_str = shift_date_dt.strftime('%d %B %Y')

                if context.job_queue:
                    check_time_naive = datetime.combine(shift_date_dt.date(), datetime.max.time())
                    check_time_aware = check_time_naive.replace(tzinfo=TIMEZONE) + timedelta(days=1)
                    job_context = {"candidate_id": candidate_id}
                    context.job_queue.run_once(
                        schedule_onboarding_noshow_check,
                        when=check_time_aware,
                        data=job_context,
                        name=f"onboarding_noshow_{candidate_id}"
                    )
                    logger.info(f"Scheduled onboarding no-show check for {candidate_id} on {check_time_aware}")
            except (ValueError, TypeError):
                shift_date_str = shift_date_iso

        shift_time = context.user_data.get("shift_time", "–ù–µ —É–∫–∞–∑–∞–Ω–æ")
        comment = context.user_data.get("feedback_comment", "–ù–µ —É–∫–∞–∑–∞–Ω")
        reason = "–ü—Ä–∏–Ω—è—Ç –Ω–∞ —Å–º–µ–Ω—É"

        row_data = [timestamp, candidate_name, candidate_id, status, reason, manager_link, shift_date_iso, shift_time, comment]
        await add_to_sheets_queue(settings.MANAGER_FEEDBACK_SHEET_NAME, row_data)

        reply_text_parts = [
            f"‚úÖ <b>–°—Ç–∞—Ç—É—Å –∫–∞–Ω–¥–∏–¥–∞—Ç–∞ –æ–±–Ω–æ–≤–ª–µ–Ω:</b> {html.escape(status)}",
            f"üóì <b>–î–∞—Ç–∞ —Å–º–µ–Ω—ã:</b> {html.escape(shift_date_str)}",
            f"‚è∞ <b>–í—Ä–µ–º—è:</b> {html.escape(shift_time)}",
        ]
        if comment and comment != "–ù–µ —É–∫–∞–∑–∞–Ω":
            reply_text_parts.append(f"üí¨ <b>–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π:</b> {html.escape(comment)}")
        reply_text_parts.append(f"<i>–†–µ—à–µ–Ω–∏–µ –ø—Ä–∏–Ω—è–ª(–∞): {responding_user.mention_html()}</i>")
        reply_text = "\n".join(reply_text_parts)

        context.bot_data.setdefault('candidate_check_info', {})[candidate_id] = {
            "position": job_data.get('position', '‚Äî'),
            "full_name": job_data.get('full_name', '‚Äî'),
            "address": job_data.get('address', '‚Äî'),
            "phone": job_data.get('phone', '‚Äî'),
            "timestamp": time.time()
        }
        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("üìÑ –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–∞–Ω–¥–∏–¥–∞—Ç–∞", callback_data=f"check_candidate_{candidate_id}")]
        ])
        await context.bot.send_message(chat_id=responding_user.id, text="–ö–∞–Ω–¥–∏–¥–∞—Ç –æ–¥–æ–±—Ä–µ–Ω. –ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏.", reply_markup=keyboard)
    else:
        reason = context.user_data.get("feedback_reason", "–ù–µ —É–∫–∞–∑–∞–Ω–∞")
        row_data = [timestamp, candidate_name, candidate_id, status, reason, manager_link, "", "", ""]
        await add_to_sheets_queue(settings.MANAGER_FEEDBACK_SHEET_NAME, row_data)

        if status_code in ["refused", "unsuitable"]:
            logger.info(f"Candidate {candidate_id} was refused/unsuitable. Data will be deleted.")
            await database.delete_user_data(candidate_id)

        reply_text = (
            f"‚ùóÔ∏è <b>–°—Ç–∞—Ç—É—Å –∫–∞–Ω–¥–∏–¥–∞—Ç–∞ –æ–±–Ω–æ–≤–ª–µ–Ω:</b> {html.escape(status)}\n"
            f"<b>–ü—Ä–∏—á–∏–Ω–∞:</b> {html.escape(reason)}\n"
            f"<i>–†–µ—à–µ–Ω–∏–µ –ø—Ä–∏–Ω—è–ª(–∞): {responding_user.mention_html()}</i>"
        )

    if all_tasks_for_candidate:
        if is_final_decision:
            await database.move_pending_feedback_to_history(candidate_id, responding_user.id, status)
            logger.info(f"Final decision made for candidate {candidate_id}. All pending tasks moved to history.")
        else:
            logger.info(f"Intermediate status '{status}' for candidate {candidate_id}. Tasks remain for now.")

        for task in all_tasks_for_candidate:
            try:
                await context.bot.send_message(
                    chat_id=task['manager_id'],
                    text=reply_text,
                    reply_to_message_id=task['message_id'],
                    parse_mode=ParseMode.HTML,
                    allow_sending_without_reply=True
                )
                if is_final_decision and task['manager_id'] != responding_user.id:
                    original_message = await context.bot.edit_message_reply_markup(
                        chat_id=task['manager_id'],
                        message_id=task['message_id'],
                        reply_markup=None
                    )
                    await context.bot.edit_message_text(
                         text=f"{original_message.text}\n\n<i>(–û–±—Ä–∞–±–æ—Ç–∞–Ω–æ: {responding_user.mention_html()})</i>",
                         chat_id=task['manager_id'],
                         message_id=task['message_id'],
                         parse_mode=ParseMode.HTML
                    )
            except BadRequest as e:
                if "message to reply not found" not in str(e).lower():
                    logger.warning(f"Could not send feedback update to manager {task['manager_id']} (BadRequest): {e}")
            except Exception as e:
                logger.error(f"Failed to send feedback reply to manager {task['manager_id']}: {e}")

--- FILE: handlers/manager.py ---
import html
import logging
import time
import asyncio

from telegram import Update, ReplyKeyboardRemove, InlineKeyboardMarkup, InlineKeyboardButton
from telegram.ext import (
    ContextTypes,
    ConversationHandler,
    CommandHandler,
    MessageHandler,
    CallbackQueryHandler,
    filters,
)
from telegram.constants import ParseMode

from models import ManagerRegistrationState
from core import settings, database, stickers
from utils.helpers import (
    get_user_data_from_update,
    safe_answer_callback_query,
    send_or_edit_message,
    send_transient_message,
    add_user_to_interacted,
    set_user_commands
)
from utils.keyboards import (
    RESTAURANT_OPTIONS,
    build_inline_keyboard
)
from handlers.common import cancel, prompt_to_use_button

logger = logging.getLogger(__name__)

AWAIT_REJECTION_REASON = -1


async def register_manager_start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int | ManagerRegistrationState:
    user = update.effective_user
    if not user:
        return ConversationHandler.END

    await add_user_to_interacted(user.id, context)
    context.user_data.clear()

    if user.id in settings.ADMIN_IDS:
        if update.message:
            await update.message.reply_text(
                "–ü—Ä–∏–≤–µ—Ç! –ö–∞–∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä, —Ç—ã —É–∂–µ –∏–º–µ–µ—à—å –≤—Å–µ –ø—Ä–∞–≤–∞. –î–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∏—Å–ø–æ–ª—å–∑—É–π –∫–æ–º–∞–Ω–¥—É /admin.",
                reply_markup=ReplyKeyboardRemove()
            )
        return ConversationHandler.END

    keyboard = build_inline_keyboard(RESTAURANT_OPTIONS, columns=2)
    text = ("–ü—Ä–∏–≤–µ—Ç! üëã –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ —Å–∏—Å—Ç–µ–º—É —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ –º–µ–Ω–µ–¥–∂–µ—Ä–æ–≤.\n\n"
            "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏ —Ä–µ—Å—Ç–æ—Ä–∞–Ω, –∑–∞ –∫–æ—Ç–æ—Ä—ã–º —Ç—ã –±—É–¥–µ—à—å –∑–∞–∫—Ä–µ–ø–ª–µ–Ω(–∞), —á—Ç–æ–±—ã –ø–æ–ª—É—á–∞—Ç—å –∞–Ω–∫–µ—Ç—ã –∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤ üëá")

    if update.message:
        sent_message = await update.message.reply_text(text, reply_markup=keyboard, parse_mode=ParseMode.HTML)
        context.user_data[settings.ACTIVE_MESSAGE_ID_KEY] = sent_message.message_id
    elif update.callback_query:
        await send_or_edit_message(update, context, text, keyboard)

    context.user_data['chat_id'] = update.effective_chat.id

    return ManagerRegistrationState.CHOOSE_RESTAURANT


async def restaurant_chosen(update: Update, context: ContextTypes.DEFAULT_TYPE) -> ManagerRegistrationState:
    query = update.callback_query
    await safe_answer_callback_query(query)

    if not query or not query.data:
        return ConversationHandler.END

    restaurant_code_suffix = query.data.replace("res_", "")
    restaurant_name = next((name for name, code in RESTAURANT_OPTIONS if code == query.data), "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ä–µ—Å—Ç–æ—Ä–∞–Ω")

    context.user_data['reg_restaurant_code'] = restaurant_code_suffix
    context.user_data['reg_restaurant_name'] = restaurant_name

    text = "–û—Ç–ª–∏—á–Ω–æ. –¢–µ–ø–µ—Ä—å, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞–ø–∏—à–∏ —Å–≤–æ–∏ –Ω–∞—Å—Ç–æ—è—â–∏–µ <b>–§–∞–º–∏–ª–∏—é –∏ –ò–º—è</b>."
    await send_or_edit_message(update, context, text)
    return ManagerRegistrationState.AWAIT_FULL_NAME


async def full_name_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    full_name = update.message.text
    if len(full_name.split()) < 2:
        await send_transient_message(context, update.effective_chat.id, "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏ –∏ –§–∞–º–∏–ª–∏—é, –∏ –ò–º—è.")
        await update.message.delete()
        return ManagerRegistrationState.AWAIT_FULL_NAME

    user = update.effective_user
    user_id = user.id
    username = user.username
    restaurant_code = context.user_data['reg_restaurant_code']
    restaurant_name = context.user_data['reg_restaurant_name']

    await database.add_pending_manager(
        user_id, restaurant_code, restaurant_name, full_name, username, time.time()
    )

    text = ("‚úÖ –û—Ç–ª–∏—á–Ω–æ! –¢–≤–æ—è –∑–∞—è–≤–∫–∞ –ø—Ä–∏–Ω—è—Ç–∞ –∏ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É –Ω–∞ —Ä–∞—Å—Å–º–æ—Ç—Ä–µ–Ω–∏–µ.\n\n"
            "–ö–∞–∫ —Ç–æ–ª—å–∫–æ –µ–µ –æ–¥–æ–±—Ä—è—Ç, —Ç—ã –ø–æ–ª—É—á–∏—à—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ. –°–ø–∞—Å–∏–±–æ!")
    await send_or_edit_message(update, context, text)

    if settings.ADMIN_IDS:
        approval_keyboard = InlineKeyboardMarkup([
            [
                InlineKeyboardButton("‚úÖ –û–¥–æ–±—Ä–∏—Ç—å", callback_data=f"{settings.CALLBACK_MGR_APPROVE_PREFIX}{user_id}"),
                InlineKeyboardButton("‚ùå –û—Ç–∫–ª–æ–Ω–∏—Ç—å", callback_data=f"{settings.CALLBACK_MGR_REJECT_PREFIX}{user_id}")
            ]
        ])
        message = (
            f"üîî <b>–ó–∞—è–≤–∫–∞ –Ω–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—é –º–µ–Ω–µ–¥–∂–µ—Ä–∞</b> üîî\n\n"
            f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: <b>{html.escape(full_name)} (@{username})</b> (<code>{user_id}</code>)\n"
            f"–•–æ—á–µ—Ç —Å—Ç–∞—Ç—å –º–µ–Ω–µ–¥–∂–µ—Ä–æ–º —Ä–µ—Å—Ç–æ—Ä–∞–Ω–∞: <b>{html.escape(restaurant_name)}</b>"
        )
        for admin_id in settings.ADMIN_IDS:
            try:
                await context.bot.send_sticker(chat_id=admin_id, sticker=stickers.CONTACT_MANAGER)
                await asyncio.sleep(0.3)
                await context.bot.send_message(admin_id, message, reply_markup=approval_keyboard,
                                               parse_mode=ParseMode.HTML)
            except Exception as e:
                logger.error(f"Failed to send manager approval request to admin {admin_id}: {e}")

    context.user_data.clear()
    return ConversationHandler.END


async def handle_manager_approval(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int | None:
    query = update.callback_query
    await safe_answer_callback_query(query)

    if not query or not query.data or not query.from_user:
        return

    admin_user = query.from_user
    approve_prefix = settings.CALLBACK_MGR_APPROVE_PREFIX
    reject_prefix = settings.CALLBACK_MGR_REJECT_PREFIX

    if query.data.startswith(approve_prefix):
        target_user_id = int(query.data[len(approve_prefix):])

        pending_request = await database.get_pending_manager(target_user_id)
        if not pending_request:
            await query.edit_message_text(f"{query.message.text}\n\n<i>–ó–∞—è–≤–∫–∞ —É–∂–µ –±—ã–ª–∞ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–∞.</i>",
                                          parse_mode=ParseMode.HTML, reply_markup=None)
            await query.answer("–ó–∞—è–≤–∫–∞ —É–∂–µ –±—ã–ª–∞ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–∞.", show_alert=True)
            return

        restaurant_code = pending_request['restaurant_code']
        restaurant_name = pending_request['restaurant_name']
        full_name = pending_request['full_name']
        username = pending_request['username']

        await database.remove_pending_manager(target_user_id)
        await database.add_manager(target_user_id, restaurant_code, full_name, username)

        logger.info(f"Admin {admin_user.id} approved manager {target_user_id} for restaurant {restaurant_code}.")
        await context.bot.send_message(target_user_id,
                                       f"üéâ –ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –¢–≤–æ—è –∑–∞—è–≤–∫–∞ –Ω–∞ —Ä–æ–ª—å –º–µ–Ω–µ–¥–∂–µ—Ä–∞ –≤ —Ä–µ—Å—Ç–æ—Ä–∞–Ω–µ ¬´{restaurant_name}¬ª –æ–¥–æ–±—Ä–µ–Ω–∞. –¢–µ–ø–µ—Ä—å —Ç—ã –±—É–¥–µ—à—å –ø–æ–ª—É—á–∞—Ç—å –∞–Ω–∫–µ—Ç—ã –∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤.")
        await query.edit_message_text(
            f"‚úÖ <b>–ó–∞—è–≤–∫–∞ –û–î–û–ë–†–ï–ù–ê</b>\n\n"
            f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: <b>{html.escape(full_name)} (@{username})</b>\n"
            f"–†–µ—Å—Ç–æ—Ä–∞–Ω: <b>{html.escape(restaurant_name)}</b>\n"
            f"<i>–û–±—Ä–∞–±–æ—Ç–∞–ª(–∞): {admin_user.mention_html()}</i>",
            parse_mode=ParseMode.HTML, reply_markup=None
        )
        await set_user_commands(target_user_id, context.bot)

    elif query.data.startswith(reject_prefix):
        target_user_id = int(query.data[len(reject_prefix):])

        if not await database.get_pending_manager(target_user_id):
            await query.edit_message_text(f"{query.message.text}\n\n<i>–ó–∞—è–≤–∫–∞ —É–∂–µ –±—ã–ª–∞ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–∞.</i>",
                                          parse_mode=ParseMode.HTML, reply_markup=None)
            await query.answer("–ó–∞—è–≤–∫–∞ —É–∂–µ –±—ã–ª–∞ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–∞.", show_alert=True)
            return

        context.user_data['rejection_target_id'] = target_user_id
        await query.edit_message_text(
            "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ –ø—Ä–∏—á–∏–Ω—É –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏—è. –≠—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ –±—É–¥–µ—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é.", reply_markup=None)
        return AWAIT_REJECTION_REASON

    return ConversationHandler.END


async def rejection_reason_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    reason = update.message.text
    admin_user = update.effective_user
    target_user_id = context.user_data.pop('rejection_target_id', None)

    if not target_user_id:
        await update.message.reply_text("–û—à–∏–±–∫–∞: –Ω–µ –Ω–∞–π–¥–µ–Ω ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–ª—è –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏—è.")
        return ConversationHandler.END

    pending_request = await database.get_pending_manager(target_user_id)
    if not pending_request:
        await update.message.reply_text("–ó–∞—è–≤–∫–∞ —É–∂–µ –±—ã–ª–∞ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–∞ –¥—Ä—É–≥–∏–º –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º.")
        return ConversationHandler.END

    restaurant_name = pending_request['restaurant_name']
    full_name = pending_request['full_name']
    username = pending_request['username']

    await database.remove_pending_manager(target_user_id)

    logger.info(f"Admin {admin_user.id} rejected manager {target_user_id} with reason: {reason}")

    await context.bot.send_message(
        target_user_id,
        f"üòî –ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —Ç–≤–æ—è –∑–∞—è–≤–∫–∞ –Ω–∞ —Ä–æ–ª—å –º–µ–Ω–µ–¥–∂–µ—Ä–∞ –≤ —Ä–µ—Å—Ç–æ—Ä–∞–Ω–µ ¬´{restaurant_name}¬ª –±—ã–ª–∞ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∞.\n\n"
        f"<b>–ü—Ä–∏—á–∏–Ω–∞:</b> {html.escape(reason)}"
    )

    await update.message.reply_text(
        f"‚ùå <b>–ó–∞—è–≤–∫–∞ –û–¢–ö–õ–û–ù–ï–ù–ê</b>\n\n"
        f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: <b>{html.escape(full_name)} (@{username})</b>\n"
        f"–†–µ—Å—Ç–æ—Ä–∞–Ω: <b>{html.escape(restaurant_name)}</b>\n"
        f"–ü—Ä–∏—á–∏–Ω–∞: {html.escape(reason)}\n"
        f"<i>–û–±—Ä–∞–±–æ—Ç–∞–ª(–∞): {admin_user.mention_html()}</i>",
        parse_mode=ParseMode.HTML
    )

    await set_user_commands(target_user_id, context.bot)
    return ConversationHandler.END


manager_registration_handler = ConversationHandler(
    entry_points=[
        CommandHandler("register_manager", register_manager_start),
        CallbackQueryHandler(handle_manager_approval,
                             pattern=f"^{settings.CALLBACK_MGR_APPROVE_PREFIX}|^({settings.CALLBACK_MGR_REJECT_PREFIX})")
    ],
    states={
        ManagerRegistrationState.CHOOSE_RESTAURANT: [
            CallbackQueryHandler(restaurant_chosen, pattern="^res_"),
            MessageHandler(filters.TEXT & ~filters.COMMAND, prompt_to_use_button),
        ],
        ManagerRegistrationState.AWAIT_FULL_NAME: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, full_name_received)
        ],
        AWAIT_REJECTION_REASON: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, rejection_reason_received)
        ]
    },
    fallbacks=[CommandHandler("cancel", cancel)],
    name="manager_reg_conv",
    persistent=True,
    per_message=False,
)

--- FILE: handlers/climate_survey.py ---
import html
import logging
from enum import Enum

from telegram import Update, ReplyKeyboardRemove, InlineKeyboardMarkup, InlineKeyboardButton
from telegram.ext import (
    ContextTypes,
    ConversationHandler,
    CommandHandler,
    MessageHandler,
    CallbackQueryHandler,
    filters,
)
from telegram.constants import ParseMode

from models import ClimateState
from core import settings, database
from utils.helpers import (
    get_user_data_from_update,
    safe_answer_callback_query,
    send_or_edit_message,
    add_to_sheets_queue,
    get_now
)
from utils.keyboards import (
    RESTAURANT_OPTIONS,
    GENDER_OPTIONS,
    EXIT_POSITION_OPTIONS,
    YES_NO_OPTIONS_CLIMATE,
    YES_NO_MAYBE_OPTIONS,
    build_inline_keyboard
)
from handlers.common import cancel, prompt_to_use_button

logger = logging.getLogger(__name__)


async def start_climate_survey_flow(update: Update, context: ContextTypes.DEFAULT_TYPE) -> ClimateState:
    query = update.callback_query
    await safe_answer_callback_query(query)
    context.user_data.clear()
    context.user_data['_in_climate_survey'] = True
    context.user_data['chat_id'] = query.message.chat_id

    greeting_text = (
        "–ü—Ä–∏–≤–µ—Ç! –ú—ã —Å—Ç—Ä–µ–º–∏–º—Å—è —Å–¥–µ–ª–∞—Ç—å ¬´–ú–∞—Ä—á–µ–ª–ª–∏—Å¬ª –ª—É—á—à–∏–º –º–µ—Å—Ç–æ–º –¥–ª—è —Ä–∞–±–æ—Ç—ã –∏ –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω–æ–≥–æ —Ä–æ—Å—Ç–∞. üöÄ\n\n"
        "–£—Å–ø–µ—Ö –Ω–∞—à–µ–π –∫–æ–º–ø–∞–Ω–∏–∏ ‚Äî —ç—Ç–æ –∑–∞—Å–ª—É–≥–∞ –≤—Å–µ–π –∫–æ–º–∞–Ω–¥—ã, –∏ —Ç–≤–æ–µ –º–Ω–µ–Ω–∏–µ –∏–≥—Ä–∞–µ—Ç –≤ —ç—Ç–æ–º –∫–ª—é—á–µ–≤—É—é —Ä–æ–ª—å.\n\n"
        "–ü–æ–º–æ–≥–∏ –Ω–∞–º —Å—Ç–∞—Ç—å –µ—â—ë –ª—É—á—à–µ! –ü—Ä–æ–π–¥–∏, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, —ç—Ç–æ—Ç –Ω–µ–±–æ–ª—å—à–æ–π <b>–∞–Ω–æ–Ω–∏–º–Ω—ã–π –æ–ø—Ä–æ—Å</b>. "
        "–¢–≤–æ–∏ —á–µ—Å—Ç–Ω—ã–µ –æ—Ç–≤–µ—Ç—ã ‚Äî —ç—Ç–æ —Ü–µ–Ω–Ω—ã–π –≤–∫–ª–∞–¥ –≤ –Ω–∞—à–µ –æ–±—â–µ–µ —Ä–∞–∑–≤–∏—Ç–∏–µ.")
    await send_or_edit_message(update, context, greeting_text, None)

    keyboard = InlineKeyboardMarkup([
        [InlineKeyboardButton("–î–∞", callback_data="climate_employed_yes")],
        [InlineKeyboardButton("–ù–µ—Ç", callback_data="climate_employed_no")],
    ])
    message_text = "–î–ª—è –Ω–∞—á–∞–ª–∞, –ø–æ–¥—Å–∫–∞–∂–∏, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, <b>—Ä–∞–±–æ—Ç–∞–µ—à—å –ª–∏ —Ç—ã —Å–µ–π—á–∞—Å –≤ –∫–æ–º–ø–∞–Ω–∏–∏?</b>"
    await send_or_edit_message(update, context, message_text, keyboard)

    return ClimateState.AWAIT_EMPLOYMENT_STATUS


async def climate_employment_status_selected(update: Update, context: ContextTypes.DEFAULT_TYPE) -> ClimateState | int:
    query = update.callback_query
    await safe_answer_callback_query(query)

    if query.data == "climate_employed_no":
        await send_or_edit_message(update, context, "–°–ø–∞—Å–∏–±–æ –∑–∞ —á–µ—Å—Ç–Ω–æ—Å—Ç—å. –≠—Ç–æ—Ç –æ–ø—Ä–æ—Å –ø—Ä–µ–¥–Ω–∞–∑–Ω–∞—á–µ–Ω –¥–ª—è –¥–µ–π—Å—Ç–≤—É—é—â–∏—Ö —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–æ–≤. –•–æ—Ä–æ—à–µ–≥–æ –¥–Ω—è!")
        context.user_data.clear()
        return ConversationHandler.END

    keyboard = build_inline_keyboard(RESTAURANT_OPTIONS, columns=2)
    message_text = "–û—Ç–ª–∏—á–Ω–æ! –¢–æ–≥–¥–∞ –Ω–∞—á–Ω–µ–º.\n\n<b>–í–æ–ø—Ä–æ—Å 1/17</b>\n–í –∫–∞–∫–æ–º <b>—Ä–µ—Å—Ç–æ—Ä–∞–Ω–µ</b> —Ç—ã —Ä–∞–±–æ—Ç–∞–µ—à—å?"
    await send_or_edit_message(update, context, message_text, keyboard)
    return ClimateState.RESTAURANT


async def climate_restaurant_selected(update: Update, context: ContextTypes.DEFAULT_TYPE) -> ClimateState:
    query = update.callback_query
    await safe_answer_callback_query(query)
    restaurant = next((b[0] for b in RESTAURANT_OPTIONS if b[1] == query.data), "N/A")
    restaurant_code = query.data.replace("res_", "")
    context.user_data["climate_restaurant"] = restaurant
    context.user_data["climate_restaurant_code"] = restaurant_code

    keyboard = build_inline_keyboard(GENDER_OPTIONS, columns=2)
    text = f"–†–µ—Å—Ç–æ—Ä–∞–Ω: <b>{html.escape(restaurant)}</b>.\n\n<b>–í–æ–ø—Ä–æ—Å 2/17</b>\n–£–∫–∞–∂–∏, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, —Å–≤–æ–π <b>–ø–æ–ª</b>:"
    await send_or_edit_message(update, context, text, keyboard)
    return ClimateState.GENDER


async def climate_gender_selected(update: Update, context: ContextTypes.DEFAULT_TYPE) -> ClimateState:
    query = update.callback_query
    await safe_answer_callback_query(query)
    gender = next((b[0] for b in GENDER_OPTIONS if b[1] == query.data), "N/A")
    context.user_data["climate_gender"] = gender.replace('üë®', '').replace('üë©', '').strip()

    keyboard = build_inline_keyboard(EXIT_POSITION_OPTIONS, columns=2)
    text = "<b>–í–æ–ø—Ä–æ—Å 3/17</b>\n–£–∫–∞–∂–∏, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, —Å–≤–æ—é <b>–¥–æ–ª–∂–Ω–æ—Å—Ç—å</b>:"
    await send_or_edit_message(update, context, text, keyboard)
    return ClimateState.POSITION


async def climate_position_selected(update: Update, context: ContextTypes.DEFAULT_TYPE) -> ClimateState:
    query = update.callback_query
    await safe_answer_callback_query(query)
    position = next((b[0] for b in EXIT_POSITION_OPTIONS if b[1] == query.data), "N/A")
    context.user_data["climate_position"] = position

    keyboard = build_inline_keyboard(YES_NO_OPTIONS_CLIMATE, columns=2)
    text = f"–î–æ–ª–∂–Ω–æ—Å—Ç—å: <b>{html.escape(position)}</b>.\n\n<b>–í–æ–ø—Ä–æ—Å 4/17</b>\n–ì–æ—Ç–æ–≤(–∞) –ª–∏ —Ç—ã <b>–ø–æ—Ä–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞—Ç—å</b> –Ω–∞—à—É –∫–æ–º–ø–∞–Ω–∏—é –∫–∞–∫ —Ä–∞–±–æ—Ç–æ–¥–∞—Ç–µ–ª—è –¥—Ä—É–∑—å—è–º –∏–ª–∏ –±–ª–∏–∑–∫–∏–º?"
    await send_or_edit_message(update, context, text, keyboard)
    return ClimateState.RECOMMEND


async def climate_recommend_selected(update: Update, context: ContextTypes.DEFAULT_TYPE) -> ClimateState:
    query = update.callback_query
    await safe_answer_callback_query(query)
    recommend = "–î–∞" if query.data == "climate_yes" else "–ù–µ—Ç"
    context.user_data["climate_recommend"] = recommend

    text = f"–¢–≤–æ–π –æ—Ç–≤–µ—Ç: <b>{html.escape(recommend)}</b>.\n\n<b>–í–æ–ø—Ä–æ—Å 5/17</b>\n<b>–ü–æ—á–µ–º—É</b> —Ç—ã —Ç–∞–∫ —Å—á–∏—Ç–∞–µ—à—å? (–∫—Ä–∞—Ç–∫–æ)"
    await send_or_edit_message(update, context, text)
    return ClimateState.RECOMMEND_REASON


async def climate_recommend_reason_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> ClimateState:
    context.user_data["climate_recommend_reason"] = update.message.text.strip()
    keyboard = build_inline_keyboard(YES_NO_MAYBE_OPTIONS, columns=2)
    text = "–°–ø–∞—Å–∏–±–æ! –¢–µ–ø–µ—Ä—å —Å–µ—Ä–∏—è –∫–æ—Ä–æ—Ç–∫–∏—Ö –≤–æ–ø—Ä–æ—Å–æ–≤.\n\n" \
           "<b>–í–æ–ø—Ä–æ—Å 6/17</b>\n–Ø <b>–∑–Ω–∞—é</b>, —á—Ç–æ –æ—Ç –º–µ–Ω—è –æ–∂–∏–¥–∞–µ—Ç—Å—è –Ω–∞ —Ä–∞–±–æ—Ç–µ."
    await send_or_edit_message(update, context, text, keyboard)
    return ClimateState.EXPECTATIONS


async def climate_generic_yes_no_maybe_handler(
        update: Update,
        context: ContextTypes.DEFAULT_TYPE,
        current_data_key: str,
        next_state: Enum | None,
        next_question_number: int,
        next_question_text: str,
) -> Enum | int:
    query = update.callback_query
    await safe_answer_callback_query(query)

    answer_text = next((b[0] for b in YES_NO_MAYBE_OPTIONS if b[1] == query.data), "N/A")
    context.user_data[current_data_key] = answer_text.replace('‚úÖ ', '').replace('‚òëÔ∏è ', '').replace('‚ùå ', '').replace(
        'üö´ ', '').strip()

    if next_state:
        keyboard = build_inline_keyboard(YES_NO_MAYBE_OPTIONS, columns=2)
        text = f"<b>–í–æ–ø—Ä–æ—Å {next_question_number}/17</b>\n\n{next_question_text}"
        await send_or_edit_message(update, context, text, keyboard)
        return next_state
    else:
        await climate_final_question_answered(update, context)
        return ConversationHandler.END


async def climate_expectations_selected(update: Update, context: ContextTypes.DEFAULT_TYPE) -> Enum | int:
    return await climate_generic_yes_no_maybe_handler(
        update, context, "climate_expectations", ClimateState.BEST_ABILITY, 7,
        "–£ –º–µ–Ω—è –µ—Å—Ç—å –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –¥–µ–ª–∞—Ç—å —Ç–æ, —á—Ç–æ —è –¥–µ–ª–∞—é <b>–ª—É—á—à–µ –≤—Å–µ–≥–æ</b> üí™",
    )


async def climate_best_ability_selected(update: Update, context: ContextTypes.DEFAULT_TYPE) -> Enum | int:
    return await climate_generic_yes_no_maybe_handler(
        update, context, "climate_best_ability", ClimateState.PRAISE, 8,
        "–í –ø–æ—Å–ª–µ–¥–Ω–∏–µ —Å–µ–º—å –¥–Ω–µ–π –∫—Ç–æ-—Ç–æ –Ω–∞ —Ä–∞–±–æ—Ç–µ <b>–ø–æ—Ö–≤–∞–ª–∏–ª</b> –º–µ–Ω—è –∏–ª–∏ –æ—Ü–µ–Ω–∏–ª –º–æ—é —Ä–∞–±–æ—Ç—É üéâ",
    )


async def climate_praise_selected(update: Update, context: ContextTypes.DEFAULT_TYPE) -> Enum | int:
    return await climate_generic_yes_no_maybe_handler(
        update, context, "climate_praise", ClimateState.DEVELOPMENT_CARE, 9,
        "–ú–æ–π —Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª—å –∏–ª–∏ –∫—Ç–æ-—Ç–æ –¥—Ä—É–≥–æ–π –Ω–∞ —Ä–∞–±–æ—Ç–µ <b>–∑–∞–±–æ—Ç–∏—Ç—Å—è</b> –æ –º–æ–µ–º <b>—Ä–∞–∑–≤–∏—Ç–∏–∏</b> üå±",
    )


async def climate_development_care_selected(update: Update, context: ContextTypes.DEFAULT_TYPE) -> Enum | int:
    return await climate_generic_yes_no_maybe_handler(
        update, context, "climate_development_care", ClimateState.OPINION, 10,
        "–ù–∞ —Ä–∞–±–æ—Ç–µ —É –º–µ–Ω—è –µ—Å—Ç—å –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å <b>–≤—ã—Å–∫–∞–∑–∞—Ç—å —Å–≤–æ–µ –º–Ω–µ–Ω–∏–µ</b> üó£Ô∏è",
    )


async def climate_opinion_selected(update: Update, context: ContextTypes.DEFAULT_TYPE) -> Enum | int:
    return await climate_generic_yes_no_maybe_handler(
        update, context, "climate_opinion", ClimateState.COLLEAGUE_SUCCESS, 11,
        "–ú–æ–∏ <b>–∫–æ–ª–ª–µ–≥–∏</b> –Ω–∞—Å—Ç—Ä–æ–µ–Ω—ã –Ω–∞ <b>—É—Å–ø–µ—Ö</b> ü§ù",
    )


async def climate_colleague_success_selected(update: Update, context: ContextTypes.DEFAULT_TYPE) -> Enum | int:
    return await climate_generic_yes_no_maybe_handler(
        update, context, "climate_colleague_success", ClimateState.MISSION, 12,
        "–£ –Ω–∞—Å –Ω–∞ —Ä–∞–±–æ—Ç–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç <b>–º–∏—Å—Å–∏—è –∏–ª–∏ —Ü–µ–ª—å</b>, –∫–æ—Ç–æ—Ä–∞—è –º–µ–Ω—è –≤–¥–æ—Ö–Ω–æ–≤–ª—è–µ—Ç üéØ",
    )


async def climate_mission_selected(update: Update, context: ContextTypes.DEFAULT_TYPE) -> Enum | int:
    return await climate_generic_yes_no_maybe_handler(
        update, context, "climate_mission", ClimateState.IMPORTANCE, 13,
        "–Ø —á—É–≤—Å—Ç–≤—É—é, —á—Ç–æ –º–æ—è —Ä–∞–±–æ—Ç–∞ <b>–≤–∞–∂–Ω–∞</b> ‚≠ê",
    )


async def climate_importance_selected(update: Update, context: ContextTypes.DEFAULT_TYPE) -> Enum | int:
    return await climate_generic_yes_no_maybe_handler(
        update, context, "climate_importance", ClimateState.GROWTH_OPPORTUNITY, 14,
        "–£ –º–µ–Ω—è –µ—Å—Ç—å –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å <b>—Ä–∞–∑–≤–∏–≤–∞—Ç—å—Å—è –∏ —Ä–∞—Å—Ç–∏</b> –≤ —Å–≤–æ–µ–π –∫–∞—Ä—å–µ—Ä–µ üìà",
    )


async def climate_growth_opportunity_selected(update: Update, context: ContextTypes.DEFAULT_TYPE) -> Enum | int:
    return await climate_generic_yes_no_maybe_handler(
        update, context, "climate_growth_opportunity", ClimateState.SUPPORT, 15,
        "–Ø –ø–æ–ª—É—á–∞—é <b>–ø–æ–¥–¥–µ—Ä–∂–∫—É</b> –æ—Ç —Å–≤–æ–µ–≥–æ —Ä—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª—è –≤ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–∏ —Å–≤–æ–µ–π —Ä–∞–±–æ—Ç—ã ü§ó",
    )


async def climate_support_selected(update: Update, context: ContextTypes.DEFAULT_TYPE) -> Enum | int:
    return await climate_generic_yes_no_maybe_handler(
        update, context, "climate_support", ClimateState.FRIENDS, 16,
        "–ù–∞ —Ä–∞–±–æ—Ç–µ —É –º–µ–Ω—è –µ—Å—Ç—å <b>—Ö–æ—Ä–æ—à–∏–µ –¥—Ä—É–∑—å—è</b> üòä",
    )


async def climate_friends_selected(update: Update, context: ContextTypes.DEFAULT_TYPE) -> Enum | int:
    return await climate_generic_yes_no_maybe_handler(
        update, context, "climate_friends", ClimateState.TEAM_PART, 17,
        "–í —Å–≤–æ–µ–π —Ä–∞–±–æ—Ç–µ —è —á—É–≤—Å—Ç–≤—É—é —Å–µ–±—è <b>—á–∞—Å—Ç—å—é –∫–æ–º–∞–Ω–¥—ã</b> üë•",
    )


async def climate_team_part_selected(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    return await climate_generic_yes_no_maybe_handler(
        update, context, "climate_team_part", None, 0, ""
    )


async def climate_final_question_answered(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id, user_name, _ = get_user_data_from_update(update)
    data = context.user_data
    restaurant_code = data.get("climate_restaurant_code")
    timestamp = get_now().strftime("%Y-%m-%d %H:%M:%S")

    q_keys = [
        "restaurant", "gender", "position", "recommend", "recommend_reason", "expectations",
        "best_ability", "praise", "development_care", "opinion", "colleague_success",
        "mission", "importance", "growth_opportunity", "support", "friends", "team_part"
    ]
    q_answers = [data.get(f"climate_{key}", "N/A") for key in q_keys]
    row_data = [timestamp, user_name] + q_answers

    await add_to_sheets_queue(settings.CLIMATE_SURVEY_SHEET_NAME, row_data)
    await database.log_survey_completion('climate', user_id, restaurant_code)

    await send_or_edit_message(
        update, context,
        "‚úÖ <b>–û–ø—Ä–æ—Å –∑–∞–≤–µ—Ä—à–µ–Ω!</b>\n\n–ë–æ–ª—å—à–æ–µ —Å–ø–∞—Å–∏–±–æ –∑–∞ —Ç–≤–æ–π –≤–∫–ª–∞–¥! üôè –¢–≤–æ–∏ –æ—Ç–≤–µ—Ç—ã –ø–æ–º–æ–≥—É—Ç –Ω–∞–º —Å–¥–µ–ª–∞—Ç—å —Ä–∞–±–æ—á—É—é —Å—Ä–µ–¥—É –≤ ¬´–ú–∞—Ä—á–µ–ª–ª–∏—Å¬ª –µ—â–µ –ª—É—á—à–µ."
    )
    context.user_data.clear()


climate_survey_conversation_handler = ConversationHandler(
    entry_points=[CallbackQueryHandler(start_climate_survey_flow, pattern=f"^{settings.CALLBACK_START_CLIMATE}$")],
    states={
        ClimateState.AWAIT_EMPLOYMENT_STATUS: [
            CallbackQueryHandler(climate_employment_status_selected, pattern="^climate_employed_")],
        ClimateState.RESTAURANT: [CallbackQueryHandler(climate_restaurant_selected, pattern="^res_"),
                                  MessageHandler(filters.TEXT, prompt_to_use_button)],
        ClimateState.GENDER: [CallbackQueryHandler(climate_gender_selected, pattern="^climate_gender_"),
                              MessageHandler(filters.TEXT, prompt_to_use_button)],
        ClimateState.POSITION: [CallbackQueryHandler(climate_position_selected, pattern="^exit_pos_"),
                                MessageHandler(filters.TEXT, prompt_to_use_button)],
        ClimateState.RECOMMEND: [CallbackQueryHandler(climate_recommend_selected, pattern="^climate_(yes|no)$"),
                                 MessageHandler(filters.TEXT, prompt_to_use_button)],
        ClimateState.RECOMMEND_REASON: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, climate_recommend_reason_received)],
        ClimateState.EXPECTATIONS: [CallbackQueryHandler(climate_expectations_selected, pattern="^climate_q_"),
                                    MessageHandler(filters.TEXT, prompt_to_use_button)],
        ClimateState.BEST_ABILITY: [CallbackQueryHandler(climate_best_ability_selected, pattern="^climate_q_"),
                                    MessageHandler(filters.TEXT, prompt_to_use_button)],
        ClimateState.PRAISE: [CallbackQueryHandler(climate_praise_selected, pattern="^climate_q_"),
                              MessageHandler(filters.TEXT, prompt_to_use_button)],
        ClimateState.DEVELOPMENT_CARE: [CallbackQueryHandler(climate_development_care_selected, pattern="^climate_q_"),
                                        MessageHandler(filters.TEXT, prompt_to_use_button)],
        ClimateState.OPINION: [CallbackQueryHandler(climate_opinion_selected, pattern="^climate_q_"),
                               MessageHandler(filters.TEXT, prompt_to_use_button)],
        ClimateState.COLLEAGUE_SUCCESS: [
            CallbackQueryHandler(climate_colleague_success_selected, pattern="^climate_q_"),
            MessageHandler(filters.TEXT, prompt_to_use_button)],
        ClimateState.MISSION: [CallbackQueryHandler(climate_mission_selected, pattern="^climate_q_"),
                               MessageHandler(filters.TEXT, prompt_to_use_button)],
        ClimateState.IMPORTANCE: [CallbackQueryHandler(climate_importance_selected, pattern="^climate_q_"),
                                  MessageHandler(filters.TEXT, prompt_to_use_button)],
        ClimateState.GROWTH_OPPORTUNITY: [
            CallbackQueryHandler(climate_growth_opportunity_selected, pattern="^climate_q_"),
            MessageHandler(filters.TEXT, prompt_to_use_button)],
        ClimateState.SUPPORT: [CallbackQueryHandler(climate_support_selected, pattern="^climate_q_"),
                               MessageHandler(filters.TEXT, prompt_to_use_button)],
        ClimateState.FRIENDS: [CallbackQueryHandler(climate_friends_selected, pattern="^climate_q_"),
                               MessageHandler(filters.TEXT, prompt_to_use_button)],
        ClimateState.TEAM_PART: [CallbackQueryHandler(climate_team_part_selected, pattern="^climate_q_"),
                                 MessageHandler(filters.TEXT, prompt_to_use_button)],
    },
    fallbacks=[CommandHandler("cancel", cancel)],
    name="climate_survey_conv",
    persistent=True,
    per_message=False,
    conversation_timeout=settings.CONVERSATION_TIMEOUT_SECONDS
)

