--- FILE: monitor.py ---
import os
import time
import psutil
import sys
import requests
from pathlib import Path
from dotenv import load_dotenv

sys.path.append(str(Path(__file__).parent.resolve()))
from core.logging_config import setup_logging

BASE_DIR = Path(__file__).parent.resolve()
load_dotenv(BASE_DIR / ".env")

logger = setup_logging("MONITOR")

FROZEN_THRESHOLD_SECONDS = 90
CHECK_INTERVAL_SECONDS = 60

PID_FILE = BASE_DIR / "bot.pid"
HEARTBEAT_FILE = BASE_DIR / "heartbeat.txt"
PING_FILE = BASE_DIR / "ping.txt"

def get_bot_pid():
    try:
        with open(PID_FILE, "r") as f:
            return int(f.read().strip())
    except (FileNotFoundError, ValueError):
        return None

def kill_process(pid: int):
    try:
        process = psutil.Process(pid)
        logger.warning(f"Process {pid} found. Attempting to terminate gracefully.")
        process.terminate()
        try:
            process.wait(timeout=5)
            logger.info(f"Process {pid} terminated gracefully.")
        except psutil.TimeoutExpired:
            logger.warning(f"Graceful termination failed. Forcing kill on process {pid}.")
            process.kill()
            logger.info(f"Process {pid} killed.")
    except psutil.NoSuchProcess:
        logger.warning(f"Process {pid} not found (already terminated).")
    except psutil.Error as e:
        logger.error(f"Failed to terminate process {pid} with psutil error: {e}", exc_info=True)
    except Exception as e:
        logger.error(f"An unexpected error occurred while terminating process {pid}: {e}", exc_info=True)


def cleanup_files():
    for f in [PID_FILE, HEARTBEAT_FILE, PING_FILE]:
        if f.exists():
            try:
                os.remove(f)
            except (OSError, PermissionError) as e:
                logger.error(f"Failed to remove file {f}: {e}")
    logger.info("State files cleaned up.")

def send_ping_to_bot():
    url = "http://localhost:8888/ping"
    try:
        response = requests.get(url, timeout=5)
        response.raise_for_status()
        logger.info(f"HTTP Ping to {url} successful (status {response.status_code}).")
        return True
    except requests.RequestException as e:
        logger.error(f"Network error sending HTTP ping to {url}: {e}")
        return False

if __name__ == "__main__":
    logger.info("Health Monitor started.")
    while True:
        try:
            time.sleep(CHECK_INTERVAL_SECONDS)

            bot_pid = get_bot_pid()
            if not bot_pid or not psutil.pid_exists(bot_pid):
                logger.warning(f"Bot is not running (PID {bot_pid} not found). Skipping check.")
                continue

            if HEARTBEAT_FILE.exists():
                try:
                    time_since_heartbeat = time.time() - HEARTBEAT_FILE.stat().st_mtime
                    if time_since_heartbeat > FROZEN_THRESHOLD_SECONDS:
                        logger.critical(
                            f"PROCESS HEARTBEAT LOST! Last signal was {time_since_heartbeat:.0f}s ago. Killing process {bot_pid}."
                        )
                        kill_process(bot_pid)
                        cleanup_files()
                        continue
                except FileNotFoundError:
                    logger.warning("Heartbeat file disappeared during check. Race condition?")
            else:
                 logger.warning("Heartbeat file (heartbeat.txt) not found. Bot might have just started.")

            logger.info("Performing functional check via HTTP /ping...")
            if not send_ping_to_bot():
                logger.critical(f"BOT IS UNRESPONSIVE! HTTP server did not respond. Killing process {bot_pid}.")
                kill_process(bot_pid)
                cleanup_files()
            else:
                logger.info("✅ HEALTH CHECK PASSED. Bot is responsive.")

        except KeyboardInterrupt:
            logger.info("Health Monitor stopped by user.")
            sys.exit(0)
        except Exception as e:
            logger.error(f"Unexpected error in monitor loop: {e}", exc_info=True)
            time.sleep(CHECK_INTERVAL_SECONDS)

--- FILE: models.py ---
from enum import Enum, auto

class OnboardingState(Enum):
    POSITION = auto()
    AWAIT_OTHER_POSITION = auto()
    IMPRESSION = auto()
    INTEREST_RATING = auto()
    INTEREST_REASON = auto()

class OnboardingFollowupState(Enum):
    AWAITING_STATUS = auto()
    AWAITING_LEAVING_REASON = auto()
    AWAITING_FURTHER_REASON = auto()

class ExitState(Enum):
    RESTAURANT = auto()
    POSITION = auto()
    DURATION = auto()
    LEADERSHIP = auto()
    TRAINING = auto()
    FEEDBACK = auto()
    AWAITING_REASON = auto()
    AWAITING_IMPROVEMENT = auto()
    AWAITING_COMMENTS = auto()

class ClimateState(Enum):
    AWAIT_EMPLOYMENT_STATUS = auto()
    RESTAURANT = auto()
    GENDER = auto()
    POSITION = auto()
    RECOMMEND = auto()
    RECOMMEND_REASON = auto()
    EXPECTATIONS = auto()
    BEST_ABILITY = auto()
    PRAISE = auto()
    DEVELOPMENT_CARE = auto()
    OPINION = auto()
    COLLEAGUE_SUCCESS = auto()
    MISSION = auto()
    IMPORTANCE = auto()
    GROWTH_OPPORTUNITY = auto()
    SUPPORT = auto()
    FRIENDS = auto()
    TEAM_PART = auto()

class RecruitmentState(Enum):
    FULL_NAME = auto()
    AGE = auto()
    FAMILY_INFO = auto()
    VACANCY_SOURCE = auto()
    AWAIT_MULTI_VACANCY = auto()
    AWAIT_OTHER_VACANCY = auto()
    REASON_FOR_CHOICE = auto()
    AWAIT_MULTI_RESTAURANT = auto()
    KNOWS_MARCELLIS = auto()
    NIGHT_SHIFTS = auto()
    WEEKLY_SHIFTS = auto()
    MOBILE_PHONE = auto()
    SOCIAL_LINK = auto()
    CITY = auto()
    ADDRESS = auto()
    AWAIT_CHECKPOINT_1 = auto()
    MARITAL_STATUS = auto()
    CHILDREN = auto()
    HEALTH_ASSESSMENT = auto()
    ATTITUDE_TO_APPEARANCE = auto()
    EDUCATION_NAME = auto()
    GRADUATION_YEAR = auto()
    COURSE = auto()
    EDUCATION_FORM = auto()
    AWAIT_ADDITIONAL_COURSES_DECISION = auto()
    ADDITIONAL_COURSES = auto()
    EXPERIENCE_DURATION = auto()
    AWAIT_EXPERIENCE_DETAILS = auto()
    EXPECTED_INCOME = auto()
    REASON_FOR_LEAVING = auto()
    PREVIOUS_JOBS_COUNT = auto()
    AWAIT_CHECKPOINT_2 = auto()
    ATTITUDE_TO_SPORT = auto()
    LIFE_VALUES = auto()
    LIFE_WEAKNESSES = auto()
    LIFE_GOAL = auto()
    READING_NOW = auto()
    JUDGED_BEFORE = auto()

class ManagerRegistrationState(Enum):
    CHOOSE_RESTAURANT = auto()
    AWAIT_FULL_NAME = auto()

class AdminState(Enum):
    MENU = auto()
    MANAGE_MANAGERS = auto()
    MANAGE_EMPLOYEES = auto()
    CHOOSE_EMPLOYEE_RESTAURANT = auto()
    LIST_EMPLOYEES_PAGINATED = auto()
    AWAIT_REMOVAL_ID = auto()
    CHOOSE_ADD_RESTAURANT = auto()
    AWAIT_ADD_ID = auto()
    BROADCAST_CONFIRM = auto()
    AWAIT_CANDIDATE_ACTION = auto()

class FeedbackState(Enum):
    AWAITING_FEEDBACK = auto()

class ManagerFeedbackState(Enum):
    AWAITING_DECISION = auto()
    AWAITING_REASON = auto()
    AWAITING_SHIFT_DATE = auto()
    AWAITING_MANUAL_SHIFT_DATE = auto()
    AWAITING_SHIFT_TIME = auto()
    AWAITING_COMMENT = auto()

class CandidateFeedbackState(Enum):
    AWAITING_IMPRESSION = auto()
    AWAITING_CONDITIONS_MET = auto()
    AWAITING_REQUIREMENTS_CLEAR = auto()
    AWAITING_ADDITIONAL_COMMENTS = auto()

class MainMenuState(Enum):
    MAIN = auto()
    AWAITING_FEEDBACK_CHOICE = auto()
    ADMIN_PANEL = auto()

--- FILE: watchdog.py ---
import subprocess
import time
import sys
import os
from pathlib import Path

sys.path.append(str(Path(__file__).parent.resolve()))
from core.logging_config import setup_logging

logger = setup_logging("WATCHDOG")

script_dir = Path(__file__).parent.resolve()
main_script_path = script_dir / "main.py"

if not main_script_path.is_file():
    logger.critical(f"Main bot script not found at: {main_script_path}")
    sys.exit(1)

python_executable = sys.executable

RESTART_INTERVAL_SECONDS = 604800

logger.info(f"Using Python: {python_executable}")
logger.info(f"Path to bot script: {main_script_path}")
logger.info(f"Watchdog starting. Bot will be restarted every {RESTART_INTERVAL_SECONDS / 3600:.1f} hours.")

while True:
    try:
        logger.info("Starting bot process...")
        start_time = time.time()

        process = subprocess.Popen(
            [python_executable, str(main_script_path)],
            env=os.environ.copy()
        )

        while True:
            return_code = process.poll()
            if return_code is not None:
                logger.warning(f"Bot process exited with code: {return_code}. Restarting in 5 seconds...")
                time.sleep(5)
                break

            uptime = time.time() - start_time
            if uptime > RESTART_INTERVAL_SECONDS:
                logger.info(f"Planned restart: bot has been running for {uptime:.0f} seconds. Terminating...")
                process.terminate()
                try:
                    process.wait(timeout=10)
                    logger.info("Bot terminated gracefully for planned restart.")
                except subprocess.TimeoutExpired:
                    logger.warning("Graceful termination failed during planned restart. Forcing kill.")
                    process.kill()
                break

            time.sleep(1)

    except KeyboardInterrupt:
        logger.info("KeyboardInterrupt received. Shutting down watchdog...")
        if 'process' in locals() and process.poll() is None:
            logger.info("Terminating bot process...")
            process.terminate()
            try:
                process.wait(timeout=5)
            except subprocess.TimeoutExpired:
                logger.warning("Bot did not terminate gracefully, killing.")
                process.kill()
        break

    except (OSError, subprocess.SubprocessError) as e:
        logger.error(f"Error in watchdog loop regarding subprocess: {e}", exc_info=True)
        logger.warning("Restarting in 15 seconds after error...")
        time.sleep(15)
        continue
    except Exception as e:
        logger.error(f"Unexpected error in watchdog loop: {e}", exc_info=True)
        logger.warning("Restarting in 15 seconds after error...")
        time.sleep(15)
        continue

    time.sleep(1)

logger.info("Watchdog has been shut down.")

--- FILE: requirements.txt ---
aiohappyeyeballs==2.6.1
aiohttp==3.12.13
aiosignal==1.3.2
aiosqlite==0.21.0
anyio==4.8.0
APScheduler==3.11.0
attrs==25.3.0
cachetools==5.5.1
certifi==2025.7.14
charset-normalizer==3.4.1
class-registry==2.1.2
filters==1.3.2
frozenlist==1.7.0
google-api-core==2.25.1
google-api-python-client==2.176.0
google-auth==2.38.0
google-auth-httplib2==0.2.0
google-auth-oauthlib==1.2.1
googleapis-common-protos==1.70.0
gspread==6.0.2
gspread_asyncio==2.0.0
h11==0.14.0
httpcore==1.0.7
httplib2==0.22.0
httpx==0.28.1
idna==3.10
multidict==6.4.4
numpy==2.2.2
oauthlib==3.2.2
pandas==2.2.3
propcache==0.3.2
proto-plus==1.26.1
protobuf==6.31.1
psutil==7.0.0
pyasn1==0.6.1
pyasn1_modules==0.4.1
pyparsing==3.2.3
pytest-win32consoletitle==0.1.2
python-dateutil==2.9.0.post0
python-dotenv==1.1.0
python-telegram-bot==22.0
pytz==2025.1
regex==2024.11.6
requests==2.32.3
requests-oauthlib==2.0.0
rsa==4.9
six==1.17.0
sniffio==1.3.1
StrEnum==0.4.15
tenacity==9.0.0
typing_extensions==4.12.2
tzdata==2025.1
tzlocal==5.3
uritemplate==4.2.0
urllib3==2.3.0
watchdog==5.0.3
Win32Security==2.1.0
yarl==1.20.1


--- FILE: package_project.py ---
import os
from pathlib import Path

# --- НАСТРОЙКИ ---
# Папка, в которой находится ваш проект
ROOT_DIRECTORY = Path(__file__).parent

# Имя файла, в который будет сохранен весь код
OUTPUT_FILE = "full_project_code.txt"

# Папки, которые нужно исключить из сборки (очень важно для venv!)
EXCLUDE_DIRS = {
    ".venv",
    "venv",
    "__pycache__",
    ".git",
    ".idea",
    "bot_database.sqlite-journal"  # Исключаем временные файлы БД
}

# Расширения файлов, которые нужно включить
INCLUDE_EXTENSIONS = {
    ".py",
    ".txt",
    ".env",
    ".json"
}


# ------------------

def package_project():
    """Собирает все текстовые файлы проекта в один большой текстовый файл."""
    full_code = []

    print(f"Начинаю сборку проекта из папки: {ROOT_DIRECTORY}")

    # os.walk рекурсивно обойдет все папки и файлы
    for dirpath, dirnames, filenames in os.walk(ROOT_DIRECTORY):

        # Удаляем из списка папок те, которые нужно исключить
        # Это предотвращает обход этих папок os.walk
        dirnames[:] = [d for d in dirnames if d not in EXCLUDE_DIRS]

        # Преобразуем путь в объект Path для удобства
        current_path = Path(dirpath)

        for filename in filenames:
            # Собираем полный путь к файлу
            file_path = current_path / filename

            # Проверяем расширение файла
            if file_path.suffix in INCLUDE_EXTENSIONS:
                try:
                    with open(file_path, 'r', encoding='utf-8') as f:
                        content = f.read()

                        # Получаем относительный путь для заголовка
                        relative_path = file_path.relative_to(ROOT_DIRECTORY)

                        # Формируем красивый заголовок
                        header = f"--- FILE: {str(relative_path).replace(os.sep, '/')} ---\n"

                        # Добавляем заголовок и содержимое в наш список
                        full_code.append(header)
                        full_code.append(content)
                        full_code.append("\n\n")  # Добавляем отступ между файлами

                        print(f"  [+] Добавлен файл: {relative_path}")

                except Exception as e:
                    print(f"  [!] Ошибка чтения файла {file_path}: {e}")

    # Записываем все собранное в один файл
    try:
        with open(ROOT_DIRECTORY / OUTPUT_FILE, 'w', encoding='utf-8') as f:
            f.writelines(full_code)
        print(f"\n✅ Проект успешно собран в файл: {OUTPUT_FILE}")
    except Exception as e:
        print(f"\n❌ Ошибка записи в итоговый файл: {e}")


if __name__ == "__main__":
    package_project()

--- FILE: main.py ---
import asyncio
import logging
import os
import time
import psutil
from datetime import timedelta

from telegram import Update
from telegram.ext import (
    Application,
    PicklePersistence,
    CommandHandler,
    CallbackQueryHandler,
    ChatMemberHandler,
    TypeHandler,
    ConversationHandler,
    JobQueue,
    MessageHandler,
    filters,
    ContextTypes,
)
from aiohttp import web

from models import AdminState, MainMenuState, FeedbackState, ManagerFeedbackState
from core import settings, database, g_sheets, monitoring
from core.logging_config import setup_logging
from handlers.common import error_handler, update_timestamp_handler, cancel
from handlers.recruitment import recruitment_conversation_handler, show_full_recruitment_report, \
    send_candidate_check_info
from handlers.onboarding import onboarding_conversation_handler
from handlers.exit_interview import (
    exit_interview_conversation_handler,
    chat_member_handler,
    quit_clarification_handler
)
from handlers.climate_survey import climate_survey_conversation_handler
from handlers.bot_feedback import feedback_submission_handler
from handlers.manager import manager_registration_handler, handle_manager_approval
from handlers.admin import (
    list_managers, add_manager_start, remove_manager_start,
    broadcast_climate_start, admin_panel_start, add_restaurant_chosen,
    add_id_received, handle_broadcast_confirmation,
    show_stats, admin_list_pending_candidates, remove_manager_selected,
    handle_admin_delete_candidate, handle_admin_delete_confirmation,
    manage_employees_start, toggle_employee_status_handler, manage_managers_start,
    show_employees_paginated, handle_candidate_action_menu
)
from handlers.feedback import (
    candidate_feedback_conversation_handler,
    onboarding_followup_conversation_handler,
)
from handlers.main_menu import start, handle_manager_feedback_button, handle_feedback_candidate_selection, \
    receive_and_forward_feedback, start_feedback
from handlers.manager_feedback_flow import (
    start_manager_feedback_flow,
    decision_received,
    shift_date_received,
    manual_shift_date_received,
    shift_time_received,
    comment_received,
    skip_comment,
    process_manager_feedback
)
from utils.helpers import send_or_edit_message

logger = setup_logging(__name__)

background_tasks = set()
stop_event = asyncio.Event()


async def cleanup_bot_data(context: ContextTypes.DEFAULT_TYPE):
    now = time.time()
    bot_data = context.bot_data
    cleanup_count = 0
    if 'candidate_check_info' in bot_data:
        thirty_days_ago = now - timedelta(days=30).total_seconds()
        keys_to_delete = [
            cid for cid, data in bot_data['candidate_check_info'].items()
            if data.get('timestamp', 0) < thirty_days_ago
        ]
        for key in keys_to_delete:
            del bot_data['candidate_check_info'][key]
            cleanup_count += 1

    if cleanup_count > 0:
        logger.info(f"Bot data cleanup: Removed {cleanup_count} old entries.")


async def post_init(application: Application):
    global background_tasks, stop_event
    application.bot_data.setdefault("last_telegram_update_ts", time.time())

    if not all([settings.TOKEN, settings.GOOGLE_CREDENTIALS_JSON, settings.SPREADSHEET_ID, settings.ADMIN_IDS]):
        logger.critical("CRITICAL ERROR: One or more required environment variables are missing or invalid.")

    agc_manager = await g_sheets.init_google_sheets_client()
    if not agc_manager:
        logger.warning("Google Sheets client failed to initialize. Recording to sheets is disabled.")

    loop = asyncio.get_running_loop()

    if agc_manager:
        writer_task = loop.create_task(
            g_sheets.batch_writer_task(application, stop_event, agc_manager, application.bot_data)
        )
        background_tasks.add(writer_task)
        writer_task.add_done_callback(background_tasks.discard)

    if application.job_queue:
        application.job_queue.run_repeating(
            cleanup_bot_data,
            interval=timedelta(hours=24),
            first=timedelta(seconds=10),
            name="cleanup_bot_data"
        )
        logger.info("Scheduled periodic bot_data cleanup.")

    logger.info(f"Bot post-initialization complete. {len(background_tasks)} background tasks started.")


async def on_shutdown(application: Application):
    global background_tasks, stop_event
    logger.info("--- Initiating graceful shutdown sequence ---")
    if not stop_event.is_set():
        stop_event.set()
    if background_tasks:
        logger.info(f"Cancelling {len(background_tasks)} background tasks...")
        for task in list(background_tasks):
            if not task.done():
                task.cancel()
        try:
            await asyncio.gather(*background_tasks, return_exceptions=True)
            logger.info("All background tasks cancelled.")
        except asyncio.CancelledError:
            logger.info("Gather was cancelled, this is expected.")
        background_tasks.clear()
    if os.path.exists(settings.PID_FILE):
        try:
            os.remove(settings.PID_FILE)
            logger.info(f"PID file {settings.PID_FILE} removed.")
        except OSError:
            pass
    logger.info("--- Bot shutdown complete ---")


async def reason_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    context.user_data["feedback_reason"] = update.message.text
    await send_or_edit_message(update, context, "Спасибо, твоя обратная связь сохранена! 🙏")
    await process_manager_feedback(context, update.effective_user)
    return ConversationHandler.END


async def main() -> None:
    logger.info("--- Bot Starting Up ---")

    await database.init_db()
    logger.info("Database initialization complete.")

    try:
        pid = os.getpid()
        with open(settings.PID_FILE, "w") as f:
            f.write(str(pid))
        logger.info(f"Bot process started with PID: {pid}.")
    except Exception as e:
        logger.critical(f"Could not write PID file '{settings.PID_FILE}': {e}.")
        return

    persistence = PicklePersistence(filepath=settings.PERSISTENCE_FILE)
    application = (
        Application.builder()
        .token(settings.TOKEN)
        .persistence(persistence)
        .post_init(post_init)
        .post_shutdown(on_shutdown)
        .read_timeout(30).write_timeout(30).connect_timeout(30)
        .job_queue(JobQueue())
        .build()
    )

    application.add_handler(TypeHandler(Update, update_timestamp_handler), group=-1)
    application.add_handler(
        CallbackQueryHandler(handle_manager_approval,
                             pattern=f"^{settings.CALLBACK_MGR_APPROVE_PREFIX}|^{settings.CALLBACK_MGR_REJECT_PREFIX}")
    )
    application.add_handler(CallbackQueryHandler(show_full_recruitment_report, pattern=f"^show_full_report_"))
    application.add_handler(CallbackQueryHandler(send_candidate_check_info, pattern=f"^check_candidate_"))
    application.add_handler(CallbackQueryHandler(handle_admin_delete_confirmation, pattern="^cand_del_confirm_"))
    application.add_handler(chat_member_handler)
    application.add_handler(quit_clarification_handler)

    application.add_handler(recruitment_conversation_handler)
    application.add_handler(onboarding_conversation_handler)
    application.add_handler(candidate_feedback_conversation_handler)
    application.add_handler(onboarding_followup_conversation_handler)
    application.add_handler(manager_registration_handler)
    application.add_handler(climate_survey_conversation_handler)
    application.add_handler(exit_interview_conversation_handler)
    application.add_handler(feedback_submission_handler)

    admin_conversation_handler = ConversationHandler(
        entry_points=[
            CommandHandler("start", admin_panel_start, filters=filters.User(user_id=settings.ADMIN_IDS)),
            CommandHandler("admin", admin_panel_start, filters=filters.User(user_id=settings.ADMIN_IDS)),
            CallbackQueryHandler(admin_panel_start, pattern=f"^{settings.CALLBACK_ADMIN_BACK}$")
        ],
        states={
            AdminState.MENU: [
                CallbackQueryHandler(manage_managers_start, pattern="admin_manage_managers"),
                CallbackQueryHandler(manage_employees_start, pattern="admin_manage_employees"),
                CallbackQueryHandler(admin_list_pending_candidates, pattern="admin_pending_candidates"),
                CallbackQueryHandler(broadcast_climate_start, pattern="admin_broadcast_climate_start"),
                CallbackQueryHandler(show_stats, pattern="admin_stats"),
            ],
            AdminState.MANAGE_MANAGERS: [
                CallbackQueryHandler(add_manager_start, pattern="admin_add_manager_start"),
                CallbackQueryHandler(remove_manager_start, pattern="admin_remove_manager_start"),
                CallbackQueryHandler(list_managers, pattern="admin_list_managers"),
                CallbackQueryHandler(admin_panel_start, pattern=settings.CALLBACK_ADMIN_BACK),
            ],
            AdminState.CHOOSE_EMPLOYEE_RESTAURANT: [
                CallbackQueryHandler(show_employees_paginated, pattern="^list_emp_res_"),
                CallbackQueryHandler(admin_panel_start, pattern=settings.CALLBACK_ADMIN_BACK),
            ],
            AdminState.LIST_EMPLOYEES_PAGINATED: [
                CallbackQueryHandler(toggle_employee_status_handler, pattern="^adm_tgl_emp_"),
                CallbackQueryHandler(show_employees_paginated, pattern="^list_emp_res_"),
                CallbackQueryHandler(manage_employees_start, pattern="admin_manage_employees"),
            ],
            AdminState.CHOOSE_ADD_RESTAURANT: [
                CallbackQueryHandler(add_restaurant_chosen, pattern="^res_"),
                CallbackQueryHandler(manage_managers_start, pattern="admin_manage_managers"),
            ],
            AdminState.AWAIT_ADD_ID: [
                MessageHandler(filters.TEXT & ~filters.COMMAND | filters.FORWARDED, add_id_received),
                CallbackQueryHandler(add_manager_start, pattern="admin_add_manager_start"),
            ],
            AdminState.AWAIT_REMOVAL_ID: [
                CallbackQueryHandler(remove_manager_selected, pattern="^admin_remove_mgr_"),
                CallbackQueryHandler(manage_managers_start, pattern="admin_manage_managers"),
            ],
            AdminState.BROADCAST_CONFIRM: [
                CallbackQueryHandler(handle_broadcast_confirmation,
                                     pattern=f"^(admin_broadcast_confirm|admin_broadcast_cancel)$"),
            ],
            AdminState.AWAIT_CANDIDATE_ACTION: [
                CallbackQueryHandler(handle_candidate_action_menu, pattern="^cand_act_"),
                CallbackQueryHandler(handle_admin_delete_candidate, pattern="^cand_del_"),
                CallbackQueryHandler(admin_list_pending_candidates, pattern="admin_pending_candidates")
            ]
        },
        fallbacks=[
            CommandHandler("cancel", cancel),
            CommandHandler("start", admin_panel_start, filters=filters.User(user_id=settings.ADMIN_IDS))
        ],
        persistent=True,
        name="admin_conv",
        per_message=False,
    )

    main_conversation_handler = ConversationHandler(
        entry_points=[
            CommandHandler("start", start, filters=~filters.User(user_id=settings.ADMIN_IDS)),
            CommandHandler("feedback", start_feedback),
            CallbackQueryHandler(start, pattern=f"^{settings.CALLBACK_GO_TO_MAIN_MENU}$"),
            MessageHandler(
                filters.TEXT & ~filters.COMMAND & filters.ChatType.PRIVATE & ~filters.User(user_id=settings.ADMIN_IDS),
                start_feedback),
        ],
        states={
            MainMenuState.MAIN: [
                CallbackQueryHandler(handle_manager_feedback_button, pattern="^manager_feedback$"),
                CallbackQueryHandler(start, pattern="^main_menu$"),
            ],
            MainMenuState.AWAITING_FEEDBACK_CHOICE: [
                CallbackQueryHandler(handle_feedback_candidate_selection, pattern="^fb_"),
                CallbackQueryHandler(start, pattern="^main_menu$"),
            ],
            FeedbackState.AWAITING_FEEDBACK: [
                MessageHandler(filters.TEXT & ~filters.COMMAND & filters.ChatType.PRIVATE, receive_and_forward_feedback)
            ],
            ManagerFeedbackState.AWAITING_DECISION: [
                CallbackQueryHandler(decision_received, pattern=f"^{settings.CALLBACK_MGR_FEEDBACK_PREFIX}")
            ],
            ManagerFeedbackState.AWAITING_REASON: [MessageHandler(filters.TEXT & ~filters.COMMAND, reason_received)],
            ManagerFeedbackState.AWAITING_SHIFT_DATE: [
                CallbackQueryHandler(shift_date_received, pattern="^shift_date_")
            ],
            ManagerFeedbackState.AWAITING_MANUAL_SHIFT_DATE: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, manual_shift_date_received)
            ],
            ManagerFeedbackState.AWAITING_SHIFT_TIME: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, shift_time_received)
            ],
            ManagerFeedbackState.AWAITING_COMMENT: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, comment_received),
                CallbackQueryHandler(skip_comment, pattern="^skip_comment$"),
                CommandHandler("skip", skip_comment),
            ],
        },
        fallbacks=[
            CommandHandler("cancel", cancel),
            CommandHandler("start", start, filters=~filters.User(user_id=settings.ADMIN_IDS))
        ],
        persistent=True,
        name="main_conversation_handler",
        per_message=False,
    )

    application.add_handler(admin_conversation_handler)
    application.add_handler(main_conversation_handler)
    application.add_error_handler(error_handler)

    logger.info("Starting bot polling...")

    await application.initialize()
    await application.start()
    await application.updater.start_polling(allowed_updates=Update.ALL_TYPES)

    await stop_event.wait()

    await application.updater.stop()
    await application.stop()
    await application.shutdown()


if __name__ == "__main__":
    try:
        asyncio.run(main())
    except (KeyboardInterrupt, SystemExit):
        logger.info("Bot stopped by user or system.")
    except Exception as e:
        logger.critical(f"Bot failed to run due to an unhandled exception: {e}", exc_info=True)

--- FILE: ping.txt ---
1756994692.770977

--- FILE: heartbeat.txt ---
1756994730.699946

--- FILE: core/g_sheets.py ---
import asyncio
import gspread
import gspread_asyncio
import html
import logging
import requests
import json
from collections import defaultdict
from tenacity import retry, stop_after_attempt, wait_exponential, retry_if_exception_type
from typing import List, Any, Tuple

from google.oauth2.service_account import Credentials
from telegram.ext import Application
from telegram.constants import ParseMode

from core import settings, database

logger = logging.getLogger(__name__)

GSPREAD_RETRY_ERRORS = (
    gspread.exceptions.APIError,
    requests.exceptions.ConnectionError,
    requests.exceptions.Timeout,
    requests.exceptions.RequestException,
    gspread.exceptions.GSpreadException,
    TimeoutError,
)

MAX_WRITE_ATTEMPTS = 3

retry_gspread_operation = retry(
    stop=stop_after_attempt(5),
    wait=wait_exponential(multiplier=1, min=10, max=60),
    retry=retry_if_exception_type(GSPREAD_RETRY_ERRORS),
    reraise=True,
    before_sleep=lambda retry_state: logger.warning(
        f"Retrying GSheets operation (attempt {retry_state.attempt_number}) due to: {retry_state.outcome.exception()}"
    )
)


async def init_google_sheets_client() -> gspread_asyncio.AsyncioGspreadClientManager | None:
    logger.info("Initializing Google Sheets client...")
    if not settings.GOOGLE_CREDENTIALS_JSON:
        logger.error("GSheets credentials not found in GOOGLE_CREDENTIALS_JSON env variable. Sheets will not work.")
        return None
    if not settings.SPREADSHEET_ID:
        logger.error("SPREADSHEET_ID is not set in .env file. Sheets will not work.")
        return None

    try:
        creds_json = json.loads(settings.GOOGLE_CREDENTIALS_JSON)

        scope = [
            "https://www.googleapis.com/auth/spreadsheets",
            "https://www.googleapis.com/auth/drive",
        ]

        creds = Credentials.from_service_account_info(creds_json, scopes=scope)

        agc_manager = gspread_asyncio.AsyncioGspreadClientManager(lambda: creds)
        client = await agc_manager.authorize()
        await client.open_by_key(settings.SPREADSHEET_ID)
        logger.info("Google Sheets client initialized and spreadsheet access verified.")
        return agc_manager
    except json.JSONDecodeError:
        logger.error("Failed to parse GOOGLE_CREDENTIALS_JSON. Make sure it's a valid JSON string.")
    except Exception as e:
        logger.error(f"Unexpected error initializing Google Sheets client: {e}", exc_info=True)
    return None


@retry_gspread_operation
async def append_rows_to_sheet(worksheet: gspread_asyncio.AsyncioGspreadWorksheet, data: List[List[Any]]):
    if not data:
        return
    await worksheet.append_rows(data, value_input_option='USER_ENTERED')
    logger.info(f"Successfully appended {len(data)} rows to sheet '{worksheet.title}'.")


async def process_batch_for_sheet(application: Application, agc_manager, sheet_name: str, items: List[dict]):
    item_ids = [item['id'] for item in items]
    data_to_write = [json.loads(item['data_json']) for item in items]

    try:
        agc = await agc_manager.authorize()
        spreadsheet = await agc.open_by_key(settings.SPREADSHEET_ID)
        worksheet = await spreadsheet.worksheet(sheet_name)
        await append_rows_to_sheet(worksheet, data_to_write)
        await database.mark_sheets_queue_items_processed(item_ids)
    except Exception as e:
        logger.error(f"Failed to write batch to '{sheet_name}': {e}. Incrementing attempts.", exc_info=True)
        await database.increment_sheets_queue_attempts(item_ids)

        failed_items_count = 0
        for item in items:
            if item['attempts'] + 1 >= MAX_WRITE_ATTEMPTS:
                failed_items_count += 1

        if failed_items_count > 0:
            message = (f"🚨 <b>КРИТИЧЕСКАЯ ОШИБКА GOOGLE SHEETS</b> 🚨\n"
                       f"Не удалось записать данные в лист <b>'{html.escape(sheet_name)}'</b> после {MAX_WRITE_ATTEMPTS} попыток.\n"
                       f"<b>Ошибка:</b> <pre>{html.escape(str(e))[:1000]}</pre>\n"
                       f"❗️ <b>{failed_items_count} записей помечены как 'неудачные' и больше не будут обрабатываться.</b> Проверьте БД и логи.")

            if settings.ADMIN_IDS:
                for admin_id in settings.ADMIN_IDS:
                    try:
                        await application.bot.send_message(admin_id, message, parse_mode=ParseMode.HTML)
                    except Exception as notify_err:
                        logger.error(f"Failed to notify admin {admin_id}: {notify_err}")


async def batch_writer_task(application: Application, stop_event: asyncio.Event, agc_manager, bot_data):
    logger.info("Batch writer task started.")

    async def perform_write():
        batch = await database.get_sheets_queue_batch()
        if not batch:
            return

        items_by_sheet = defaultdict(list)
        for item in batch:
            items_by_sheet[item['sheet_name']].append(item)

        for sheet_name, items in items_by_sheet.items():
            await process_batch_for_sheet(application, agc_manager, sheet_name, items)

    while not stop_event.is_set():
        try:
            await asyncio.wait_for(stop_event.wait(), timeout=settings.BATCH_INTERVAL)
        except asyncio.TimeoutError:
            await perform_write()
        except asyncio.CancelledError:
            break

    logger.info("Batch writer task stopping. Performing final write...")
    await perform_write()
    logger.info("Batch writer task finished.")

--- FILE: core/logging_config.py ---
import logging
import sys
from logging.handlers import TimedRotatingFileHandler
from pathlib import Path

LOG_DIR = Path(__file__).parent.parent / "logs"
LOG_DIR.mkdir(exist_ok=True)

LOG_FILE = LOG_DIR / "bot.log"


class InteractionAndErrorFilter(logging.Filter):
    def filter(self, record):
        is_interaction = record.name.startswith('handlers') or record.name == '__main__'
        is_error_level = record.levelno >= logging.WARNING
        return is_interaction or is_error_level


def setup_logging(name: str):
    return logging.getLogger(name)


formatter = logging.Formatter(
    '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
log_filter = InteractionAndErrorFilter()

file_handler = TimedRotatingFileHandler(
    LOG_FILE,
    when='W0',
    interval=1,
    backupCount=1,
    encoding='utf-8',
    delay=False
)
file_handler.setFormatter(formatter)
file_handler.addFilter(log_filter)

stream_handler = logging.StreamHandler(sys.stdout)
stream_handler.setFormatter(formatter)
stream_handler.addFilter(log_filter)

root_logger = logging.getLogger()
root_logger.setLevel(logging.INFO)

if root_logger.hasHandlers():
    root_logger.handlers.clear()

root_logger.addHandler(file_handler)
root_logger.addHandler(stream_handler)

logging.getLogger("httpx").setLevel(logging.WARNING)
logging.getLogger("googleapiclient.discovery_cache").setLevel(logging.ERROR)
logging.getLogger("apscheduler").setLevel(logging.WARNING)
logging.getLogger("aiohttp.access").setLevel(logging.WARNING)

--- FILE: core/monitoring.py ---
import asyncio
import logging
import time
import os
from datetime import datetime

from aiohttp import web
from telegram.ext import Application

from core import settings

logger = logging.getLogger(__name__)


async def handle_http_ping(request: web.Request) -> web.Response:
    try:
        with open(settings.PING_FILE, 'w') as f:
            f.write(str(time.time()))
        logger.info("HTTP PING HANDLED, ping.txt updated.")
        return web.Response(text="OK")
    except Exception as e:
        logger.error(f"HTTP PING: Failed to write ping file: {e}", exc_info=True)
        return web.Response(text="ERROR", status=500)


async def start_http_server(app: web.Application, stop_event: asyncio.Event):
    runner = web.AppRunner(app)
    await runner.setup()
    site = web.TCPSite(runner, '0.0.0.0', 8888)
    try:
        await site.start()
        logger.info("HTTP Health Check Server started at http://0.0.0.0:8888")
        await stop_event.wait()
    except Exception as e:
        logger.error(f"HTTP server failed to start or run: {e}")
    finally:
        logger.info("Stopping HTTP Health Check Server...")
        await runner.cleanup()
        logger.info("HTTP server cleanup complete.")


async def heartbeat_task(application: Application, stop_event: asyncio.Event, bot_data):
    while not stop_event.is_set():
        try:
            now = time.time()
            with open(settings.HEARTBEAT_FILE, "w") as f:
                f.write(str(now))

            await asyncio.wait_for(stop_event.wait(), timeout=settings.HEARTBEAT_INTERVAL_SECONDS)

        except asyncio.TimeoutError:
            continue
        except asyncio.CancelledError:
            break
        except Exception as e:
            logger.error(f"Error in heartbeat task: {e}", exc_info=True)
            await asyncio.sleep(settings.HEARTBEAT_INTERVAL_SECONDS)

    logger.info("Heartbeat task finished.")
    if os.path.exists(settings.HEARTBEAT_FILE):
        try:
            os.remove(settings.HEARTBEAT_FILE)
        except OSError:
            pass

--- FILE: core/database.py ---
import asyncio
import sqlite3
import logging
import json
from typing import List, Tuple, Optional, Dict, Any

from core.settings import DATABASE_FILE

logger = logging.getLogger(__name__)


class DatabaseError(Exception):
    pass


def _execute_query_sync(query: str, params: tuple = (), fetch: Optional[str] = None):
    try:
        with sqlite3.connect(DATABASE_FILE) as conn:
            conn.row_factory = sqlite3.Row
            cursor = conn.cursor()
            cursor.execute("PRAGMA journal_mode=WAL;")
            cursor.execute("PRAGMA foreign_keys = ON;")
            cursor.execute(query, params)
            conn.commit()
            if fetch == "one":
                result = cursor.fetchone()
                return dict(result) if result else None
            if fetch == "all":
                results = cursor.fetchall()
                return [dict(row) for row in results]
            return cursor.lastrowid
    except sqlite3.Error as e:
        logger.error(f"Database error on query '{query}': {e}", exc_info=True)
        raise DatabaseError(f"Database operation failed: {e}")


async def execute_query(query: str, params: tuple = (), fetch: Optional[str] = None):
    try:
        return await asyncio.to_thread(_execute_query_sync, query, params, fetch)
    except DatabaseError:
        return None if fetch else 0


async def init_db():
    query_managers = "CREATE TABLE IF NOT EXISTS managers (user_id INTEGER NOT NULL, restaurant_code TEXT NOT NULL, full_name TEXT, username TEXT, PRIMARY KEY (user_id, restaurant_code));"
    await execute_query(query_managers)
    query_pending_managers = "CREATE TABLE IF NOT EXISTS pending_managers (user_id INTEGER PRIMARY KEY, full_name TEXT NOT NULL, username TEXT, restaurant_code TEXT NOT NULL, restaurant_name TEXT NOT NULL, request_time REAL NOT NULL);"
    await execute_query(query_pending_managers)
    query_pending_feedback = "CREATE TABLE IF NOT EXISTS pending_feedback (feedback_id TEXT PRIMARY KEY, manager_id INTEGER NOT NULL, message_id INTEGER, candidate_id INTEGER NOT NULL, candidate_name TEXT NOT NULL, job_data_json TEXT NOT NULL, created_at REAL NOT NULL);"
    await execute_query(query_pending_feedback)
    query_surveys = "CREATE TABLE IF NOT EXISTS surveys (survey_type TEXT NOT NULL, user_id INTEGER NOT NULL, restaurant_code TEXT, completed_at REAL NOT NULL, PRIMARY KEY (survey_type, user_id));"
    await execute_query(query_surveys)
    query_sheets_queue = "CREATE TABLE IF NOT EXISTS sheets_queue (id INTEGER PRIMARY KEY AUTOINCREMENT, sheet_name TEXT NOT NULL, data_json TEXT NOT NULL, created_at REAL NOT NULL, attempts INTEGER DEFAULT 0, is_processed BOOLEAN DEFAULT 0);"
    await execute_query(query_sheets_queue)
    query_candidate_restaurants = "CREATE TABLE IF NOT EXISTS candidate_restaurants (user_id INTEGER PRIMARY KEY, restaurant_code TEXT NOT NULL);"
    await execute_query(query_candidate_restaurants)
    query_feedback_history = "CREATE TABLE IF NOT EXISTS feedback_history (feedback_id TEXT PRIMARY KEY, manager_id INTEGER NOT NULL, message_id INTEGER, candidate_id INTEGER NOT NULL, candidate_name TEXT NOT NULL, job_data_json TEXT NOT NULL, created_at REAL NOT NULL, decision_at REAL, decision_by_id INTEGER, status TEXT);"
    await execute_query(query_feedback_history)
    query_employees = "CREATE TABLE IF NOT EXISTS employees (user_id INTEGER PRIMARY KEY, full_name TEXT, restaurant_code TEXT, is_active BOOLEAN DEFAULT 1, added_at REAL);"
    await execute_query(query_employees)
    logger.info("Database initialized successfully.")


async def add_employee(user_id: int, full_name: str, restaurant_code: str):
    query = "INSERT OR REPLACE INTO employees (user_id, full_name, restaurant_code, is_active, added_at) VALUES (?, ?, ?, 1, ?)"
    await execute_query(query, (user_id, full_name, restaurant_code, asyncio.get_event_loop().time()))
    logger.info(f"Added/updated employee {user_id} ({full_name}) for restaurant {restaurant_code}.")


async def register_candidate(user_id: int, full_name: str, restaurant_code: str):
    query = "INSERT OR REPLACE INTO employees (user_id, full_name, restaurant_code, is_active, added_at) VALUES (?, ?, ?, 0, ?)"
    await execute_query(query, (user_id, full_name, restaurant_code, asyncio.get_event_loop().time()))
    logger.info(f"Registered candidate {user_id} ({full_name}) for restaurant {restaurant_code} as inactive.")


async def activate_employee(user_id: int):
    query = "UPDATE employees SET is_active = 1 WHERE user_id = ?"
    await execute_query(query, (user_id,))
    logger.info(f"Activated employee {user_id}.")


async def deactivate_employee(user_id: int):
    query = "UPDATE employees SET is_active = 0 WHERE user_id = ?"
    await execute_query(query, (user_id,))
    logger.info(f"Deactivated employee {user_id}.")


async def toggle_employee_status(user_id: int):
    query = "UPDATE employees SET is_active = NOT is_active WHERE user_id = ?"
    await execute_query(query, (user_id,))
    logger.info(f"Toggled active status for employee {user_id}.")


async def get_active_employees() -> List[int]:
    query = "SELECT user_id FROM employees WHERE is_active = 1"
    result = await execute_query(query, fetch="all")
    return [row['user_id'] for row in result] if result else []


async def get_all_employees_with_status() -> List[Dict[str, Any]]:
    query = "SELECT user_id, full_name, restaurant_code, is_active FROM employees ORDER BY is_active DESC, full_name"
    return await execute_query(query, fetch="all") or []


async def count_employees_in_restaurant(restaurant_code: str) -> int:
    query = "SELECT COUNT(user_id) as count FROM employees WHERE restaurant_code = ?"
    result = await execute_query(query, (restaurant_code,), fetch="one")
    return result['count'] if result else 0


async def get_employees_paginated(restaurant_code: str, page: int, limit: int) -> List[Dict[str, Any]]:
    offset = page * limit
    query = "SELECT user_id, full_name, is_active FROM employees WHERE restaurant_code = ? ORDER BY is_active DESC, full_name LIMIT ? OFFSET ?"
    return await execute_query(query, (restaurant_code, limit, offset), fetch="all") or []


async def get_feedback_from_history(feedback_id: str) -> Optional[Dict[str, Any]]:
    query = "SELECT * FROM feedback_history WHERE feedback_id = ?"
    result = await execute_query(query, (feedback_id,), fetch="one")
    if result:
        result['job_data'] = json.loads(result['job_data_json'])
        return result
    return None


async def move_pending_feedback_to_history(candidate_id: int, decision_by_id: int, status: str):
    first_task_details_query = "SELECT * FROM pending_feedback WHERE candidate_id = ? LIMIT 1"
    task_details = await execute_query(first_task_details_query, (candidate_id,), fetch="one")
    if not task_details:
        await remove_all_pending_feedback_for_candidate(candidate_id)
        return

    insert_query = "INSERT OR IGNORE INTO feedback_history (feedback_id, manager_id, message_id, candidate_id, candidate_name, job_data_json, created_at, decision_at, decision_by_id, status) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)"
    decision_time = asyncio.get_event_loop().time()
    await execute_query(insert_query, (
        task_details['feedback_id'], task_details['manager_id'], task_details['message_id'],
        task_details['candidate_id'], task_details['candidate_name'], task_details['job_data_json'],
        task_details['created_at'], decision_time, decision_by_id, status
    ))
    logger.info(f"Moved feedback for candidate {candidate_id} to history with status '{status}'.")
    await remove_all_pending_feedback_for_candidate(candidate_id)


async def add_to_sheets_db_queue(sheet_name: str, data: list):
    query = "INSERT INTO sheets_queue (sheet_name, data_json, created_at) VALUES (?, ?, ?)"
    data_json = json.dumps(data, ensure_ascii=False)
    created_at = asyncio.get_event_loop().time()
    await execute_query(query, (sheet_name, data_json, created_at))


async def get_sheets_queue_batch(limit: int = 50) -> List[Dict[str, Any]]:
    query = "SELECT id, sheet_name, data_json, attempts FROM sheets_queue WHERE is_processed = 0 ORDER BY created_at LIMIT ?"
    result = await execute_query(query, (limit,), fetch="all")
    return result if result else []


async def mark_sheets_queue_items_processed(item_ids: List[int]):
    if not item_ids: return
    query = f"UPDATE sheets_queue SET is_processed = 1 WHERE id IN ({','.join(['?'] * len(item_ids))})"
    await execute_query(query, tuple(item_ids))


async def increment_sheets_queue_attempts(item_ids: List[int]):
    if not item_ids: return
    query = f"UPDATE sheets_queue SET attempts = attempts + 1 WHERE id IN ({','.join(['?'] * len(item_ids))})"
    await execute_query(query, tuple(item_ids))


async def add_manager(user_id: int, restaurant_code: str, full_name: str, username: Optional[str]):
    query = "INSERT OR REPLACE INTO managers (user_id, restaurant_code, full_name, username) VALUES (?, ?, ?, ?)"
    await execute_query(query, (user_id, restaurant_code, full_name, username))
    logger.info(f"Added/updated manager {user_id} ({full_name}) for restaurant {restaurant_code}.")


async def get_manager_details(user_id: int) -> Optional[Dict[str, Any]]:
    query = "SELECT user_id, full_name, username FROM managers WHERE user_id = ? LIMIT 1"
    return await execute_query(query, (user_id,), fetch="one")


async def remove_manager_from_all_restaurants(user_id: int):
    query = "DELETE FROM managers WHERE user_id = ?"
    await execute_query(query, (user_id,))
    logger.info(f"Removed manager {user_id} from all restaurants.")


async def get_managers_for_restaurant(restaurant_code: str) -> List[int]:
    query = "SELECT user_id FROM managers WHERE restaurant_code = ?"
    result = await execute_query(query, (restaurant_code,), fetch="all")
    return [row['user_id'] for row in result] if result else []


async def get_all_managers_by_restaurant() -> dict[str, list[dict]]:
    query = "SELECT restaurant_code, user_id, full_name, username FROM managers ORDER BY restaurant_code, full_name"
    result = await execute_query(query, fetch="all")
    managers_map = {}
    if result:
        for row in result:
            res_code = row['restaurant_code']
            if res_code not in managers_map:
                managers_map[res_code] = []
            managers_map[res_code].append(
                {'user_id': row['user_id'], 'full_name': row['full_name'], 'username': row['username']}
            )
    return managers_map


async def is_manager_in_restaurant(user_id: int, restaurant_code: str) -> bool:
    query = "SELECT 1 FROM managers WHERE user_id = ? AND restaurant_code = ?"
    result = await execute_query(query, (user_id, restaurant_code), fetch="one")
    return result is not None


async def is_user_a_manager(user_id: int) -> bool:
    query = "SELECT 1 FROM managers WHERE user_id = ? LIMIT 1"
    result = await execute_query(query, (user_id,), fetch="one")
    return result is not None


async def add_pending_manager(user_id: int, restaurant_code: str, restaurant_name: str, full_name: str, username: Optional[str],
                              request_time: float):
    query = "INSERT OR REPLACE INTO pending_managers (user_id, restaurant_code, restaurant_name, full_name, username, request_time) VALUES (?, ?, ?, ?, ?, ?)"
    await execute_query(query, (user_id, restaurant_code, restaurant_name, full_name, username, request_time))
    logger.info(f"Added pending manager request for user {user_id}.")


async def get_pending_manager(user_id: int) -> Optional[dict]:
    query = "SELECT restaurant_code, restaurant_name, full_name, username FROM pending_managers WHERE user_id = ?"
    result = await execute_query(query, (user_id,), fetch="one")
    return result


async def remove_pending_manager(user_id: int):
    query = "DELETE FROM pending_managers WHERE user_id = ?"
    await execute_query(query, (user_id,))
    logger.info(f"Removed pending manager request for user {user_id}.")


async def add_pending_feedback(feedback_id: str, manager_id: int, message_id: int, candidate_id: int,
                               candidate_name: str,
                               job_data: dict, created_at: float):
    query = "INSERT INTO pending_feedback (feedback_id, manager_id, message_id, candidate_id, candidate_name, job_data_json, created_at) VALUES (?, ?, ?, ?, ?, ?, ?)"
    job_data_json = json.dumps(job_data, ensure_ascii=False)
    await execute_query(query,
                        (feedback_id, manager_id, message_id, candidate_id, candidate_name, job_data_json, created_at))
    logger.info(f"Added pending feedback task {feedback_id} for manager {manager_id} about candidate {candidate_id}.")


async def get_pending_feedback_for_manager(manager_id: int) -> List[Dict[str, Any]]:
    query = "SELECT feedback_id, candidate_name FROM pending_feedback WHERE manager_id = ?"
    result = await execute_query(query, (manager_id,), fetch="all")
    return [{"id": row['feedback_id'], "name": row['candidate_name']} for row in result] if result else []


async def get_all_pending_feedback() -> List[Dict[str, Any]]:
    query = "SELECT feedback_id, candidate_id, candidate_name, job_data_json FROM pending_feedback ORDER BY created_at"
    results = await execute_query(query, fetch="all")
    if not results: return []
    tasks, processed_candidates = [], set()
    for row in results:
        candidate_id = row['candidate_id']
        if candidate_id in processed_candidates: continue
        job_data = json.loads(row['job_data_json'])
        tasks.append({
            "id": row['feedback_id'],
            "candidate_id": candidate_id,
            "name": row['candidate_name'],
            "restaurant_name": job_data.get('interview_restaurant_name', 'Неизвестно')
        })
        processed_candidates.add(candidate_id)
    return tasks


async def get_pending_feedback_by_id(feedback_id: str) -> Optional[Dict[str, Any]]:
    query = "SELECT * FROM pending_feedback WHERE feedback_id = ?"
    result = await execute_query(query, (feedback_id,), fetch="one")
    if result:
        result['job_data'] = json.loads(result['job_data_json'])
        return result
    return None


async def get_candidate_id_from_feedback_id(feedback_id: str) -> Optional[int]:
    query = "SELECT candidate_id FROM pending_feedback WHERE feedback_id = ? LIMIT 1"
    result = await execute_query(query, (feedback_id,), fetch="one")
    return result['candidate_id'] if result else None


async def get_all_pending_feedback_for_candidate(candidate_id: int) -> List[Dict[str, Any]]:
    query = "SELECT * FROM pending_feedback WHERE candidate_id = ?"
    return await execute_query(query, (candidate_id,), fetch="all") or []


async def remove_all_pending_feedback_for_candidate(candidate_id: int):
    query = "DELETE FROM pending_feedback WHERE candidate_id = ?"
    await execute_query(query, (candidate_id,))
    logger.info(f"Removed all pending feedback tasks for candidate {candidate_id}.")


async def get_survey_counts_by_restaurant() -> Dict[str, Dict[str, int]]:
    query = "SELECT restaurant_code, survey_type, COUNT(*) as count FROM surveys GROUP BY restaurant_code, survey_type"
    results = await execute_query(query, fetch="all")
    stats = {}
    if not results: return stats
    for row in results:
        res_code, survey_type, count = row['restaurant_code'] or 'N/A', row['survey_type'], row['count']
        if res_code not in stats: stats[res_code] = {}
        stats[res_code][survey_type] = count
    return stats


async def log_survey_completion(survey_type: str, user_id: int, restaurant_code: Optional[str] = None):
    query = "INSERT OR REPLACE INTO surveys (survey_type, user_id, restaurant_code, completed_at) VALUES (?, ?, ?, ?)"
    await execute_query(query, (survey_type, user_id, restaurant_code, asyncio.get_event_loop().time()))


async def is_survey_completed(survey_type: str, user_id: int) -> bool:
    query = "SELECT 1 FROM surveys WHERE survey_type = ? AND user_id = ?"
    result = await execute_query(query, (survey_type, user_id), fetch="one")
    return result is not None


async def log_candidate_restaurant(user_id: int, restaurant_code: str):
    query = "INSERT OR REPLACE INTO candidate_restaurants (user_id, restaurant_code) VALUES (?, ?)"
    await execute_query(query, (user_id, restaurant_code))


async def get_candidate_restaurant(user_id: int) -> Optional[str]:
    query = "SELECT restaurant_code FROM candidate_restaurants WHERE user_id = ?"
    result = await execute_query(query, (user_id,), fetch="one")
    return result['restaurant_code'] if result else None


async def delete_user_data(user_id: int):
    logger.warning(f"Deleting all data for user_id: {user_id}")
    tables_with_user_id = ["managers", "pending_managers", "surveys", "candidate_restaurants", "employees"]
    for table in tables_with_user_id:
        await execute_query(f"DELETE FROM {table} WHERE user_id = ?", (user_id,))
    await execute_query("DELETE FROM pending_feedback WHERE candidate_id = ?", (user_id,))
    await execute_query("DELETE FROM pending_feedback WHERE manager_id = ?", (user_id,))
    await execute_query("UPDATE feedback_history SET decision_by_id = NULL WHERE decision_by_id = ?", (user_id,))
    logger.info(f"Successfully deleted data for user_id: {user_id}")


async def remove_manager(user_id: int, restaurant_code: str):
    query = "DELETE FROM managers WHERE user_id = ? AND restaurant_code = ?"
    await execute_query(query, (user_id, restaurant_code))
    logger.info(f"Removed manager {user_id} from restaurant {restaurant_code}.")

--- FILE: core/stickers.py ---
import random

# --- Приветствия ---
GREETING_HOSTESS = "CAACAgIAAxkBAAIHj2iAChs6ubi63zrSCHd1wehShbDJAAJ2gwACLfIAAUgAAVT4KBDVr2Y2BA"
GREETING_TEAM = "CAACAgIAAxkBAAIHlWiACr5xbMv9tNQ49KymsksqOYYLAAIUgQACfZwAAUgcJKOgFuH9lTYE"
GREETING_CHEF = "CAACAgIAAxkBAAIHmWiAC1efwOzU8PXv1cpGP2IZ01BEAAN7AALN5wFI533VDdT1mHo2BA"
GREETING_WAITER = "CAACAgIAAxkBAAIHnGiAC3iUpaLbf_-H5J9czOn6997CAAKfggACV28AAUiiD8EOkiO0cTYE"

# --- Эмоции и действия ---
QUESTION_DOG = "CAACAgIAAxkBAAIHn2iAC5maCrWA69Cgrzfmcl4ZOeHPAAISgQACM0cAAUgQ_dl65aVWljYE"
FEEDBACK_SENT_DOG = "CAACAgIAAxkBAAIHomiAC85YGIm1_BbEF1NKi5gB3xSnAAKKgAAC3T8AAUjlRNKUgmsdrTYE"
ONBOARDING_INFO_DOG = "CAACAgIAAxkBAAIHpWiAC_VJG1TFQPhfztpeA5eXZflGAAIqjwAC8jABSBuofKT7h7gINgQ"
CONTACT_MANAGER = "CAACAgIAAxkBAAIHqGiADDZiFgfl-2wPnPD6XrYMB3RRAAKyhAAC5XABSOmbTsnxVW-RNgQ"
SUCCESS_DOG = "CAACAgIAAxkBAAIHq2iADFnw9MexQP_XPAMAAQzkjsZBAQACQYcAAmj5AUj2xzFdQF12uTYE"


# Список для случайного выбора приветственного стикера
GREETING_STICKERS = [GREETING_HOSTESS, GREETING_TEAM, GREETING_CHEF, GREETING_WAITER]

def get_random_greeting():
    """Возвращает ID случайного приветственного стикера."""
    return random.choice(GREETING_STICKERS)

--- FILE: core/settings.py ---
import os
from pathlib import Path
from dotenv import load_dotenv

BASE_DIR = Path(__file__).parent.parent.resolve()
load_dotenv(BASE_DIR / ".env")

TOKEN = os.getenv("BOT_TOKEN")
GOOGLE_CREDENTIALS_JSON = os.getenv("GOOGLE_CREDENTIALS_JSON")
SPREADSHEET_ID = os.getenv("SPREADSHEET_ID")
MOSCOW_TIMEZONE = "Europe/Moscow"

raw_admin_ids = os.getenv("ADMIN_CHAT_ID", "")
try:
    ADMIN_IDS = {int(admin_id.strip()) for admin_id in raw_admin_ids.split(',') if admin_id.strip().isdigit()}
except (ValueError, TypeError):
    ADMIN_IDS = set()

EMPLOYEES_PER_PAGE = 15

ONBOARDING_SHEET_NAME = "Ознакомительная смена"
EXIT_INTERVIEW_SHEET_NAME = "exit interview"
CLIMATE_SURVEY_SHEET_NAME = "Замер климата"
INTERVIEW_SHEET_NAME = os.getenv("INTERVIEW_SHEET_NAME", "Первичный контакт")
MANAGER_FEEDBACK_SHEET_NAME = "ОС от менеджера"
CANDIDATE_FEEDBACK_SHEET_NAME = "ОС от кандидата"
LEAVING_REASON_SHEET_NAME = "Причины ухода (авто)"
BOT_FEEDBACK_SHEET_NAME = "ОС по боту"
CANDIDATE_NOSHOW_SHEET_NAME = "Кандидаты (передумали)"


BATCH_INTERVAL = 30

EXIT_INTERVIEW_COOLDOWN_SECONDS = 60 * 60 * 24 * 7
FEEDBACK_DELAY_SECONDS = 1800
ONBOARDING_FOLLOWUP_SECONDS = 60 * 60 * 24 * 7

PID_FILE = BASE_DIR / "bot.pid"
HEARTBEAT_FILE = BASE_DIR / "heartbeat.txt"
PING_FILE = BASE_DIR / "ping.txt"
PERSISTENCE_FILE = BASE_DIR / "bot_persistence.pkl"
DATABASE_FILE = BASE_DIR / "bot_database.sqlite"

HEARTBEAT_INTERVAL_SECONDS = 30
TELEGRAM_INACTIVITY_THRESHOLD_SECONDS = 60 * 10
CONVERSATION_TIMEOUT_SECONDS = 60 * 60 * 3

ACTIVE_MESSAGE_ID_KEY = "active_message_id"

CALLBACK_START_ONBOARDING = "start_onboarding"
CALLBACK_START_EXIT = "start_exit_interview"
CALLBACK_START_CLIMATE = "start_climate_survey"
CALLBACK_CONFIRM_QUIT = "confirm_quit"
CALLBACK_DECLINE_QUIT = "decline_quit"

CALLBACK_ADMIN_LIST = "admin_list_managers"
CALLBACK_ADMIN_ADD_START = "admin_add_manager_start"
CALLBACK_ADMIN_REMOVE_START = "admin_remove_manager_start"
CALLBACK_ADMIN_BACK = "admin_back_to_menu"
CALLBACK_ADMIN_EXIT = "admin_exit_panel"
CALLBACK_ADMIN_BROADCAST_CLIMATE_START = "admin_broadcast_climate_start"
CALLBACK_ADMIN_BROADCAST_CONFIRM = "admin_broadcast_confirm"
CALLBACK_ADMIN_BROADCAST_CANCEL = "admin_broadcast_cancel"
CALLBACK_ADMIN_STATS = "admin_stats"

CALLBACK_MGR_APPROVE_PREFIX = "mgr_approve_"
CALLBACK_MGR_REJECT_PREFIX = "mgr_reject_"

CALLBACK_MGR_FEEDBACK_PREFIX = "mgr_feedback_status_"
CALLBACK_START_CANDIDATE_FEEDBACK = "start_candidate_feedback"

CALLBACK_ONBOARDING_FOLLOWUP_YES = "onboarding_followup_yes"
CALLBACK_ONBOARDING_FOLLOWUP_NO = "onboarding_followup_no"

CALLBACK_GO_TO_MAIN_MENU = "go_to_main_menu"

--- FILE: utils/keyboards.py ---
import locale
from datetime import date, timedelta
from typing import List, Tuple, Dict, Any
from telegram import InlineKeyboardButton, InlineKeyboardMarkup
from utils.helpers import build_inline_keyboard, get_now
from core import settings

try:
    locale.setlocale(locale.LC_TIME, 'ru_RU.UTF-8')
except locale.Error:
    try:
        locale.setlocale(locale.LC_TIME, 'russian')
    except locale.Error:
        print("Warning: Could not set Russian locale. Dates might be in English.")

InlineButtonOption = Tuple[str, str]

RESTAURANT_OPTIONS: List[InlineButtonOption] = [
    ("Восстания, 15", "res_V15"), ("Одоевского, 34", "res_O34"), ("Типанова, 27/39", "res_T27"),
    ("Московский, 205", "res_M205"), ("Ленинский, 120", "res_L120"), ("Невский, 21", "res_N21"),
    ("Рубинштейна, 1/43", "res_R1"), ("Грибоедова 18-20", "res_G18"), ("Науки, 14А", "res_N14"),
    ("Энгельса, 124", "res_E124"), ("МСК, Камергерский", "res_MSK"), ("Мурино", "res_MUR")
]

ONBOARDING_POSITION_OPTIONS: List[InlineButtonOption] = [
    ("Хостес", "onboard_pos_Hostess"), ("Официант", "onboard_pos_Waiter"),
    ("Бармен", "onboard_pos_Bartender"), ("Другое", "onboard_pos_Other")
]

EXIT_POSITION_OPTIONS: List[InlineButtonOption] = [
    ("Официант", "exit_pos_Waiter"), ("Бармен", "exit_pos_Bartender"), ("Повар", "exit_pos_Cook"),
    ("Хостес", "exit_pos_Hostess"), ("Менеджер", "exit_pos_Manager"), ("Бригадир", "exit_pos_Brigadier"),
    ("Кассир", "exit_pos_Cashier"), ("Мойка/Уборка", "exit_pos_Cleaner"), ("Курьер", "exit_pos_Courier"),
    ("Менеджер доставки", "exit_pos_DeliveryManager")
]

RECRUITMENT_POSITION_OPTIONS: List[InlineButtonOption] = [
    ("Официант", "vac_Waiter"), ("Бармен", "vac_Bartender"), ("Повар", "vac_Cook"),
    ("Хостес", "vac_Hostess"), ("Менеджер", "vac_Manager"), ("Бригадир", "vac_Brigadier"),
    ("Кассир", "vac_Cashier"), ("Мойка/Уборка", "vac_Cleaner"), ("Курьер", "vac_Courier"),
    ("Менеджер доставки", "vac_DeliveryManager"), ("Другое", "vac_Other")
]

DURATION_OPTIONS: List[InlineButtonOption] = [
    ("< 1 мес", "dur_1m"), ("1-6 мес", "dur_6m"), ("6-12 мес", "dur_1y"),
    ("1-2 года", "dur_2y"), ("> 2 лет", "dur_2y+")
]

RATING_OPTIONS: List[InlineButtonOption] = [
    ("1 (Очень плохо)", "rate_1"), ("2 (Плохо)", "rate_2"), ("3 (Нормально)", "rate_3"),
    ("4 (Хорошо)", "rate_4"), ("5 (Отлично!)", "rate_5")
]

TRAINING_OPTIONS: List[InlineButtonOption] = [
    ("Да, полностью", "train_Full"), ("В основном да", "train_Mostly"),
    ("Частично", "train_Partly"), ("Нет, недостаточно", "train_No")
]

FEEDBACK_OPTIONS: List[InlineButtonOption] = [
    ("Регулярно", "feed_Regular"), ("Иногда", "feed_Sometimes"),
    ("Редко", "feed_Rarely"), ("Никогда", "feed_Never")
]

GENDER_OPTIONS: List[InlineButtonOption] = [("Мужчина 👨", "climate_gender_male"),
                                            ("Женщина 👩", "climate_gender_female")]

YES_NO_OPTIONS: List[InlineButtonOption] = [("Да", "yes"), ("Нет", "no")]
YES_NO_OPTIONS_CLIMATE: List[InlineButtonOption] = [("Да 👍", "climate_yes"), ("Нет 👎", "climate_no")]

YES_NO_MAYBE_OPTIONS: List[InlineButtonOption] = [
    ("✅ Да", "climate_q_yes"), ("☑️ Скорее да", "climate_q_mostly_yes"),
    ("❌ Скорее нет", "climate_q_mostly_no"), ("🚫 Нет", "climate_q_no")
]

CHILDREN_OPTIONS: List[InlineButtonOption] = [
    ("Нет", "child_0"), ("1", "child_1"), ("2", "child_2"), ("Больше 2", "child_many")
]

HEALTH_OPTIONS: List[InlineButtonOption] = [
    ("Отличное", "health_excellent"), ("Хорошее", "health_good"),
    ("Нормальное", "health_normal"), ("Плохое", "health_bad")
]

EXPERIENCE_OPTIONS: List[InlineButtonOption] = [
    ("Нет опыта", "exp_0"), ("До 3 мес.", "exp_3m"), ("3-6 мес.", "exp_6m"),
    ("6-12 мес.", "exp_1y"), ("1-3 года", "exp_3y"), ("Более 3 лет", "exp_many")
]

INCOME_OPTIONS: List[InlineButtonOption] = [
    ("до 60 000 ₽", "inc_60"), ("до 80 000 ₽", "inc_80"), ("до 100 000 ₽", "inc_100"),
    ("до 120 000 ₽", "inc_120"), ("Выше 120 000 ₽", "inc_more")
]

JOBS_COUNT_OPTIONS: List[InlineButtonOption] = [
    ("1", "jobs_1"), ("2", "jobs_2"), ("3", "jobs_3"), ("4", "jobs_4"), ("Более 4", "jobs_many")
]

COURSE_OPTIONS: List[InlineButtonOption] = [
    ("1", "course_1"), ("2", "course_2"), ("3", "course_3"), ("4", "course_4"),
    ("5", "course_5"), ("6", "course_6"), ("Не учусь", "course_none")
]

MARITAL_STATUS_OPTIONS: List[InlineButtonOption] = [
    ("💍 Женат/Замужем", "m_married"), ("❤️ В отношениях", "m_relation"),
    ("🚶 Свободен(на)", "m_single"), ("💔 Разведен(а)", "m_divorced")
]

ATTITUDE_TO_APPEARANCE_OPTIONS: List[InlineButtonOption] = [
    ("😍 Считаю себя красивым(ой)", "app_nice"), ("🙂 У меня обычная внешность", "app_normal"),
    ("😕 Считаю себя непривлекательным(ой)", "app_not_nice")
]

EDUCATION_FORM_OPTIONS: List[InlineButtonOption] = [
    ("☀️ Очная", "form_full"), ("🌙 Вечерняя", "form_evening"),
    ("✉️ Заочная", "form_part"), ("💻 Дистанционная", "form_remote")
]

VACANCY_SOURCE_OPTIONS: List[InlineButtonOption] = [
    ("🌐 HeadHunter", "src_hh"), ("✈️ Telegram", "src_tg"),
    ("🗣️ Посоветовали", "src_ref"), ("📝 Авито", "src_avito"),
    ("🚶 С улицы", "src_walk"), ("❓ Другое", "src_other")
]

MANAGER_FEEDBACK_OPTIONS: List[InlineButtonOption] = [
    ("✅ Ознакомительная смена", f"{settings.CALLBACK_MGR_FEEDBACK_PREFIX}onboarding"),
    ("🤔 Подумает", f"{settings.CALLBACK_MGR_FEEDBACK_PREFIX}thinking"),
    ("❌ Отказался", f"{settings.CALLBACK_MGR_FEEDBACK_PREFIX}refused"),
    ("⛔️ Не подходит", f"{settings.CALLBACK_MGR_FEEDBACK_PREFIX}unsuitable"),
]

CANDIDATE_FEEDBACK_RATING_OPTIONS: List[InlineButtonOption] = [
    ("😞 1", "cand_rate_1"), ("😕 2", "cand_rate_2"), ("😐 3", "cand_rate_3"),
    ("🙂 4", "cand_rate_4"), ("😀 5", "cand_rate_5"),
]

INTEREST_RATING_OPTIONS: List[InlineButtonOption] = [
    (str(i), f"onboard_rate_{i}") for i in range(1, 11)
]

POSITION_LINKS: Dict[str, List[Dict[str, str]]] = {
    "Официант": [
        {"name": "Подпишись на канал, чтобы быть в курсе событий", "url": "https://t.me/+1c-IyuONGdk0NDEy", "is_critical": True},
        {"name": "Меню и словарь ингредиентов", "url": "https://docs.google.com/spreadsheets/d/1wb5RszKAdkb9zRgvVijHYrve6K63x5KljCZO_9MokHw/edit?gid=176953636", "is_critical": True},
        {"name": "Стандарты сервиса и работы официанта (для аттестации)", "url": "https://docs.google.com/spreadsheets/d/12jxORpWm9zfcA8AN84uGwV1XNJZRQPwX0TcffgabdNs/edit?usp=sharing", "is_critical": True},
        {"name": "Методичка, которая поможет тебе на адаптации", "url": "https://drive.google.com/drive/folders/1dA8QOrcng94GBigEjtkmw6celBsXq-cM?usp=share_link", "is_critical": False},
        {"name": "Дополнительные файлы, которые помогут освоиться", "url": "https://drive.google.com/drive/folders/1gcf7Io0hcVdwJuH-KkKXH_5OaUZBrGMD?usp=share_link", "is_critical": False},
        {"additional_message": "Напиши сегодня пожелания по графику своему менеджеру!"},
    ],
    "Хостес": [
        {"name": "Подпишись на канал, чтобы быть в курсе событий", "url": "https://t.me/+1c-IyuONGdk0NDEy", "is_critical": True},
        {"name": "Стандарты работы хостес (для аттестации)", "url": "https://docs.google.com/spreadsheets/d/11tJyxLR9uYTUXpfvqQ9Nvbnj6TQ7m9mk-_EkN2itt7g/edit", "is_critical": True},
        {"name": "Дополнительные файлы, которые помогут освоиться", "url": "https://drive.google.com/drive/folders/15QU-fC3fOezWsKNbRRKlWvooNYm-7P1O?usp=share_link", "is_critical": False},
        {"additional_message": "Напиши сегодня пожелания по графику своему менеджеру!"},
    ],
    "Бармен": [
        {"name": "Подпишись на канал, чтобы быть в курсе событий", "url": "https://t.me/+1c-IyuONGdk0NDEy", "is_critical": True},
        {"additional_message": "Напиши сегодня пожелания по графику старшему бармену!"},
    ],
    "Другое": [
        {"name": "Подпишись на канал, чтобы быть в курсе событий", "url": "https://t.me/+1c-IyuONGdk0NDEy", "is_critical": True},
        {"additional_message": "Желаем тебе успешного старта и увлекательной адаптации!"},
    ]
}


def get_admin_menu_keyboard() -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup([
        [InlineKeyboardButton("📋 Список менеджеров", callback_data="admin_list_managers")],
        [InlineKeyboardButton("➕ Добавить/➖ Удалить менеджера", callback_data="admin_manage_managers")],
        [InlineKeyboardButton("👥 Управление сотрудниками", callback_data="admin_manage_employees")],
        [InlineKeyboardButton("🤔 Кандидаты на рассмотрении", callback_data="admin_pending_candidates")],
        [InlineKeyboardButton("📊 Запустить замер климата",
                              callback_data="admin_broadcast_climate_start")],
        [InlineKeyboardButton("📈 Статистика опросов", callback_data="admin_stats")],
        [InlineKeyboardButton("💬 Обратная связь по боту", callback_data="submit_bot_feedback")]
    ])


def get_back_to_admin_menu_keyboard() -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup([[InlineKeyboardButton("⬅️ Назад в меню", callback_data=settings.CALLBACK_ADMIN_BACK)]])


def get_manager_menu_keyboard(pending_feedback_count: int = 0) -> InlineKeyboardMarkup:
    feedback_button_text = "📝 Оставить ОС по кандидатам"
    if pending_feedback_count > 0:
        feedback_button_text += f" ({pending_feedback_count} ❗️)"

    buttons = [
        [InlineKeyboardButton(feedback_button_text, callback_data="manager_feedback")],
        [InlineKeyboardButton("💬 Обратная связь по боту", callback_data="submit_bot_feedback")]
    ]
    return InlineKeyboardMarkup(buttons)


def get_pending_feedback_keyboard(pending_tasks: List[Dict[str, Any]]) -> InlineKeyboardMarkup:
    buttons = []
    for task in pending_tasks:
        buttons.append([InlineKeyboardButton(f"👤 {task['name']}", callback_data=f"fb_{task['id']}")])
    buttons.append([InlineKeyboardButton("⬅️ Назад в главное меню", callback_data="main_menu")])
    return InlineKeyboardMarkup(buttons)


def get_shift_date_keyboard() -> InlineKeyboardMarkup:
    buttons = []
    today = get_now().date()
    for i in range(6):
        target_date = today + timedelta(days=i)
        day_name = target_date.strftime("%a").capitalize()
        date_str = target_date.strftime("%d %b")
        text = f"{day_name}, {date_str}"
        callback_data = f"shift_date_{target_date.isoformat()}"
        buttons.append(InlineKeyboardButton(text, callback_data=callback_data))

    keyboard_layout = [buttons[i:i + 2] for i in range(0, len(buttons), 2)]
    keyboard_layout.append([
        InlineKeyboardButton("Другая дата (ввести вручную)", callback_data="shift_date_other")
    ])

    return InlineKeyboardMarkup(keyboard_layout)

--- FILE: utils/helpers.py ---
import asyncio
import html
import logging
from typing import Optional, Tuple, List, Any
from datetime import datetime
from zoneinfo import ZoneInfo, ZoneInfoNotFoundError

from telegram import (
    Update,
    InlineKeyboardMarkup,
    CallbackQuery,
    MessageOriginUser,
    MessageOriginHiddenUser,
    MessageOriginChannel,
    InlineKeyboardButton,
    Message,
    Bot,
    BotCommand,
    BotCommandScopeChat,
)
from telegram.constants import ParseMode
from telegram.error import BadRequest, Forbidden, TelegramError
from telegram.ext import ContextTypes

from core import settings, database

logger = logging.getLogger(__name__)

try:
    TIMEZONE = ZoneInfo(settings.MOSCOW_TIMEZONE)
except ZoneInfoNotFoundError:
    logger.warning(f"Timezone '{settings.MOSCOW_TIMEZONE}' not found. Falling back to UTC.")
    TIMEZONE = ZoneInfo("UTC")


def get_now() -> datetime:
    return datetime.now(TIMEZONE)


def build_inline_keyboard(buttons: List[Tuple[str, str]], columns: int) -> InlineKeyboardMarkup:
    layout = [buttons[i:i + columns] for i in range(0, len(buttons), columns)]
    keyboard = [[InlineKeyboardButton(text, callback_data=data) for text, data in row] for row in layout]
    return InlineKeyboardMarkup(keyboard)


def get_user_data_from_update(update: Optional[Update]) -> Tuple[int, str, Optional[str]]:
    user = None
    chat_id = 0

    if update:
        if update.effective_user:
            user = update.effective_user
        elif hasattr(update, 'callback_query') and update.callback_query and update.callback_query.from_user:
            user = update.callback_query.from_user
        elif hasattr(update, 'my_chat_member') and update.my_chat_member and update.my_chat_member.from_user:
            user = update.my_chat_member.from_user
        elif hasattr(update, 'chat_member') and update.chat_member and update.chat_member.new_chat_member:
             user = update.chat_member.new_chat_member.user

    if user:
        user_id = user.id
        first_name = user.first_name
        full_name = f"{html.escape(first_name or '')} {html.escape(user.last_name or '')}".strip()
        user_display_name = f"@{user.username}" if user.username else full_name or f"User_{user_id}"
        return user_id, user_display_name, first_name

    if update and update.effective_chat:
        user_id = update.effective_chat.id
        return user_id, f"Chat_{user_id}", None

    logger.warning("Could not determine user or chat ID from update.")
    return 0, "Unknown User", None


async def set_user_commands(user_id: int, bot: Bot):
    if user_id == 0:
        return
    commands = []
    if user_id in settings.ADMIN_IDS:
        commands = [BotCommand("start", "⭐ Панель Администратора")]
    elif await database.is_user_a_manager(user_id):
        commands = [BotCommand("start", "🏠 Главное меню менеджера")]

    try:
        current_commands = await bot.get_my_commands(scope=BotCommandScopeChat(chat_id=user_id))
        if [c.to_dict() for c in commands] != [c.to_dict() for c in current_commands]:
            await bot.set_my_commands(commands=commands, scope=BotCommandScopeChat(chat_id=user_id))
            logger.info(f"Updated commands for user {user_id}.")
    except (BadRequest, Forbidden) as e:
        logger.warning(f"Could not set commands for user {user_id}: {e}")


async def add_user_to_interacted(user_id: int, context: ContextTypes.DEFAULT_TYPE):
    if user_id == 0: return
    interacted_set = context.bot_data.setdefault("users_interacted", set())
    if user_id not in interacted_set:
        interacted_set.add(user_id)
        logger.info(f"Added user {user_id} to interacted set. Current size: {len(interacted_set)}")
        if context.application.persistence:
            try:
                await context.application.persistence.flush()
            except Exception as e:
                logger.error(f"Error flushing persistence after adding user: {e}")


async def safe_answer_callback_query(query: Optional[CallbackQuery]):
    if not query: return
    try:
        await query.answer()
    except BadRequest:
        pass
    except Forbidden:
        logger.warning(f"Forbidden to answer callback query {query.id}. Bot might be blocked.")
    except Exception as e:
        logger.error(f"Unexpected error answering callback query {query.id}: {e}", exc_info=True)


async def send_transient_message(context: ContextTypes.DEFAULT_TYPE, chat_id: int, text: str):
    try:
        message = await context.bot.send_message(chat_id=chat_id, text=text)
        transient_msgs = context.user_data.setdefault('transient_messages', [])
        transient_msgs.append(message.message_id)
    except (Forbidden, BadRequest) as e:
        logger.warning(f"Could not send transient message to {chat_id}: {e}")


async def cleanup_transient_messages(context: ContextTypes.DEFAULT_TYPE, chat_id: int):
    transient_msgs = context.user_data.pop('transient_messages', [])
    for msg_id in transient_msgs:
        try:
            await context.bot.delete_message(chat_id=chat_id, message_id=msg_id)
        except (BadRequest, Forbidden) as e:
            if "message to delete not found" not in str(e).lower():
                logger.warning(f"Could not delete transient message {msg_id} in chat {chat_id}: {e}")


async def send_or_edit_message(
    update: Update,
    context: ContextTypes.DEFAULT_TYPE,
    text: str,
    reply_markup: Optional[InlineKeyboardMarkup] = None,
    delete_user_message: bool = True
):
    chat_id = update.effective_chat.id
    active_message_id = context.user_data.get(settings.ACTIVE_MESSAGE_ID_KEY)

    await cleanup_transient_messages(context, chat_id)

    new_message = None
    try:
        if active_message_id:
            new_message = await context.bot.edit_message_text(
                chat_id=chat_id,
                message_id=active_message_id,
                text=text,
                reply_markup=reply_markup,
                parse_mode=ParseMode.HTML
            )
        else:
            new_message = await context.bot.send_message(
                chat_id, text, reply_markup=reply_markup, parse_mode=ParseMode.HTML
            )
    except BadRequest as e:
        if "Message is not modified" not in str(e):
            logger.warning(f"Could not edit message {active_message_id}, sending new one. Error: {e}")
            try:
                new_message = await context.bot.send_message(
                    chat_id, text, reply_markup=reply_markup, parse_mode=ParseMode.HTML
                )
            except (Forbidden, TelegramError) as send_e:
                 logger.error(f"Failed to send new message to chat {chat_id} after edit failed: {send_e}")
                 return
        else:
            pass
    except (Forbidden, TelegramError) as e:
        logger.error(f"Telegram API error for chat {chat_id}: {e}")
        return

    if update.message and delete_user_message:
        try:
            await update.message.delete()
        except (BadRequest, Forbidden):
            pass

    if new_message:
        context.user_data[settings.ACTIVE_MESSAGE_ID_KEY] = new_message.message_id


async def remove_keyboard_from_previous_message(context: ContextTypes.DEFAULT_TYPE, chat_id: int):
    active_message_id = context.user_data.pop(settings.ACTIVE_MESSAGE_ID_KEY, None)
    if active_message_id:
        try:
            await context.bot.edit_message_reply_markup(
                chat_id=chat_id,
                message_id=active_message_id,
                reply_markup=None
            )
        except (BadRequest, Forbidden):
            pass


async def send_new_menu_message(
        context: ContextTypes.DEFAULT_TYPE,
        chat_id: int,
        text: str,
        reply_markup: InlineKeyboardMarkup
):
    await remove_keyboard_from_previous_message(context, chat_id)
    try:
        new_message = await context.bot.send_message(
            chat_id=chat_id,
            text=text,
            reply_markup=reply_markup,
            parse_mode=ParseMode.HTML
        )
        context.user_data[settings.ACTIVE_MESSAGE_ID_KEY] = new_message.message_id
    except (Forbidden, BadRequest) as e:
        logger.error(f"Failed to send new menu message to {chat_id}: {e}")


async def get_id_from_input(update: Update, context: ContextTypes.DEFAULT_TYPE) -> Optional[int]:
    message = update.message

    if message.forward_origin:
        origin = message.forward_origin
        if isinstance(origin, MessageOriginUser):
            return origin.sender_user.id
        if isinstance(origin, MessageOriginChannel):
            await message.reply_text("Пожалуйста, перешлите сообщение от пользователя, а не из канала.")
            return None
        if isinstance(origin, MessageOriginHiddenUser):
            await message.reply_text("Не удалось получить ID, так как пользователь скрыл свой аккаунт при пересылке. Попросите его написать боту /start и переслать его сообщение.")
            return None
        await message.reply_text("Этот тип пересланного сообщения не поддерживается.")
        return None

    text = message.text
    if not text:
        await message.reply_text("Пожалуйста, отправьте текст: ID, @username или перешлите сообщение.")
        return None
    if text.isdigit():
        return int(text)
    if text.startswith('@'):
        try:
            chat = await context.bot.get_chat(text)
            if chat.id < 0:
                await message.reply_text(f"Указанный {text} является группой или каналом, а не пользователем.")
                return None
            return chat.id
        except (BadRequest, Forbidden) as e:
            logger.warning(f"Could not find user by username {text}: {e}")
            await message.reply_text(f"Не удалось найти пользователя с ником {text}. Возможно, он не запускал бота.")
            return None

    await message.reply_text(
        "Неверный формат. Пожалуйста, перешлите сообщение, введите числовой Telegram ID или @username.")
    return None


async def add_to_sheets_queue(queue_name: str, data: List[Any]):
    if not data: return
    try:
        await database.add_to_sheets_db_queue(queue_name, data)
    except Exception as e:
        logger.error(f"Failed to add data to DB queue '{queue_name}': {e}", exc_info=True)


def format_user_for_sheets(user_id: int, full_name: str, username: Optional[str] = None) -> str:
    display_name = full_name
    if username:
        display_name += f" (@{username})"
    return f'=HYPERLINK("tg://user?id={user_id}"; "{display_name}")'

--- FILE: handlers/recruitment.py ---
import html
import logging
import re
import uuid
import asyncio

from telegram import Update, ReplyKeyboardRemove, InlineKeyboardMarkup, InlineKeyboardButton
from telegram.ext import (
    ContextTypes,
    ConversationHandler,
    CommandHandler,
    MessageHandler,
    CallbackQueryHandler,
    filters,
)
from telegram.constants import ParseMode
from telegram.error import BadRequest, Forbidden

from models import RecruitmentState
from core import settings, database, stickers
from utils.helpers import (
    get_user_data_from_update,
    safe_answer_callback_query,
    send_or_edit_message,
    send_transient_message,
    add_to_sheets_queue,
    add_user_to_interacted,
    get_now,
    format_user_for_sheets
)
from utils.keyboards import (
    RECRUITMENT_POSITION_OPTIONS,
    RESTAURANT_OPTIONS,
    YES_NO_OPTIONS,
    MARITAL_STATUS_OPTIONS,
    CHILDREN_OPTIONS,
    HEALTH_OPTIONS,
    ATTITUDE_TO_APPEARANCE_OPTIONS,
    EDUCATION_FORM_OPTIONS,
    COURSE_OPTIONS,
    EXPERIENCE_OPTIONS,
    INCOME_OPTIONS,
    JOBS_COUNT_OPTIONS,
    VACANCY_SOURCE_OPTIONS,
    build_inline_keyboard
)
from handlers.common import cancel, prompt_to_use_button
from handlers.feedback import schedule_candidate_feedback

logger = logging.getLogger(__name__)

TOTAL_QUESTIONS = 34
MIN_ANSWER_LENGTH = 10

WEEKLY_SHIFTS_OPTIONS = [
    ("1-2", "shifts_1_2"), ("2-3", "shifts_2_3"),
    ("3-4", "shifts_3_4"), ("4-5", "shifts_4_5"),
    ("5+", "shifts_5_plus")
]


def get_progress_bar(current_q: int, total_q: int) -> str:
    progress = int((current_q / total_q) * 10)
    filled = '█' * progress
    empty = '░' * (10 - progress)
    percent = int((current_q / total_q) * 100)
    return f"[{filled}{empty}] {percent}%"


def get_question_header(context: ContextTypes.DEFAULT_TYPE) -> str:
    current_q = context.user_data.setdefault('current_question_num', 1)
    progress_bar = get_progress_bar(current_q, TOTAL_QUESTIONS)
    return f"<b>Вопрос {current_q}/{TOTAL_QUESTIONS}</b>\n<code>{progress_bar}</code>\n\n"


async def start_recruitment_flow(update: Update, context: ContextTypes.DEFAULT_TYPE) -> RecruitmentState:
    user = update.effective_user
    logger.info(f"User {user.id} starting RECRUITMENT flow with deeplink.")
    await add_user_to_interacted(user.id, context)
    context.user_data.clear()
    context.user_data['conversations'] = {'recruitment_conv': True} # Флаг для /start

    if update.message:
        try:
            await update.message.delete()
        except (BadRequest, Forbidden):
            pass

    param = context.args[0] if context.args else ""
    if not param or not param.startswith("interview_"):
        await context.bot.send_message(
            update.effective_chat.id,
            "Ой, кажется, в ссылке или QR-коде ошибка. Пожалуйста, обратись к менеджеру, чтобы получить корректную ссылку."
        )
        return ConversationHandler.END

    restaurant_code_suffix = param.replace("interview_", "")
    restaurant_code = f"res_{restaurant_code_suffix}"
    restaurant_name = next((name for name, code in RESTAURANT_OPTIONS if code == restaurant_code), None)

    if not restaurant_name:
        await context.bot.send_message(
            update.effective_chat.id,
            "Не смогли определить ресторан по этой ссылке. Пожалуйста, обратись к менеджеру за помощью."
        )
        return ConversationHandler.END

    context.user_data['preselected_restaurant_code'] = restaurant_code_suffix
    context.user_data['preselected_restaurant_name'] = restaurant_name
    context.user_data['chat_id'] = update.effective_chat.id
    context.user_data['current_question_num'] = 1

    await context.bot.send_sticker(chat_id=user.id, sticker=stickers.get_random_greeting())
    await asyncio.sleep(0.5)

    header = get_question_header(context)
    text = (
        "Ciao! 👋\n\n"
        f"Рады, что ты хочешь стать частью команды «Марчеллис» в ресторане по адресу: <b>{html.escape(restaurant_name)}</b>.\n\n"
        f"Чтобы мы могли познакомиться поближе, я задам {TOTAL_QUESTIONS} вопросов. Это займет около 10-15 минут.\n\n"
        "<i>Продолжая диалог, ты даешь согласие на обработку своих персональных данных. Мы гарантируем их конфиденциальность.</i>\n\n"
        f"{header}"
        "Начнём? Напиши, пожалуйста, свои Фамилию, Имя и Отчество полностью."
    )

    sent_message = await context.bot.send_message(
        chat_id=update.effective_chat.id,
        text=text,
        parse_mode=ParseMode.HTML,
        reply_markup=ReplyKeyboardRemove()
    )
    context.user_data[settings.ACTIVE_MESSAGE_ID_KEY] = sent_message.message_id

    return RecruitmentState.FULL_NAME


async def full_name_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> RecruitmentState:
    context.user_data.setdefault('current_question_num', 1)
    full_name = update.message.text.strip()
    if len(full_name.split()) < 2:
        await send_transient_message(context, update.effective_chat.id,
                                     "Пожалуйста, введите как минимум Фамилию и Имя.")
        return RecruitmentState.FULL_NAME

    context.user_data['full_name'] = full_name
    first_name = full_name.split()[1] if len(full_name.split()) > 1 else full_name.split()[0]
    context.user_data['first_name'] = first_name

    context.user_data['current_question_num'] += 1
    header = get_question_header(context)
    text = (f"Отлично, {html.escape(first_name)}, приятно познакомиться! ✨\n\n"
            f"{header}"
            'Сколько тебе полных лет?')

    await send_or_edit_message(update, context, text)

    return RecruitmentState.AGE


async def age_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int | RecruitmentState:
    context.user_data.setdefault('current_question_num', 2)
    age_text = update.message.text.strip()
    if not age_text.isdigit():
        await send_transient_message(context, update.effective_chat.id, "Пожалуйста, введите свой возраст цифрами.")
        await update.message.delete()
        return RecruitmentState.AGE

    age = int(age_text)

    if age < 16:
        await send_or_edit_message(update, context,
                                   "К сожалению, мы можем принять на работу только с 16 лет. Спасибо за твой интерес, будем рады видеть тебя в будущем! 🙏"
                                   )
        context.user_data.clear()
        return ConversationHandler.END

    if age > 100:
        await send_transient_message(context, update.effective_chat.id,
                                     "Введен маловероятный возраст. Пожалуйста, проверь и введи корректное число.")
        await update.message.delete()
        return RecruitmentState.AGE

    context.user_data['age'] = age_text
    context.user_data['current_question_num'] += 1
    header = get_question_header(context)
    text = f"Принято!\n\n{header}" \
           'Расскажи немного о своей семье (с кем ты живешь, кто твои близкие).'
    await send_or_edit_message(update, context, text)
    return RecruitmentState.FAMILY_INFO


async def family_info_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> RecruitmentState:
    context.user_data.setdefault('current_question_num', 3)
    answer = update.message.text.strip()
    if len(answer) < MIN_ANSWER_LENGTH:
        await send_transient_message(context, update.effective_chat.id,
                                     f"Пожалуйста, дай более развернутый ответ (хотя бы {MIN_ANSWER_LENGTH} символов).")
        return RecruitmentState.FAMILY_INFO

    context.user_data['family_info'] = answer
    context.user_data['current_question_num'] += 1
    header = get_question_header(context)
    keyboard = build_inline_keyboard(VACANCY_SOURCE_OPTIONS, columns=2)
    text = f"Спасибо, что поделился(ась)!\n\n{header}" \
           'Откуда ты узнал(а) о вакансии?'
    await send_or_edit_message(update, context, text, keyboard)
    return RecruitmentState.VACANCY_SOURCE


async def vacancy_source_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> RecruitmentState:
    context.user_data.setdefault('current_question_num', 4)
    query = update.callback_query
    await safe_answer_callback_query(query)
    source = next((name for name, data in VACANCY_SOURCE_OPTIONS if data == query.data), "Другое")
    context.user_data['vacancy_source'] = source
    context.user_data['current_question_num'] += 1
    header = get_question_header(context)
    context.user_data.setdefault('selected_vacancies', [])
    buttons = [InlineKeyboardButton(f"{'✅ ' if code in context.user_data['selected_vacancies'] else ''}{name}",
                                    callback_data=code) for name, code in RECRUITMENT_POSITION_OPTIONS]
    keyboard_layout = [buttons[i:i + 2] for i in range(0, len(buttons), 2)]
    keyboard_layout.append([InlineKeyboardButton("✔️ Готово", callback_data="done_vacancies")])
    text = f"{header}Какая вакансия тебя интересует? (можно выбрать несколько)"
    await send_or_edit_message(update, context, text, InlineKeyboardMarkup(keyboard_layout))
    return RecruitmentState.AWAIT_MULTI_VACANCY


async def multi_vacancy_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> RecruitmentState:
    context.user_data.setdefault('current_question_num', 5)
    query = update.callback_query
    await safe_answer_callback_query(query)
    action = query.data
    selected_vacancies = context.user_data.setdefault('selected_vacancies', [])

    if action == "done_vacancies":
        if not selected_vacancies:
            await query.answer("Пожалуйста, выбери хотя бы одну вакансию.", show_alert=True)
            return RecruitmentState.AWAIT_MULTI_VACANCY

        if 'vac_Other' in selected_vacancies:
            await send_or_edit_message(update, context,
                                       "Ты выбрал(а) 'Другое'. Пожалуйста, уточни, какая должность тебя интересует?")
            return RecruitmentState.AWAIT_OTHER_VACANCY

        context.user_data['applied_position'] = ", ".join(
            [next(name for name, code in RECRUITMENT_POSITION_OPTIONS if code == v_code) for v_code in
             selected_vacancies])
        context.user_data['current_question_num'] += 1
        header = get_question_header(context)
        text = f"Выбрано: <b>{html.escape(context.user_data['applied_position'])}</b>.\n\n{header}Почему именно эта работа/вакансия тебя привлекает?"
        await send_or_edit_message(update, context, text)
        return RecruitmentState.REASON_FOR_CHOICE

    if action in selected_vacancies:
        selected_vacancies.remove(action)
    else:
        selected_vacancies.append(action)

    buttons = [InlineKeyboardButton(f"{'✅ ' if code in selected_vacancies else ''}{name}", callback_data=code) for
               name, code in RECRUITMENT_POSITION_OPTIONS]
    keyboard_layout = [buttons[i:i + 2] for i in range(0, len(buttons), 2)]
    keyboard_layout.append([InlineKeyboardButton("✔️ Готово", callback_data="done_vacancies")])
    await query.edit_message_reply_markup(reply_markup=InlineKeyboardMarkup(keyboard_layout))
    return RecruitmentState.AWAIT_MULTI_VACANCY


async def other_vacancy_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> RecruitmentState:
    other_position = update.message.text.strip()
    selected_vacancies = context.user_data.get('selected_vacancies', [])

    # Формируем итоговый список должностей
    final_positions = []
    for code in selected_vacancies:
        if code == 'vac_Other':
            final_positions.append(other_position)
        else:
            final_positions.append(next(name for name, c in RECRUITMENT_POSITION_OPTIONS if c == code))

    context.user_data['applied_position'] = ", ".join(final_positions)
    context.user_data['current_question_num'] += 1
    header = get_question_header(context)
    text = f"Выбрано: <b>{html.escape(context.user_data['applied_position'])}</b>.\n\n{header}Почему именно эта работа/вакансия тебя привлекает?"
    await send_or_edit_message(update, context, text)
    return RecruitmentState.REASON_FOR_CHOICE


async def reason_for_choice_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> RecruitmentState:
    context.user_data.setdefault('current_question_num', 6)
    answer = update.message.text.strip()
    if len(answer) < MIN_ANSWER_LENGTH:
        await send_transient_message(context, update.effective_chat.id,
                                     f"Пожалуйста, дай более развернутый ответ (хотя бы {MIN_ANSWER_LENGTH} символов).")
        return RecruitmentState.REASON_FOR_CHOICE

    context.user_data['reason_for_choice'] = answer
    context.user_data['current_question_num'] += 1
    header = get_question_header(context)
    context.user_data.setdefault('preferred_restaurants', [])
    buttons = [
        InlineKeyboardButton(f"{'✅ ' if code in context.user_data.get('preferred_restaurant_codes', []) else ''}{name}",
                             callback_data=code) for name, code in RESTAURANT_OPTIONS]
    keyboard_layout = [buttons[i:i + 2] for i in range(0, len(buttons), 2)]
    keyboard_layout.append([InlineKeyboardButton("✔️ Готово", callback_data="done_restaurants")])
    text = f"Интересный выбор! Спасибо.\n\n{header}" \
           'В каком из наших ресторанов ты хотел(а) бы работать? (можно выбрать несколько)'
    await send_or_edit_message(update, context, text, InlineKeyboardMarkup(keyboard_layout))
    return RecruitmentState.AWAIT_MULTI_RESTAURANT


async def multi_restaurant_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> RecruitmentState:
    context.user_data.setdefault('current_question_num', 7)
    query = update.callback_query
    await safe_answer_callback_query(query)
    action = query.data
    selected_restaurants_codes = context.user_data.setdefault('preferred_restaurant_codes', [])

    if action == "done_restaurants":
        if not selected_restaurants_codes:
            await query.answer("Пожалуйста, выбери хотя бы один ресторан.", show_alert=True)
            return RecruitmentState.AWAIT_MULTI_RESTAURANT

        context.user_data['preferred_restaurant'] = ", ".join(
            [next(name for name, code in RESTAURANT_OPTIONS if code == r_code) for r_code in
             selected_restaurants_codes])
        context.user_data['current_question_num'] += 1
        header = get_question_header(context)
        keyboard = build_inline_keyboard(YES_NO_OPTIONS, columns=2)
        text = f"{header}Ты уже знаком(а) с ресторанами «Марчеллис» как гость?"
        await send_or_edit_message(update, context, text, keyboard)
        return RecruitmentState.KNOWS_MARCELLIS

    if action in selected_restaurants_codes:
        selected_restaurants_codes.remove(action)
    else:
        selected_restaurants_codes.append(action)

    buttons = [InlineKeyboardButton(f"{'✅ ' if code in selected_restaurants_codes else ''}{name}", callback_data=code)
               for name, code in RESTAURANT_OPTIONS]
    keyboard_layout = [buttons[i:i + 2] for i in range(0, len(buttons), 2)]
    keyboard_layout.append([InlineKeyboardButton("✔️ Готово", callback_data="done_restaurants")])
    await query.edit_message_reply_markup(reply_markup=InlineKeyboardMarkup(keyboard_layout))
    return RecruitmentState.AWAIT_MULTI_RESTAURANT


async def knows_marcellis_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> RecruitmentState:
    context.user_data.setdefault('current_question_num', 8)
    query = update.callback_query
    await safe_answer_callback_query(query)
    context.user_data['knows_marcellis'] = "Да" if query.data == "yes" else "Нет"
    context.user_data['current_question_num'] += 1
    header = get_question_header(context)
    keyboard = build_inline_keyboard(YES_NO_OPTIONS, columns=2)
    text = f"{header}🌙 Готов(а) ли ты к ночным сменам?"
    await send_or_edit_message(update, context, text, keyboard)
    return RecruitmentState.NIGHT_SHIFTS


async def night_shifts_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> RecruitmentState:
    context.user_data.setdefault('current_question_num', 9)
    query = update.callback_query
    await safe_answer_callback_query(query)
    context.user_data['night_shifts'] = "Да" if query.data == "yes" else "Нет"
    context.user_data['current_question_num'] += 1
    header = get_question_header(context)
    keyboard = build_inline_keyboard(WEEKLY_SHIFTS_OPTIONS, columns=3)
    text = f"{header}🗓️ Сколько полных смен в неделю ты готов(а) нам уделять? (если полная смена = 12 часов)"
    await send_or_edit_message(update, context, text, keyboard)
    return RecruitmentState.WEEKLY_SHIFTS


async def weekly_shifts_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> RecruitmentState:
    context.user_data.setdefault('current_question_num', 10)
    query = update.callback_query
    await safe_answer_callback_query(query)
    answer = next((name for name, data in WEEKLY_SHIFTS_OPTIONS if data == query.data), "Не указано")
    context.user_data['weekly_shifts'] = answer
    context.user_data['current_question_num'] += 1
    header = get_question_header(context)
    text = f"{header}📱 Оставь, пожалуйста, свой мобильный телефон для связи (например, +79991234567):"
    await send_or_edit_message(update, context, text)
    return RecruitmentState.MOBILE_PHONE


async def mobile_phone_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> RecruitmentState:
    context.user_data.setdefault('current_question_num', 11)
    phone_text = update.message.text.strip()
    cleaned_phone = re.sub(r'\D', '', phone_text)
    if len(cleaned_phone) == 11 and cleaned_phone.startswith(('7', '8')):
        cleaned_phone = cleaned_phone[1:]
    if len(cleaned_phone) != 10:
        await send_transient_message(context, update.effective_chat.id,
                                     "Пожалуйста, введи корректный 10-значный номер телефона (например, +7 999 123-45-67).")
        await update.message.delete()
        return RecruitmentState.MOBILE_PHONE
    context.user_data['mobile_phone'] = f"+7{cleaned_phone}"
    context.user_data['current_question_num'] += 1
    header = get_question_header(context)
    text = f"Записал!\n\n{header}🌐 Есть ссылка на твой профиль в соцсетях (VK, Instagram и т.д.)? Если нет, просто напиши «нет»."
    await send_or_edit_message(update, context, text)
    return RecruitmentState.SOCIAL_LINK


async def social_link_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> RecruitmentState:
    context.user_data.setdefault('current_question_num', 12)
    context.user_data['social_link'] = update.message.text.strip()
    context.user_data['current_question_num'] += 1
    header = get_question_header(context)
    text = f"Окей!\n\n{header}🏙️ В каком городе ты родился(ась)?"
    await send_or_edit_message(update, context, text)
    return RecruitmentState.CITY


async def city_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> RecruitmentState:
    context.user_data.setdefault('current_question_num', 13)
    context.user_data['city'] = update.message.text.strip()
    context.user_data['current_question_num'] += 1
    header = get_question_header(context)
    text = f"Понятно!\n\n{header}🏠 А где ты сейчас живешь (город, район, ближайшее метро)?"
    await send_or_edit_message(update, context, text)
    return RecruitmentState.ADDRESS


async def address_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> RecruitmentState:
    context.user_data.setdefault('current_question_num', 14)
    context.user_data['address'] = update.message.text.strip()
    context.user_data['current_question_num'] += 1
    header = get_question_header(context)
    keyboard = build_inline_keyboard(MARITAL_STATUS_OPTIONS, columns=2)
    text = f"Принято, двигаемся дальше.\n\n{header}Каково твое семейное положение?"
    await send_or_edit_message(update, context, text, keyboard)
    return RecruitmentState.MARITAL_STATUS


async def marital_status_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> RecruitmentState:
    context.user_data.setdefault('current_question_num', 15)
    query = update.callback_query
    await safe_answer_callback_query(query)
    status = next((name for name, data in MARITAL_STATUS_OPTIONS if data == query.data), "Не указано")
    context.user_data['marital_status'] = status
    context.user_data['current_question_num'] += 1
    header = get_question_header(context)
    keyboard = build_inline_keyboard(CHILDREN_OPTIONS, columns=4)
    text = f"{header}👶 Есть ли у тебя дети?"
    await send_or_edit_message(update, context, text, keyboard)
    return RecruitmentState.CHILDREN


async def children_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> RecruitmentState:
    context.user_data.setdefault('current_question_num', 16)
    query = update.callback_query
    await safe_answer_callback_query(query)
    answer = next((text for text, data in CHILDREN_OPTIONS if data == query.data), "Не указано")
    context.user_data['children'] = answer
    context.user_data['current_question_num'] += 1
    header = get_question_header(context)
    keyboard = build_inline_keyboard(HEALTH_OPTIONS, columns=2)
    text = f"{header}💪 Как ты оцениваешь уровень своего здоровья?"
    await send_or_edit_message(update, context, text, keyboard)
    return RecruitmentState.HEALTH_ASSESSMENT


async def health_assessment_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> RecruitmentState:
    context.user_data.setdefault('current_question_num', 17)
    query = update.callback_query
    await safe_answer_callback_query(query)
    answer = next((text for text, data in HEALTH_OPTIONS if data == query.data), "Не указано")
    context.user_data['health_assessment'] = answer
    context.user_data['current_question_num'] += 1
    header = get_question_header(context)
    keyboard = build_inline_keyboard(ATTITUDE_TO_APPEARANCE_OPTIONS, columns=1)
    text = f"{header}✨ Как ты относишься к своей внешности?"
    await send_or_edit_message(update, context, text, keyboard)
    return RecruitmentState.ATTITUDE_TO_APPEARANCE


async def attitude_to_appearance_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> RecruitmentState:
    context.user_data.setdefault('current_question_num', 18)
    query = update.callback_query
    await safe_answer_callback_query(query)
    attitude = next((name for name, data in ATTITUDE_TO_APPEARANCE_OPTIONS if data == query.data), "Не указано")
    context.user_data['attitude_to_appearance'] = attitude
    context.user_data['current_question_num'] += 1
    header = get_question_header(context)
    text = f"{header}🎓 Напиши название твоего последнего учебного заведения (полностью):"
    await send_or_edit_message(update, context, text)
    return RecruitmentState.EDUCATION_NAME


async def education_name_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> RecruitmentState:
    context.user_data.setdefault('current_question_num', 19)
    context.user_data['education_name'] = update.message.text.strip()
    context.user_data['current_question_num'] += 1
    header = get_question_header(context)
    text = f"Супер!\n\n{header}📅 Год поступления / год окончания:"
    await send_or_edit_message(update, context, text)
    return RecruitmentState.GRADUATION_YEAR


async def graduation_year_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> RecruitmentState:
    context.user_data.setdefault('current_question_num', 20)
    context.user_data['graduation_year'] = update.message.text.strip()
    context.user_data['current_question_num'] += 1
    header = get_question_header(context)
    keyboard = build_inline_keyboard(COURSE_OPTIONS, columns=4)
    text = f"Записал.\n\n{header}🔢 На каком курсе учишься сейчас?"
    await send_or_edit_message(update, context, text, keyboard)
    return RecruitmentState.COURSE


async def course_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> RecruitmentState:
    context.user_data.setdefault('current_question_num', 21)
    query = update.callback_query
    await safe_answer_callback_query(query)
    course = next((name for name, data in COURSE_OPTIONS if data == query.data), "Не указано")
    context.user_data['course'] = course
    context.user_data['current_question_num'] += 1
    header = get_question_header(context)
    keyboard = build_inline_keyboard(EDUCATION_FORM_OPTIONS, columns=2)
    text = f"Принято.\n\n{header}🏛️ Форма обучения:"
    await send_or_edit_message(update, context, text, keyboard)
    return RecruitmentState.EDUCATION_FORM


async def education_form_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> RecruitmentState:
    context.user_data.setdefault('current_question_num', 22)
    query = update.callback_query
    await safe_answer_callback_query(query)
    form = next((name for name, data in EDUCATION_FORM_OPTIONS if data == query.data), "Не указано")
    context.user_data['education_form'] = form
    context.user_data['current_question_num'] += 1
    header = get_question_header(context)
    keyboard = InlineKeyboardMarkup([
        [InlineKeyboardButton("Да, напишу", callback_data="courses_yes")],
        [InlineKeyboardButton("Нет", callback_data="courses_no")]
    ])
    text = f"{header}📚 Проходил(а) ли ты какие-либо курсы, тренинги, семинары?"
    await send_or_edit_message(update, context, text, keyboard)
    return RecruitmentState.AWAIT_ADDITIONAL_COURSES_DECISION


async def additional_courses_decision_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> RecruitmentState:
    context.user_data.setdefault('current_question_num', 23)
    query = update.callback_query
    await safe_answer_callback_query(query)

    if query.data == "courses_yes":
        await send_or_edit_message(update, context, "Пожалуйста, перечисли их:")
        return RecruitmentState.ADDITIONAL_COURSES
    else:
        context.user_data['additional_courses'] = "Нет"
        context.user_data['current_question_num'] += 1
        header = get_question_header(context)
        keyboard = build_inline_keyboard(EXPERIENCE_OPTIONS, columns=2)
        text = f"Принято!\n\n{header}👷‍♂️ Есть ли у тебя опыт работы на той позиции, на которую претендуешь?"
        await send_or_edit_message(update, context, text, keyboard)
        return RecruitmentState.EXPERIENCE_DURATION


async def additional_courses_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> RecruitmentState:
    context.user_data.setdefault('current_question_num', 23)
    context.user_data['additional_courses'] = update.message.text.strip()
    context.user_data['current_question_num'] += 1
    header = get_question_header(context)
    keyboard = build_inline_keyboard(EXPERIENCE_OPTIONS, columns=2)
    text = f"Принято!\n\n{header}👷‍♂️ Есть ли у тебя опыт работы на той позиции, на которую претендуешь?"
    await send_or_edit_message(update, context, text, keyboard)
    return RecruitmentState.EXPERIENCE_DURATION


async def experience_duration_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> RecruitmentState:
    context.user_data.setdefault('current_question_num', 24)
    query = update.callback_query
    await safe_answer_callback_query(query)
    answer = next((text for text, data in EXPERIENCE_OPTIONS if data == query.data), "Не указано")
    context.user_data['experience_duration'] = answer
    context.user_data['current_question_num'] += 1

    if query.data == "exp_0":
        context.user_data['experience_details'] = "Нет"
        context.user_data['current_question_num'] += 1
        header = get_question_header(context)
        keyboard = build_inline_keyboard(INCOME_OPTIONS, columns=2)
        text = f"{header}💰 На какой доход в месяц ты рассчитываешь?"
        await send_or_edit_message(update, context, text, keyboard)
        return RecruitmentState.EXPECTED_INCOME
    else:
        header = get_question_header(context)
        text = f"{header}🏢 Опиши свой последний опыт: название компании, даты работы, должность и обязанности."
        await send_or_edit_message(update, context, text)
        return RecruitmentState.AWAIT_EXPERIENCE_DETAILS


async def experience_details_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> RecruitmentState:
    context.user_data.setdefault('current_question_num', 25)
    context.user_data['experience_details'] = update.message.text.strip()
    context.user_data['current_question_num'] += 1
    header = get_question_header(context)
    keyboard = build_inline_keyboard(INCOME_OPTIONS, columns=2)
    text = f"Подробно! Спасибо.\n\n{header}💰 На какой доход в месяц ты рассчитываешь?"
    await send_or_edit_message(update, context, text, keyboard)
    return RecruitmentState.EXPECTED_INCOME


async def expected_income_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> RecruitmentState:
    context.user_data.setdefault('current_question_num', 26)
    query = update.callback_query
    await safe_answer_callback_query(query)
    answer = next((text for text, data in INCOME_OPTIONS if data == query.data), "Не указано")
    context.user_data['expected_income'] = answer
    context.user_data['current_question_num'] += 1
    header = get_question_header(context)
    text = f"{header}🚶‍♂️ Какова была настоящая причина ухода с последнего места работы?"
    await send_or_edit_message(update, context, text)
    return RecruitmentState.REASON_FOR_LEAVING


async def reason_for_leaving_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> RecruitmentState:
    context.user_data.setdefault('current_question_num', 27)
    answer = update.message.text.strip()
    if len(answer) < MIN_ANSWER_LENGTH:
        await send_transient_message(context, update.effective_chat.id,
                                     f"Пожалуйста, дай более развернутый ответ (хотя бы {MIN_ANSWER_LENGTH} символов).")
        return RecruitmentState.REASON_FOR_LEAVING
    context.user_data['reason_for_leaving'] = answer
    context.user_data['current_question_num'] += 1
    header = get_question_header(context)
    keyboard = build_inline_keyboard(JOBS_COUNT_OPTIONS, columns=3)
    text = f"Спасибо за честность.\n\n{header}🏢 Укажи общее количество компаний, где ты когда-либо работал(а):"
    await send_or_edit_message(update, context, text, keyboard)
    return RecruitmentState.PREVIOUS_JOBS_COUNT


async def previous_jobs_count_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> RecruitmentState:
    context.user_data.setdefault('current_question_num', 28)
    query = update.callback_query
    await safe_answer_callback_query(query)
    answer = next((text for text, data in JOBS_COUNT_OPTIONS if data == query.data), "Не указано")
    context.user_data['previous_jobs_count'] = answer
    context.user_data['current_question_num'] += 1
    header = get_question_header(context)
    text = f"Отлично! Осталось совсем немного вопросов о тебе как о личности.\n\n{header}🤸‍♂️ Расскажи о своем отношении к спорту (занимаешься ли, чем увлекаешься):"
    await send_or_edit_message(update, context, text)
    return RecruitmentState.ATTITUDE_TO_SPORT


async def attitude_to_sport_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> RecruitmentState:
    context.user_data.setdefault('current_question_num', 29)
    context.user_data['attitude_to_sport'] = update.message.text.strip()
    context.user_data['current_question_num'] += 1
    header = get_question_header(context)
    text = f"Здорово!\n\n{header}✨ Перечисли три самых ценных для тебя качества в руководителе."
    await send_or_edit_message(update, context, text)
    return RecruitmentState.LIFE_VALUES


async def life_values_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> RecruitmentState:
    context.user_data.setdefault('current_question_num', 30)
    context.user_data['life_values'] = update.message.text.strip()
    context.user_data['current_question_num'] += 1
    header = get_question_header(context)
    text = f"Интересный взгляд!\n\n{header}🪨 Назови свои главные достоинства как сотрудника."
    await send_or_edit_message(update, context, text)
    return RecruitmentState.LIFE_WEAKNESSES


async def life_weaknesses_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> RecruitmentState:
    context.user_data.setdefault('current_question_num', 31)
    context.user_data['life_weaknesses'] = update.message.text.strip()
    context.user_data['current_question_num'] += 1
    header = get_question_header(context)
    text = f"Спасибо!\n\n{header}🎯 В какой сфере ты хотел(а) бы реализоваться в жизни?"
    await send_or_edit_message(update, context, text)
    return RecruitmentState.LIFE_GOAL


async def life_goal_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> RecruitmentState:
    context.user_data.setdefault('current_question_num', 32)
    context.user_data['life_goal'] = update.message.text.strip()
    context.user_data['current_question_num'] += 1
    header = get_question_header(context)
    text = f"Хорошая цель!\n\n{header}📖 Какую книгу ты сейчас читаешь или какой курс проходишь?"
    await send_or_edit_message(update, context, text)
    return RecruitmentState.READING_NOW


async def reading_now_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> RecruitmentState:
    context.user_data.setdefault('current_question_num', 33)
    context.user_data['reading_now'] = update.message.text.strip()
    context.user_data['current_question_num'] += 1
    header = get_question_header(context)
    keyboard = build_inline_keyboard(YES_NO_OPTIONS, columns=2)
    text = f"И последний вопрос, финишная прямая!\n\n{header}⚖️ Есть ли у тебя судимость?"
    await send_or_edit_message(update, context, text, keyboard)
    return RecruitmentState.JUDGED_BEFORE


async def judged_before_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    context.user_data.setdefault('current_question_num', 34)
    query = update.callback_query
    await safe_answer_callback_query(query)
    context.user_data['judged_before'] = "Да" if query.data == "yes" else "Нет"
    await send_or_edit_message(update, context,
                               "Отлично! Это был последний вопрос. 🚀\n\nСпасибо за уделенное время! Мы обрабатываем твою анкету...")
    await send_recruitment_results(context)

    first_name = context.user_data.get('first_name', 'кандидат')
    final_text = f"Спасибо, {html.escape(first_name)}! Твоя анкета принята. Менеджер скоро свяжется с тобой. Хорошего дня!"
    await send_or_edit_message(update, context, final_text, None)

    context.user_data.clear()
    return ConversationHandler.END


async def send_recruitment_results(context: ContextTypes.DEFAULT_TYPE):
    user_data = context.user_data
    chat_id = user_data.get('chat_id')
    user_full_name = user_data.get('full_name', f'Кандидат_{chat_id}')
    user = await context.bot.get_chat(chat_id)

    timestamp = get_now().strftime("%Y-%m-%d %H:%M:%S")
    interview_restaurant_code_suffix = user_data.get("preselected_restaurant_code")

    report_fields_for_sheets = [
        "preselected_restaurant_name", "full_name", "age", "family_info", "vacancy_source",
        "applied_position", "reason_for_choice", "preferred_restaurant", "knows_marcellis",
        "night_shifts", "weekly_shifts", "mobile_phone", "social_link", "city", "address", "marital_status",
        "children", "health_assessment", "attitude_to_appearance", "education_name",
        "graduation_year", "course", "education_form", "additional_courses",
        "experience_duration", "experience_details", "expected_income", "reason_for_leaving",
        "previous_jobs_count", "attitude_to_sport", "life_values", "life_weaknesses",
        "life_goal", "reading_now", "judged_before"
    ]

    user_link = format_user_for_sheets(chat_id, user_full_name, user.username)
    row_data = [timestamp, user_link]

    for key in report_fields_for_sheets:
        row_data.append(user_data.get(key, "N/A"))

    await add_to_sheets_queue(settings.INTERVIEW_SHEET_NAME, row_data)
    await database.log_survey_completion('recruitment', chat_id, interview_restaurant_code_suffix)
    await database.log_candidate_restaurant(chat_id, interview_restaurant_code_suffix)

    def clean_text(key, default="—"):
        text = str(user_data.get(key, default))
        text = text.replace('💍 ', '').replace('❤️ ', '').replace('🚶 ', '').replace('💔 ', '')
        text = text.replace('😍 ', '').replace('🙂 ', '').replace('😕 ', '')
        text = text.replace('☀️ ', '').replace('🌙 ', '').replace('✉️ ', '').replace('💻 ', '')
        return html.escape(text)

    full_report_parts = [
        f"<b>Кандидат:</b> <code>{clean_text('full_name')}</code>, {clean_text('age')} лет",
        f"<b>Вакансия:</b> {clean_text('applied_position')}",
        f"<b>Ресторан:</b> {clean_text('preselected_restaurant_name')}",
        f"<b>Телефон:</b> <code>{clean_text('mobile_phone')}</code>",
        f"<b>Соц. сеть:</b> <code>{clean_text('social_link')}</code>",
        "",
        "──────────────",
        "<b>КЛЮЧЕВЫЕ ДАННЫЕ</b>",
        "──────────────",
        f"<b>Ожидания по доходу:</b> {clean_text('expected_income')}",
        f"<b>Опыт:</b> {clean_text('experience_duration')}",
        f"<b>Предыдущие места работы:</b> {clean_text('previous_jobs_count')}",
        f"<b>Ночные смены:</b> {clean_text('night_shifts')}",
        f"<b>Смен в неделю:</b> {clean_text('weekly_shifts')}",
        f"<b>Знакомство с брендом:</b> {clean_text('knows_marcellis')}",
        f"<b>Судимость:</b> {clean_text('judged_before')}",
        f"<b>Состояние здоровья:</b> {clean_text('health_assessment')}",
        f"<b>Дети:</b> {clean_text('children')}",
        "",
        "──────────────",
        "<b>РАЗВЕРНУТЫЕ ОТВЕТЫ</b>",
        "──────────────",
        "",
        "🤔 <b>Мотивация и цели</b>",
        f"<i>{clean_text('reason_for_choice')}</i>",
        "",
        "🚶‍♂️ <b>Причина ухода с прошлого места</b>",
        f"<i>{clean_text('reason_for_leaving')}</i>",
        "",
        "📋 <b>Детали опыта работы</b>",
        f"<i>{clean_text('experience_details')}</i>",
        "",
        "💪 <b>Сильные стороны и ценности</b>",
        f"<i>Сильные стороны: {clean_text('life_weaknesses')}\nКачества в руководителе: {clean_text('life_values')}</i>",
        "",
        "🎓 <b>Образование</b>",
        f"<i>Учебное заведение: {clean_text('education_name')} ({clean_text('education_form')})\nГоды/Курс: {clean_text('graduation_year')} / {clean_text('course')}\nДоп. курсы: {clean_text('additional_courses')}</i>",
        "",
        "👤 <b>Личная информация</b>",
        f"<i>Проживание: {clean_text('address')}\nСемейное положение: {clean_text('marital_status')}\nСемья: {clean_text('family_info')}\nСпорт: {clean_text('attitude_to_sport')}\nКниги/Курсы: {clean_text('reading_now')}\nВнешность: {clean_text('attitude_to_appearance')}</i>",
    ]
    full_report_text = "\n".join(full_report_parts)

    summary_text = (
        f"⚡️ Новая анкета!\n\n"
        f"Кандидат: <b>{clean_text('full_name')}</b> ({clean_text('age')})\n"
        f"Позиция: <b>{clean_text('applied_position')}</b>\n"
        f"Ресторан: <b>{clean_text('preselected_restaurant_name')}</b>\n\n"
        f"💵 {clean_text('expected_income')}\n"
        f"🕒 Опыт: {clean_text('experience_duration')}\n"
        f"🌙 Ночи: {clean_text('night_shifts')}"
    )

    recipients = set(settings.ADMIN_IDS)
    if interview_restaurant_code_suffix:
        manager_ids = await database.get_managers_for_restaurant(interview_restaurant_code_suffix)
        recipients.update(manager_ids)

    job_context_for_managers = {
        "candidate_id": chat_id,
        "candidate_name": user_data.get('full_name', 'Кандидат'),
        "position": user_data.get('applied_position', '—'),
        "full_name": user_data.get('full_name', '—'),
        "address": user_data.get('address', '—'),
        "phone": user_data.get('mobile_phone', '—'),
        "interview_restaurant_code": interview_restaurant_code_suffix,
        "interview_restaurant_name": user_data.get('preselected_restaurant_name', 'Не указан'),
        "preferred_restaurant_codes": user_data.get('preferred_restaurant_codes', []),
        "recruitment_report": full_report_text
    }

    # --- Регистрация кандидата в БД как НЕАКТИВНОГО ---
    # ПРИМЕЧАНИЕ: Вам потребуется создать эту функцию в core/database.py
    # Она должна добавлять запись в таблицу employees со статусом is_active = 0
    await database.register_candidate(
        user_id=chat_id,
        full_name=user_full_name,
        restaurant_code=interview_restaurant_code_suffix
    )
    logger.info(f"Candidate {chat_id} registered in the system as inactive.")

    for recipient_id in recipients:
        try:
            feedback_id = str(uuid.uuid4())
            keyboard = InlineKeyboardMarkup([[
                InlineKeyboardButton("📄 Посмотреть полную анкету", callback_data=f"show_full_report_{feedback_id}")
            ]])

            sent_message = await context.bot.send_message(recipient_id, summary_text, parse_mode=ParseMode.HTML,
                                                          reply_markup=keyboard)

            await database.add_pending_feedback(
                feedback_id=feedback_id,
                manager_id=recipient_id,
                message_id=sent_message.message_id,
                candidate_id=chat_id,
                candidate_name=user_data.get('full_name', 'Кандидат'),
                job_data=job_context_for_managers,
                created_at=get_now().timestamp()
            )
        except Exception as e:
            logger.error(f"Ошибка отправки анкеты и создания задачи для получателя {recipient_id}: {e}")

    if context.job_queue:
        job_context_for_candidate = {"candidate_id": chat_id}
        context.job_queue.run_once(schedule_candidate_feedback, when=settings.FEEDBACK_DELAY_SECONDS,
                                   data=job_context_for_candidate, name=f"cand_feedback_{chat_id}")

        logger.info(f"Scheduled candidate feedback for candidate {chat_id}")


async def show_full_recruitment_report(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    await safe_answer_callback_query(query)
    feedback_id = query.data.replace("show_full_report_", "")

    # Сначала ищем в активных задачах
    feedback_task = await database.get_pending_feedback_by_id(feedback_id)
    # Если не нашли, ищем в истории
    if not feedback_task:
        feedback_task = await database.get_feedback_from_history(feedback_id)

    if not feedback_task:
        await query.edit_message_text(
            f"{query.message.text}\n\n<i>(Анкета не найдена в активных задачах или истории.)</i>",
            parse_mode=ParseMode.HTML,
            reply_markup=None
        )
        return

    full_report = feedback_task.get("job_data", {}).get("recruitment_report", "Не удалось загрузить полную анкету.")

    try:
        await query.edit_message_text(
            text=full_report,
            parse_mode=ParseMode.HTML,
            reply_markup=None
        )
    except BadRequest as e:
        if "Message is not modified" not in str(e):
            logger.error(f"Error editing message to full report: {e}")
            await query.message.reply_text(text=full_report, parse_mode=ParseMode.HTML)


async def send_candidate_check_info(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    await safe_answer_callback_query(query)
    candidate_id = int(query.data.replace("check_candidate_", ""))
    check_data = context.bot_data.get('candidate_check_info', {}).get(candidate_id)

    if not check_data:
        await query.edit_message_text("Данные для проверки не найдены (возможно, они устарели).")
        return

    check_message_parts = [
        f"<b>1.</b> {html.escape(check_data['position'])}",
        f"<b>2.</b> <code>{html.escape(check_data['full_name'])}</code>",
        "<b>3. В проекте не работал</b>",
        f"<b>4.</b> {html.escape(check_data['address'])}",
        f"<b>5.</b> <code>{html.escape(check_data['phone'])}</code>",
    ]
    check_message = "\n".join(check_message_parts)
    await query.message.reply_text(text=check_message, parse_mode=ParseMode.HTML)
    await query.edit_message_reply_markup(reply_markup=None)


recruitment_conversation_handler = ConversationHandler(
    entry_points=[CommandHandler("start", start_recruitment_flow, filters=filters.Regex(r'interview_'))],
    states={
        RecruitmentState.FULL_NAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, full_name_received)],
        RecruitmentState.AGE: [MessageHandler(filters.TEXT & ~filters.COMMAND, age_received)],
        RecruitmentState.FAMILY_INFO: [MessageHandler(filters.TEXT & ~filters.COMMAND, family_info_received)],
        RecruitmentState.VACANCY_SOURCE: [CallbackQueryHandler(vacancy_source_received, pattern="^src_"),
                                          MessageHandler(filters.TEXT & ~filters.COMMAND, prompt_to_use_button)],
        RecruitmentState.AWAIT_MULTI_VACANCY: [
            CallbackQueryHandler(multi_vacancy_handler, pattern="^vac_|done_vacancies$"),
            MessageHandler(filters.TEXT & ~filters.COMMAND, prompt_to_use_button)],
        RecruitmentState.AWAIT_OTHER_VACANCY: [MessageHandler(filters.TEXT & ~filters.COMMAND, other_vacancy_received)],
        RecruitmentState.REASON_FOR_CHOICE: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, reason_for_choice_received)],
        RecruitmentState.AWAIT_MULTI_RESTAURANT: [
            CallbackQueryHandler(multi_restaurant_handler, pattern="^res_|done_restaurants$"),
            MessageHandler(filters.TEXT & ~filters.COMMAND, prompt_to_use_button)],
        RecruitmentState.KNOWS_MARCELLIS: [CallbackQueryHandler(knows_marcellis_received, pattern="^(yes|no)$"),
                                           MessageHandler(filters.TEXT & ~filters.COMMAND, prompt_to_use_button)],
        RecruitmentState.NIGHT_SHIFTS: [CallbackQueryHandler(night_shifts_received, pattern="^(yes|no)$"),
                                        MessageHandler(filters.TEXT & ~filters.COMMAND, prompt_to_use_button)],
        RecruitmentState.WEEKLY_SHIFTS: [CallbackQueryHandler(weekly_shifts_received, pattern="^shifts_"),
                                         MessageHandler(filters.TEXT & ~filters.COMMAND, prompt_to_use_button)],
        RecruitmentState.MOBILE_PHONE: [MessageHandler(filters.TEXT & ~filters.COMMAND, mobile_phone_received)],
        RecruitmentState.SOCIAL_LINK: [MessageHandler(filters.TEXT & ~filters.COMMAND, social_link_received)],
        RecruitmentState.CITY: [MessageHandler(filters.TEXT & ~filters.COMMAND, city_received)],
        RecruitmentState.ADDRESS: [MessageHandler(filters.TEXT & ~filters.COMMAND, address_received)],
        RecruitmentState.MARITAL_STATUS: [CallbackQueryHandler(marital_status_received, pattern="^m_"),
                                          MessageHandler(filters.TEXT & ~filters.COMMAND, prompt_to_use_button)],
        RecruitmentState.CHILDREN: [CallbackQueryHandler(children_received, pattern="^child_"),
                                    MessageHandler(filters.TEXT & ~filters.COMMAND, prompt_to_use_button)],
        RecruitmentState.HEALTH_ASSESSMENT: [CallbackQueryHandler(health_assessment_received, pattern="^health_"),
                                             MessageHandler(filters.TEXT & ~filters.COMMAND, prompt_to_use_button)],
        RecruitmentState.ATTITUDE_TO_APPEARANCE: [
            CallbackQueryHandler(attitude_to_appearance_received, pattern="^app_"),
            MessageHandler(filters.TEXT & ~filters.COMMAND, prompt_to_use_button)],
        RecruitmentState.EDUCATION_NAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, education_name_received)],
        RecruitmentState.GRADUATION_YEAR: [MessageHandler(filters.TEXT & ~filters.COMMAND, graduation_year_received)],
        RecruitmentState.COURSE: [CallbackQueryHandler(course_received, pattern="^course_"),
                                  MessageHandler(filters.TEXT & ~filters.COMMAND, prompt_to_use_button)],
        RecruitmentState.EDUCATION_FORM: [CallbackQueryHandler(education_form_received, pattern="^form_"),
                                          MessageHandler(filters.TEXT & ~filters.COMMAND, prompt_to_use_button)],
        RecruitmentState.AWAIT_ADDITIONAL_COURSES_DECISION: [
            CallbackQueryHandler(additional_courses_decision_received, pattern="^courses_"),
            MessageHandler(filters.TEXT & ~filters.COMMAND, prompt_to_use_button)],
        RecruitmentState.ADDITIONAL_COURSES: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, additional_courses_received)],
        RecruitmentState.EXPERIENCE_DURATION: [CallbackQueryHandler(experience_duration_received, pattern="^exp_"),
                                               MessageHandler(filters.TEXT & ~filters.COMMAND, prompt_to_use_button)],
        RecruitmentState.AWAIT_EXPERIENCE_DETAILS: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, experience_details_received)],
        RecruitmentState.EXPECTED_INCOME: [CallbackQueryHandler(expected_income_received, pattern="^inc_"),
                                           MessageHandler(filters.TEXT & ~filters.COMMAND, prompt_to_use_button)],
        RecruitmentState.REASON_FOR_LEAVING: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, reason_for_leaving_received)],
        RecruitmentState.PREVIOUS_JOBS_COUNT: [CallbackQueryHandler(previous_jobs_count_received, pattern="^jobs_"),
                                               MessageHandler(filters.TEXT & ~filters.COMMAND, prompt_to_use_button)],
        RecruitmentState.ATTITUDE_TO_SPORT: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, attitude_to_sport_received)],
        RecruitmentState.LIFE_VALUES: [MessageHandler(filters.TEXT & ~filters.COMMAND, life_values_received)],
        RecruitmentState.LIFE_WEAKNESSES: [MessageHandler(filters.TEXT & ~filters.COMMAND, life_weaknesses_received)],
        RecruitmentState.LIFE_GOAL: [MessageHandler(filters.TEXT & ~filters.COMMAND, life_goal_received)],
        RecruitmentState.READING_NOW: [MessageHandler(filters.TEXT & ~filters.COMMAND, reading_now_received)],
        RecruitmentState.JUDGED_BEFORE: [CallbackQueryHandler(judged_before_received, pattern="^(yes|no)$"),
                                         MessageHandler(filters.TEXT & ~filters.COMMAND, prompt_to_use_button)],
    },
    fallbacks=[CommandHandler("cancel", cancel)],
    name="recruitment_conv",
    persistent=True,
    per_message=False,
    conversation_timeout=settings.CONVERSATION_TIMEOUT_SECONDS
)

--- FILE: handlers/main_menu.py ---
import html
import logging
import asyncio

from telegram import Update, ReplyKeyboardRemove
from telegram.ext import (
    ContextTypes,
    ConversationHandler,
)
from telegram.constants import ParseMode
from telegram.error import Forbidden

from models import MainMenuState, AdminState, FeedbackState, ManagerFeedbackState
from core import settings, database, stickers
from utils.helpers import (
    safe_answer_callback_query, add_user_to_interacted,
    get_user_data_from_update, send_new_menu_message, send_or_edit_message,
    set_user_commands
)
from utils.keyboards import get_manager_menu_keyboard, get_pending_feedback_keyboard
from handlers.admin import admin_panel_start
from handlers.manager_feedback_flow import start_manager_feedback_flow
from handlers.common import handle_blocked_user

logger = logging.getLogger(__name__)


async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    user = update.effective_user
    if not user:
        return ConversationHandler.END

    active_conv_names = [
        'recruitment_conv', 'onboarding_conv', 'exit_interview_conv',
        'climate_survey_conv', 'manager_reg_conv', 'admin_conv'
    ]
    current_conversations = context.user_data.get('conversations', {})
    is_in_another_conv = any(current_conversations.get(name) is not None for name in active_conv_names)

    if is_in_another_conv:
        logger.info(f"User {user.id} tried to use /start while in an active conversation.")
        if update.effective_message:
            await update.effective_message.reply_text(
                "Кажется, вы сейчас в процессе заполнения анкеты. "
                "Чтобы прервать и начать заново, пожалуйста, используйте команду /cancel.",
                reply_markup=ReplyKeyboardRemove()
            )
        return ConversationHandler.END

    try:
        await set_user_commands(user.id, context.bot)
        await add_user_to_interacted(user.id, context)

        is_manager = await database.is_user_a_manager(user.id)

        if update.callback_query:
            await safe_answer_callback_query(update.callback_query)

        if is_manager:
            return await show_manager_menu(update, context)

        await context.bot.send_sticker(chat_id=user.id, sticker=stickers.get_random_greeting())
        await update.effective_message.reply_text(
            "Ciao! 👋 Я бот-помощник команды «Марчеллис».\n\n"
            "Если вы кандидат, пожалуйста, воспользуйтесь специальной ссылкой или QR-кодом от менеджера, чтобы начать анкетирование.\n\n"
            "Если у вас есть вопрос, предложение или вы хотите оставить отзыв — просто напишите его в следующем сообщении.",
            reply_markup=ReplyKeyboardRemove()
        )
        return ConversationHandler.END

    except Forbidden:
        return await handle_blocked_user(user.id, context)


async def show_manager_menu(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    user = update.effective_user
    await context.bot.send_sticker(chat_id=user.id, sticker=stickers.GREETING_WAITER)

    pending_feedback = await database.get_pending_feedback_for_manager(user.id)
    keyboard = get_manager_menu_keyboard(len(pending_feedback))
    text = f"Ciao, {html.escape(user.first_name)}! 👋\n\nЭто твое меню менеджера."

    await send_new_menu_message(context, user.id, text, keyboard)
    return MainMenuState.MAIN


async def handle_manager_feedback_button(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await safe_answer_callback_query(query)
    user_id = query.from_user.id

    pending_tasks = await database.get_pending_feedback_for_manager(user_id)
    if not pending_tasks:
        await query.answer("У тебя нет кандидатов, ожидающих обратной связи.", show_alert=True)
        return MainMenuState.MAIN

    keyboard = get_pending_feedback_keyboard(pending_tasks)
    await send_or_edit_message(update, context, "Выбери кандидата, по которому хочешь оставить обратную связь:",
                               keyboard)

    return MainMenuState.AWAITING_FEEDBACK_CHOICE


async def handle_feedback_candidate_selection(update: Update,
                                              context: ContextTypes.DEFAULT_TYPE) -> ManagerFeedbackState:
    query = update.callback_query
    await safe_answer_callback_query(query)

    feedback_id = query.data.replace("fb_", "")
    context.user_data['feedback_id'] = feedback_id

    return await start_manager_feedback_flow(update, context)


async def start_feedback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    user = update.effective_user
    if not user:
        return ConversationHandler.END

    logger.info(f"User {user.id} triggered /start or text message. Routing to general FEEDBACK flow.")

    if update.effective_chat:
        context.user_data['chat_id'] = update.effective_chat.id

    text = ("Привет! 👋 Я бот-помощник команды «Марчеллис».\n\n"
            "Если у тебя есть предложение, вопрос или жалоба — просто напиши это в следующем сообщении, и я передам всё нашей команде.\n\n"
            "Чтобы отменить, отправь команду /cancel.")

    try:
        await context.bot.send_sticker(chat_id=user.id, sticker=stickers.QUESTION_DOG)
        await asyncio.sleep(0.5)

        sent_message = await update.effective_message.reply_text(text, reply_markup=ReplyKeyboardRemove())
        context.user_data[settings.ACTIVE_MESSAGE_ID_KEY] = sent_message.message_id

        return FeedbackState.AWAITING_FEEDBACK
    except Forbidden:
        return await handle_blocked_user(user.id, context)


async def receive_and_forward_feedback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    feedback_text = update.message.text
    user_id, user_name, _ = get_user_data_from_update(update)
    logger.info(f"Received general feedback from {user_name}")

    if settings.ADMIN_IDS:
        message = f"📩 <b>Новое сообщение от пользователя</b> 📩\n\n<b>От:</b> {html.escape(user_name)}\n<b>Сообщение:</b>\n<pre>{html.escape(feedback_text)}</pre>"
        for admin_id in settings.ADMIN_IDS:
            try:
                await context.bot.send_message(admin_id, message, parse_mode=ParseMode.HTML)
            except Exception as e:
                logger.error(f"Failed to forward feedback to admin {admin_id}: {e}")

        await send_or_edit_message(update, context, "Спасибо! Мы получили твое сообщение и передали команде. 🙏")
        await asyncio.sleep(0.5)
        await context.bot.send_sticker(chat_id=user_id, sticker=stickers.FEEDBACK_SENT_DOG)
    else:
        await send_or_edit_message(update, context,
                                   "К сожалению, функция отправки сообщений сейчас не работает. Попробуй, пожалуйста, позже."
                                   )

    context.user_data.clear()
    return ConversationHandler.END

--- FILE: handlers/feedback.py ---
import html
import logging
from datetime import timedelta

from telegram import Update, InlineKeyboardMarkup, InlineKeyboardButton
from telegram.ext import (
    ContextTypes,
    ConversationHandler,
    CommandHandler,
    CallbackQueryHandler,
    MessageHandler,
    filters,
)
from telegram.constants import ParseMode

from models import CandidateFeedbackState, OnboardingFollowupState
from core import settings, database
from utils.helpers import (
    safe_answer_callback_query,
    send_or_edit_message,
    add_to_sheets_queue,
    build_inline_keyboard,
    get_now,
    get_user_data_from_update,
    send_new_menu_message
)
from utils.keyboards import CANDIDATE_FEEDBACK_RATING_OPTIONS, YES_NO_OPTIONS, RESTAURANT_OPTIONS
from handlers.common import cancel, prompt_to_use_button
from handlers.onboarding import start_onboarding_flow

logger = logging.getLogger(__name__)

async def schedule_candidate_feedback(context: ContextTypes.DEFAULT_TYPE):
    job_data = context.job.data
    candidate_id = job_data["candidate_id"]

    text = "Привет еще раз! 👋 Прошло немного времени после твоего визита. Будем очень благодарны, если ты ответишь на 4 коротких вопроса о встрече. Это поможет нам стать лучше."
    keyboard = InlineKeyboardMarkup(
        [[InlineKeyboardButton("✍️ Пройти опрос (1 минута)",
                               callback_data=settings.CALLBACK_START_CANDIDATE_FEEDBACK)]])

    try:
        await context.bot.send_message(candidate_id, text, reply_markup=keyboard)
    except Exception as e:
        logger.error(f"Failed to send candidate feedback poll to {candidate_id}: {e}")


async def schedule_onboarding_noshow_check(context: ContextTypes.DEFAULT_TYPE):
    job_data = context.job.data
    candidate_id = job_data.get("candidate_id")

    if not candidate_id:
        logger.error("No candidate_id in schedule_onboarding_noshow_check job.")
        return

    if await database.is_survey_completed("onboarding", candidate_id):
        logger.info(f"Candidate {candidate_id} has completed onboarding survey. No-show check cancelled.")
        return

    logger.info(f"Starting onboarding NO-SHOW check for candidate {candidate_id}.")
    keyboard = InlineKeyboardMarkup([
        [InlineKeyboardButton("Да, все в силе / смена перенеслась", callback_data=settings.CALLBACK_ONBOARDING_FOLLOWUP_YES)],
        [InlineKeyboardButton("Нет, я передумал(а) / не могу выйти", callback_data=settings.CALLBACK_ONBOARDING_FOLLOWUP_NO)],
    ])
    text = ("Привет! 👋 На связи команда «Марчеллис».\n\n"
            "Заметили, что ты не прошел(-ла) опрос после ознакомительной смены. "
            "Хотели бы уточнить твой статус: твои планы по работе у нас еще актуальны?")

    try:
        sent_message = await context.bot.send_message(candidate_id, text, reply_markup=keyboard)
        context.user_data[settings.ACTIVE_MESSAGE_ID_KEY] = sent_message.message_id
        context.user_data['candidate_id_for_noshow'] = candidate_id
    except Exception as e:
        logger.error(f"Failed to send onboarding no-show check to {candidate_id}: {e}")


async def start_onboarding_followup(update: Update,
                                    context: ContextTypes.DEFAULT_TYPE) -> OnboardingFollowupState | int:
    query = update.callback_query
    await safe_answer_callback_query(query)

    if query.data == settings.CALLBACK_ONBOARDING_FOLLOWUP_YES:
        await send_or_edit_message(update, context,
                                   "Отлично! Рады, что ты с нами. Пожалуйста, не забудь пройти опрос после своей первой смены (ссылку тебе давал менеджер).")
        return ConversationHandler.END

    elif query.data == settings.CALLBACK_ONBOARDING_FOLLOWUP_NO:
        await send_or_edit_message(update, context,
                                   "Очень жаль это слышать. Если не сложно, напиши, пожалуйста, что повлияло на твое решение?")
        return OnboardingFollowupState.AWAITING_LEAVING_REASON

    return ConversationHandler.END


async def leaving_reason_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    reason = update.message.text
    user_id, user_name, _ = get_user_data_from_update(update)
    timestamp = get_now().strftime("%Y-%m-%d %H:%M:%S")

    restaurant_code = await database.get_candidate_restaurant(user_id)
    restaurant_name = "Неизвестно"
    if restaurant_code:
         restaurant_name = next((name for name, r_code in RESTAURANT_OPTIONS if r_code.endswith(restaurant_code)), restaurant_code)

    row_data = [timestamp, user_name, user_id, restaurant_name, reason]
    await add_to_sheets_queue(settings.CANDIDATE_NOSHOW_SHEET_NAME, row_data)

    manager_ids = []
    if restaurant_code:
        manager_ids = await database.get_managers_for_restaurant(restaurant_code)

    recipients = set(settings.ADMIN_IDS).union(set(manager_ids))
    notification_tasks = await database.get_all_pending_feedback_for_candidate(user_id)

    if notification_tasks and recipients:
        message = (f"❗️🗣️ <b>Кандидат передумал выходить на смену</b>\n\n"
                   f"<b>Кандидат:</b> {html.escape(user_name)}\n"
                   f"<b>Ресторан:</b> {html.escape(restaurant_name)}\n\n"
                   f"<b>Причина, указанная кандидатом:</b>\n<pre>{html.escape(reason)}</pre>\n\n"
                   f"<i>Задачи по этому кандидату закрыты.</i>")

        for task in notification_tasks:
            if task['manager_id'] in recipients:
                try:
                    await context.bot.send_message(
                        chat_id=task['manager_id'],
                        text=message,
                        reply_to_message_id=task['message_id'],
                        parse_mode=ParseMode.HTML,
                        allow_sending_without_reply=True
                    )
                except Exception as e:
                    logger.error(f"Failed to send leaving reason to manager/admin {task['manager_id']}: {e}")

    # Вместо полного удаления данных, просто удаляем его из очереди на рассмотрение
    await database.remove_all_pending_feedback_for_candidate(user_id)
    # Статус is_active остается 0, что корректно для отказавшегося кандидата
    logger.info(f"User {user_id} changed their mind. Reason recorded, pending feedback cleared. User data retained as inactive.")

    await send_or_edit_message(update, context,
                               "Спасибо за честный ответ. Эта информация поможет нам стать лучше. Удачи в дальнейших поисках!")
    return ConversationHandler.END


onboarding_followup_conversation_handler = ConversationHandler(
    entry_points=[
        CallbackQueryHandler(start_onboarding_followup,
                             pattern=f"^{settings.CALLBACK_ONBOARDING_FOLLOWUP_YES}$|^{settings.CALLBACK_ONBOARDING_FOLLOWUP_NO}$")
    ],
    states={
        OnboardingFollowupState.AWAITING_LEAVING_REASON: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, leaving_reason_received)],
    },
    fallbacks=[CommandHandler('cancel', cancel)],
    name="onboarding_followup_conv",
    persistent=True,
    per_message=False
)


async def start_candidate_feedback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> CandidateFeedbackState:
    query = update.callback_query
    await safe_answer_callback_query(query)
    context.user_data.clear()
    context.user_data[settings.ACTIVE_MESSAGE_ID_KEY] = query.message.message_id

    keyboard = build_inline_keyboard(CANDIDATE_FEEDBACK_RATING_OPTIONS, columns=5)
    text = "<b>Вопрос 1/4:</b> Как в целом прошло интервью? Пожалуйста, оцени от 1 (плохо) до 5 (отлично)."
    await send_or_edit_message(update, context, text, keyboard)
    return CandidateFeedbackState.AWAITING_IMPRESSION


async def impression_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> CandidateFeedbackState:
    query = update.callback_query
    await safe_answer_callback_query(query)
    context.user_data["impression_rating"] = query.data.split("_")[-1]
    context.user_data["candidate_name"] = update.effective_user.full_name
    context.user_data["candidate_id"] = update.effective_user.id

    keyboard = build_inline_keyboard(YES_NO_OPTIONS, columns=2)
    text = "<b>Вопрос 2/4:</b> Рассказал ли тебе менеджер обо всех условиях работы (график, зарплата, обязанности)?"
    await send_or_edit_message(update, context, text, keyboard)
    return CandidateFeedbackState.AWAITING_CONDITIONS_MET


async def conditions_met_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> CandidateFeedbackState:
    query = update.callback_query
    await safe_answer_callback_query(query)
    context.user_data["conditions_met"] = "Да" if query.data == "yes" else "Нет"

    keyboard = build_inline_keyboard(YES_NO_OPTIONS, columns=2)
    text = "<b>Вопрос 3/4:</b> Были ли тебе понятны требования к кандидату на эту должность?"
    await send_or_edit_message(update, context, text, keyboard)
    return CandidateFeedbackState.AWAITING_REQUIREMENTS_CLEAR


async def requirements_clear_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> CandidateFeedbackState:
    query = update.callback_query
    await safe_answer_callback_query(query)
    context.user_data["requirements_clear"] = "Да" if query.data == "yes" else "Нет"

    text = "<b>Вопрос 4/4:</b> Может быть, у тебя есть дополнительные комментарии или пожелания для нас? (Если нет, напиши «нет»)"
    await send_or_edit_message(update, context, text, None)
    return CandidateFeedbackState.AWAITING_ADDITIONAL_COMMENTS


async def additional_comments_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    context.user_data["additional_comments"] = update.message.text

    user_data = context.user_data
    candidate_id = user_data["candidate_id"]
    candidate_name = user_data["candidate_name"]
    timestamp = get_now().strftime("%Y-%m-%d %H:%M:%S")

    restaurant_code = await database.get_candidate_restaurant(candidate_id)

    impression_rating_str = user_data.get("impression_rating")
    conditions_met = user_data.get("conditions_met")
    requirements_clear = user_data.get("requirements_clear")
    additional_comments = user_data.get("additional_comments", 'Нет')

    row_data = [timestamp, candidate_name, candidate_id, impression_rating_str, conditions_met, requirements_clear,
                additional_comments]
    await add_to_sheets_queue(settings.CANDIDATE_FEEDBACK_SHEET_NAME, row_data)

    await database.log_survey_completion('candidate_feedback', candidate_id, restaurant_code)

    flags = []
    message_title = "📝 <b>ОС от кандидата после собеседования</b>"

    try:
        if impression_rating_str and int(impression_rating_str) < 3:
            flags.append(f"🚩 <b>Низкая оценка интервью: {impression_rating_str}/5</b>")
    except (ValueError, TypeError):
        pass

    if conditions_met == "Нет":
        flags.append("⚠️ <b>Условия работы были не озвучены или не понятны.</b>")
    if requirements_clear == "Нет":
        flags.append("⚠️ <b>Требования к кандидату были не ясны.</b>")

    if flags:
        message_title = "❗️🚩 <b>Критическая ОС от кандидата!</b> 🚩❗️"

    admin_message_parts = [message_title]
    admin_message_parts.append(f"\n<b>Кандидат:</b> {html.escape(candidate_name)} (ID: <code>{candidate_id}</code>)")

    if flags:
        admin_message_parts.append("\n<b>Критические моменты:</b>")
        admin_message_parts.extend(flags)
        admin_message_parts.append("\n" + "=" * 20 + "\n")

    admin_message_parts.append("<b>Полный отзыв:</b>")
    admin_message_parts.append(f"<b>Оценка интервью:</b> {impression_rating_str}/5")
    admin_message_parts.append(f"<b>Условия озвучены:</b> {conditions_met}")
    admin_message_parts.append(f"<b>Требования понятны:</b> {requirements_clear}")
    admin_message_parts.append(f"<b>Комментарий:</b> {html.escape(additional_comments)}")

    admin_message = "\n".join(admin_message_parts)

    admin_tasks = await database.get_all_pending_feedback_for_candidate(candidate_id)
    for task in admin_tasks:
        if task['manager_id'] in settings.ADMIN_IDS:
            try:
                await context.bot.send_message(
                    chat_id=task['manager_id'],
                    text=admin_message,
                    parse_mode=ParseMode.HTML,
                    reply_to_message_id=task['message_id'],
                    allow_sending_without_reply=True
                )
            except Exception as e:
                logger.error(f"Failed to send candidate feedback to admin {task['manager_id']}: {e}")

    await send_or_edit_message(update, context, "Спасибо большое за обратную связь! Она поможет нам стать лучше. 🙏")

    return ConversationHandler.END


candidate_feedback_conversation_handler = ConversationHandler(
    entry_points=[
        CallbackQueryHandler(start_candidate_feedback, pattern=f"^{settings.CALLBACK_START_CANDIDATE_FEEDBACK}$")],
    states={
        CandidateFeedbackState.AWAITING_IMPRESSION: [CallbackQueryHandler(impression_received, pattern="^cand_rate_"),
                                                     MessageHandler(filters.TEXT, prompt_to_use_button)],
        CandidateFeedbackState.AWAITING_CONDITIONS_MET: [
            CallbackQueryHandler(conditions_met_received, pattern="^(yes|no)$"),
            MessageHandler(filters.TEXT, prompt_to_use_button)],
        CandidateFeedbackState.AWAITING_REQUIREMENTS_CLEAR: [
            CallbackQueryHandler(requirements_clear_received, pattern="^(yes|no)$"),
            MessageHandler(filters.TEXT, prompt_to_use_button)],
        CandidateFeedbackState.AWAITING_ADDITIONAL_COMMENTS: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, additional_comments_received)],
    },
    fallbacks=[CommandHandler("cancel", cancel)],
    name="candidate_feedback_conv",
    persistent=True,
    per_message=False,
)

--- FILE: handlers/onboarding.py ---
import html
import logging
import asyncio

from telegram import Update, ReplyKeyboardRemove
from telegram.ext import (
    ContextTypes,
    ConversationHandler,
    CommandHandler,
    MessageHandler,
    CallbackQueryHandler,
    filters,
)
from telegram.constants import ParseMode

from models import OnboardingState
from core import settings, database, stickers
from utils.helpers import (
    get_user_data_from_update,
    safe_answer_callback_query,
    send_or_edit_message,
    add_to_sheets_queue,
    add_user_to_interacted,
    get_now,
    format_user_for_sheets,
    remove_keyboard_from_previous_message
)
from utils.keyboards import (
    RESTAURANT_OPTIONS,
    ONBOARDING_POSITION_OPTIONS,
    POSITION_LINKS,
    INTEREST_RATING_OPTIONS,
    build_inline_keyboard
)
from handlers.common import cancel, prompt_to_use_button

logger = logging.getLogger(__name__)


async def start_onboarding_flow(update: Update, context: ContextTypes.DEFAULT_TYPE) -> OnboardingState:
    user_id, user_name, _ = get_user_data_from_update(update)
    await add_user_to_interacted(user_id, context)
    context.user_data.clear()

    logger.info(f"User {user_name} ({user_id}) started onboarding flow.")

    restaurant_code = ""
    restaurant_name = "Не указан"

    if update.callback_query:
        restaurant_code = await database.get_candidate_restaurant(user_id) or ""
        restaurant_name = next((name for name, code in RESTAURANT_OPTIONS if code.endswith(restaurant_code)),
                               "Не указан")
    else:
        param = context.args[0] if context.args else ""
        if not param or not param.startswith("onboard_"):
            if update.message:
                await update.message.reply_text("Ошибка в ссылке. Пожалуйста, обратитесь к менеджеру.")
            return ConversationHandler.END
        restaurant_code = param.replace("onboard_", "")
        restaurant_name = next((name for name, r_code in RESTAURANT_OPTIONS if r_code.endswith(restaurant_code)),
                               "Не указан")

    if restaurant_name == "Не указан":
        if update.effective_message:
            await update.effective_message.reply_text(
                "Не удалось определить ресторан. Пожалуйста, обратитесь к менеджеру.")
        return ConversationHandler.END

    context.user_data['onboarding_restaurant'] = restaurant_name
    context.user_data['onboarding_restaurant_code'] = restaurant_code
    context.user_data['chat_id'] = update.effective_chat.id

    if not update.callback_query:
        await context.bot.send_sticker(chat_id=user_id, sticker=stickers.GREETING_TEAM)
        await asyncio.sleep(0.5)

    keyboard = build_inline_keyboard(ONBOARDING_POSITION_OPTIONS, columns=2)
    message_text = (
        f"Поздравляем с первой сменой в «Марчеллис»! 🎉\n\n"
        f"Ты начинаешь свой путь в ресторане: <b>{html.escape(restaurant_name)}</b>.\n\n"
        "Первое впечатление — самое важное, и мы очень хотим его узнать!\n\n"
        "<b>Шаг 1/4:</b> Напомни, пожалуйста, на какую должность ты к нам присоединился(ась)?"
    )

    sent_message = await update.effective_message.reply_text(message_text, parse_mode=ParseMode.HTML,
                                                             reply_markup=keyboard)
    context.user_data[settings.ACTIVE_MESSAGE_ID_KEY] = sent_message.message_id

    return OnboardingState.POSITION


async def position_selected(update: Update, context: ContextTypes.DEFAULT_TYPE) -> OnboardingState:
    query = update.callback_query
    await safe_answer_callback_query(query)

    if query.data == "onboard_pos_Other":
        await send_or_edit_message(update, context, "Пожалуйста, напиши свою должность:")
        return OnboardingState.AWAIT_OTHER_POSITION

    chosen_button = next((b for b in ONBOARDING_POSITION_OPTIONS if b[1] == query.data), None)
    position = chosen_button[0] if chosen_button else "Не указана"
    context.user_data["onboarding_position"] = position

    message_text = (
        f"Позиция: <b>{html.escape(position)}</b>. ✨\n\n"
        "<b>Шаг 2/4:</b>\n"
        "Поделись своим <b>первым впечатлением</b> после ознакомительной смены! Что понравилось, что удивило?"
    )
    await send_or_edit_message(update, context, message_text)
    return OnboardingState.IMPRESSION


async def other_position_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> OnboardingState:
    position = update.message.text.strip()
    context.user_data["onboarding_position"] = position
    context.user_data["onboarding_position_is_other"] = True

    message_text = (
        f"Позиция: <b>{html.escape(position)}</b>. ✨\n\n"
        "<b>Шаг 2/4:</b>\n"
        "Поделись своим <b>первым впечатлением</b> после ознакомительной смены! Что понравилось, что удивило?"
    )
    await send_or_edit_message(update, context, message_text)
    return OnboardingState.IMPRESSION


async def impression_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> OnboardingState:
    context.user_data["onboarding_impression"] = update.message.text.strip()
    keyboard = build_inline_keyboard(INTEREST_RATING_OPTIONS, columns=5)
    text = (
        "Спасибо за отзыв!\n\n"
        "<b>Шаг 3/4:</b>\n"
        "А теперь оцени свою <b>заинтересованность</b> в продолжении стажировки у нас по шкале от 1 (совсем не интересно) до 10 (очень хочу продолжить)."
    )
    await send_or_edit_message(update, context, text, keyboard)
    return OnboardingState.INTEREST_RATING


async def interest_rating_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> OnboardingState:
    query = update.callback_query
    await safe_answer_callback_query(query)
    rating = query.data.replace("onboard_rate_", "")
    context.user_data["onboarding_interest_level"] = rating
    text = (
        f"Твоя оценка: <b>{rating}</b>. Принято!\n\n"
        "<b>Шаг 4/4:</b>\n"
        "Что больше всего <b>повлияло на твою оценку</b>?"
    )
    await send_or_edit_message(update, context, text, None)
    return OnboardingState.INTEREST_REASON


async def interest_reason_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    context.user_data["onboarding_interest_reason"] = update.message.text.strip()
    user_id, user_name, _ = get_user_data_from_update(update)
    user = update.effective_user
    data = context.user_data
    restaurant_code = data.get("onboarding_restaurant_code")
    is_other_position = data.get("onboarding_position_is_other", False)
    user_link = format_user_for_sheets(user_id, user_name, user.username)

    row_data = [
        get_now().strftime("%Y-%m-%d %H:%M:%S"),
        user_link,
        data.get("onboarding_restaurant"),
        data.get("onboarding_position"),
        data.get("onboarding_impression"),
        data.get("onboarding_interest_level"),
        data.get("onboarding_interest_reason")
    ]
    await add_to_sheets_queue(settings.ONBOARDING_SHEET_NAME, row_data)
    await database.log_survey_completion('onboarding', user_id, restaurant_code)

    # --- Start: Notify Admins ---
    interest_level_str = data.get("onboarding_interest_level", "0")
    message_title = "📝 <b>Новый отзыв после ознакомительной смены</b>"
    try:
        if int(interest_level_str) < 6:
            message_title = f"❗️🚩 <b>Низкая заинтересованность после смены! ({interest_level_str}/10)</b>"
    except (ValueError, TypeError):
        pass  # If conversion fails, use the default title

    admin_message = (
        f"{message_title}\n\n"
        f"<b>Кандидат:</b> {html.escape(user_name)}\n"
        f"<b>Ресторан:</b> {html.escape(data.get('onboarding_restaurant', 'N/A'))}\n"
        f"<b>Должность:</b> {html.escape(data.get('onboarding_position', 'N/A'))}\n\n"
        f"<b>⭐ Уровень интереса:</b> {interest_level_str}/10\n"
        f"<b>💬 Причина оценки:</b>\n<pre>{html.escape(data.get('onboarding_interest_reason', 'N/A'))}</pre>\n\n"
        f"<b>📝 Впечатление от смены:</b>\n<pre>{html.escape(data.get('onboarding_impression', 'N/A'))}</pre>"
    )

    if settings.ADMIN_IDS:
        for admin_id in settings.ADMIN_IDS:
            try:
                await context.bot.send_message(
                    chat_id=admin_id,
                    text=admin_message,
                    parse_mode=ParseMode.HTML
                )
            except Exception as e:
                logger.error(f"Failed to send onboarding feedback summary to admin {admin_id}: {e}")
    # --- End: Notify Admins ---


    await send_or_edit_message(update, context, "Обрабатываем твой ответ...")
    await remove_keyboard_from_previous_message(context, user_id)

    position = "Другое" if is_other_position else data.get("onboarding_position", "сотрудника")
    links_data = POSITION_LINKS.get(position, [])
    critical_links = [item for item in links_data if item.get("is_critical")]
    other_links = [item for item in links_data if not item.get("is_critical") and "url" in item]
    additional_message = next((item.get("additional_message") for item in links_data if "additional_message" in item),
                              "Желаем тебе успешного старта и увлекательной адаптации!")
    final_position_text = data.get("onboarding_position")

    final_message_parts = [
        f"🎉 <b>Спасибо за обратную связь! Добро пожаловать в команду!</b>\n\n"
        f"Вот несколько полезных ссылок для позиции '<b>{html.escape(final_position_text)}</b>':\n"
    ]

    if critical_links:
        final_message_parts.append("\n<b>❗️ Обязательно к изучению:</b>")
        for link in critical_links:
            final_message_parts.append(f"🔗 <a href='{link['url']}'>{html.escape(link['name'])}</a>")

    if other_links:
        final_message_parts.append("\n<b>Полезные материалы:</b>")
        for link in other_links:
            final_message_parts.append(f"🔗 <a href='{link['url']}'>{html.escape(link['name'])}</a>")

    final_message_parts.append(f"\n\n🔔 <b>Важный момент:</b> {html.escape(additional_message)}\n\n")

    final_message = "\n".join(final_message_parts)

    await context.bot.send_sticker(chat_id=user_id, sticker=stickers.ONBOARDING_INFO_DOG)
    await asyncio.sleep(0.5)
    await context.bot.send_message(
        user_id,
        final_message,
        parse_mode=ParseMode.HTML,
        disable_web_page_preview=True
    )

    context.user_data.clear()
    return ConversationHandler.END


onboarding_conversation_handler = ConversationHandler(
    entry_points=[CommandHandler("start", start_onboarding_flow, filters=filters.Regex(r'onboard_'))],
    states={
        OnboardingState.POSITION: [
            CallbackQueryHandler(position_selected, pattern="^onboard_pos_"),
            MessageHandler(filters.TEXT & ~filters.COMMAND, prompt_to_use_button)
        ],
        OnboardingState.AWAIT_OTHER_POSITION: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, other_position_received)],
        OnboardingState.IMPRESSION: [MessageHandler(filters.TEXT & ~filters.COMMAND, impression_received)],
        OnboardingState.INTEREST_RATING: [
            CallbackQueryHandler(interest_rating_received, pattern="^onboard_rate_"),
            MessageHandler(filters.TEXT & ~filters.COMMAND, prompt_to_use_button)
        ],
        OnboardingState.INTEREST_REASON: [MessageHandler(filters.TEXT & ~filters.COMMAND, interest_reason_received)],
    },
    fallbacks=[CommandHandler("cancel", cancel)],
    name="onboarding_conv",
    persistent=True,
    per_message=False,
    conversation_timeout=settings.CONVERSATION_TIMEOUT_SECONDS
)

--- FILE: handlers/bot_feedback.py ---
import html
import logging

from telegram import Update, InlineKeyboardMarkup, InlineKeyboardButton
from telegram.ext import (
    ContextTypes,
    ConversationHandler,
    CallbackQueryHandler,
    MessageHandler,
    CommandHandler,
    filters,
)
from telegram.constants import ParseMode

from models import MainMenuState
from core import settings
from utils.helpers import get_user_data_from_update, add_to_sheets_queue, get_now, safe_answer_callback_query, \
    send_or_edit_message
from handlers.common import cancel

logger = logging.getLogger(__name__)

SELECT_TYPE, AWAIT_DESCRIPTION = range(2)

FEEDBACK_TYPES = {
    "fb_bug": "Ошибка (Баг)",
    "fb_suggestion": "Предложение",
    "fb_other": "Другое"
}


async def start_feedback_submission(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await safe_answer_callback_query(query)
    context.user_data[settings.ACTIVE_MESSAGE_ID_KEY] = query.message.message_id

    keyboard = [
        [InlineKeyboardButton("🐞 Ошибка (Баг)", callback_data="fb_bug")],
        [InlineKeyboardButton("💡 Предложение", callback_data="fb_suggestion")],
        [InlineKeyboardButton("📋 Другое", callback_data="fb_other")],
    ]

    text = ("Спасибо, что помогаете нам стать лучше! 🙏\n\n"
            "Пожалуйста, выберите тип вашей обратной связи:")

    await send_or_edit_message(update, context, text, InlineKeyboardMarkup(keyboard))
    return SELECT_TYPE


async def type_selected(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await safe_answer_callback_query(query)

    feedback_type_code = query.data
    feedback_type_text = FEEDBACK_TYPES.get(feedback_type_code, "Не определено")
    context.user_data['feedback_type'] = feedback_type_text

    text = (f"Вы выбрали: <b>{feedback_type_text}</b>.\n\n"
            "Теперь, пожалуйста, опишите подробно вашу мысль в одном сообщении. "
            "Если это ошибка, опишите шаги для ее воспроизведения.")

    await send_or_edit_message(update, context, text)
    return AWAIT_DESCRIPTION


async def description_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    description = update.message.text
    feedback_type = context.user_data.get('feedback_type', 'Не определено')
    user_id, user_name, _ = get_user_data_from_update(update)
    timestamp = get_now().strftime("%Y-%m-%d %H:%M:%S")

    row_data = [timestamp, user_name, user_id, feedback_type, description, "Новое"]
    await add_to_sheets_queue(settings.BOT_FEEDBACK_SHEET_NAME, row_data)

    text = "✅ Ваше сообщение принято! Спасибо за ваш вклад. Мы рассмотрим его в ближайшее время."
    await send_or_edit_message(update, context, text)

    context.user_data.clear()
    return ConversationHandler.END


feedback_submission_handler = ConversationHandler(
    entry_points=[CallbackQueryHandler(start_feedback_submission, pattern="^submit_bot_feedback$")],
    states={
        SELECT_TYPE: [CallbackQueryHandler(type_selected, pattern="^fb_")],
        AWAIT_DESCRIPTION: [MessageHandler(filters.TEXT & ~filters.COMMAND, description_received)],
    },
    fallbacks=[CommandHandler('cancel', cancel)],
    name="bot_feedback_conv",
    per_user=True,
    per_chat=True,
    per_message=False,
)

--- FILE: handlers/exit_interview.py ---
import html
import time
import logging
import asyncio
from datetime import timedelta

from telegram import Update, ReplyKeyboardRemove, InlineKeyboardMarkup, InlineKeyboardButton
from telegram.ext import (
    ContextTypes,
    ConversationHandler,
    CommandHandler,
    MessageHandler,
    CallbackQueryHandler,
    ChatMemberHandler,
    filters,
)
from telegram.constants import ParseMode, ChatMemberStatus
from telegram.error import Forbidden, BadRequest

from models import ExitState
from core import settings, database, stickers
from utils.helpers import (
    get_user_data_from_update,
    safe_answer_callback_query,
    send_or_edit_message,
    add_to_sheets_queue,
    get_now,
    remove_keyboard_from_previous_message
)
from utils.keyboards import (
    RESTAURANT_OPTIONS,
    EXIT_POSITION_OPTIONS,
    DURATION_OPTIONS,
    RATING_OPTIONS,
    TRAINING_OPTIONS,
    FEEDBACK_OPTIONS,
    build_inline_keyboard
)
from handlers.common import cancel

logger = logging.getLogger(__name__)


async def schedule_exit_interview_reminder(context: ContextTypes.DEFAULT_TYPE):
    job_data = context.job.data
    user_id = job_data["user_id"]
    first_check = job_data.get("first_check", True)

    if await database.is_survey_completed("exit", user_id):
        logger.info(f"User {user_id} has already completed the exit interview. Reminder job cancelled.")
        return

    if first_check:
        logger.info(f"User {user_id} did not complete exit interview after 3 days. Sending reminder.")
        try:
            keyboard = InlineKeyboardMarkup(
                [[InlineKeyboardButton("👋 Да, готов(а) помочь", callback_data=settings.CALLBACK_START_EXIT)]])
            await context.bot.send_message(
                user_id,
                "Привет! Напоминаем о нашей просьбе пройти небольшой опрос после увольнения. Твой опыт очень важен для нас! 🙏",
                reply_markup=keyboard
            )
            context.job_queue.run_once(
                schedule_exit_interview_reminder,
                when=timedelta(days=3),
                data={"user_id": user_id, "first_check": False},
                name=f"exit_delete_check_{user_id}"
            )
        except (Forbidden, BadRequest):
            logger.warning(f"Could not send exit interview reminder to {user_id}. Deleting user data now.")
            await database.delete_user_data(user_id)
    else:
        logger.warning(f"User {user_id} did not complete exit interview after another 3 days. Deleting user data.")
        await database.delete_user_data(user_id)


async def handle_chat_member(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not update.chat_member or not update.chat_member.new_chat_member or not update.chat_member.new_chat_member.user:
        return

    member_update = update.chat_member
    target_user = member_update.new_chat_member.user

    if not target_user or target_user.id == context.bot.id:
        return

    new_status = member_update.new_chat_member.status
    if new_status not in (ChatMemberStatus.LEFT, ChatMemberStatus.BANNED):
        return

    target_user_id = target_user.id
    target_user_name = target_user.full_name

    logger.info(f"User {target_user_name} ({target_user_id}) left or was banned from chat {member_update.chat.title}.")

    users_interacted = context.bot_data.get("users_interacted", set())
    if target_user_id not in users_interacted:
        logger.info(f"User {target_user_id} has not interacted with the bot before. Skipping exit interview invite.")
        return

    if context.job_queue.get_jobs_by_name(f"exit_reminder_{target_user_id}"):
        logger.info(f"Exit interview flow is already active for user {target_user_id}. Ignoring new event.")
        return

    try:
        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("Да, это связано с увольнением", callback_data=settings.CALLBACK_CONFIRM_QUIT)],
            [InlineKeyboardButton("Нет, просто вышел(а) из чата", callback_data=settings.CALLBACK_DECLINE_QUIT)],
        ])
        await context.bot.send_message(
            chat_id=target_user_id,
            text="Привет! 👋 Заметили, что ты покинул(а) наш рабочий чат.\n\n"
                 "Если это связано с увольнением, мы будем очень благодарны за обратную связь. Если нет — просто нажми вторую кнопку.",
            reply_markup=keyboard
        )
        logger.info(f"Sent exit clarification to user {target_user_name} (ID: {target_user_id}).")

        context.job_queue.run_once(
            schedule_exit_interview_reminder,
            when=timedelta(days=3),
            data={"user_id": target_user_id, "first_check": True},
            name=f"exit_reminder_{target_user_id}"
        )

    except (Forbidden, BadRequest):
        logger.warning(f"Failed to send exit clarification to user {target_user_id} (Forbidden/BadRequest).")
    except Exception as e:
        logger.error(f"Error sending exit clarification to user {target_user_id}: {e}", exc_info=True)


async def remove_exit_jobs(user_id: int, context: ContextTypes.DEFAULT_TYPE):
    jobs_reminder = context.job_queue.get_jobs_by_name(f"exit_reminder_{user_id}")
    jobs_delete = context.job_queue.get_jobs_by_name(f"exit_delete_check_{user_id}")
    for job in jobs_reminder + jobs_delete:
        job.schedule_removal()
    logger.info(f"Removed exit interview reminder/deletion jobs for user {user_id}.")


async def handle_quit_clarification(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await safe_answer_callback_query(query)
    if not query.message:
        return

    user_id = query.from_user.id
    context.user_data[settings.ACTIVE_MESSAGE_ID_KEY] = query.message.message_id

    if query.data == settings.CALLBACK_CONFIRM_QUIT:
        keyboard = InlineKeyboardMarkup(
            [[InlineKeyboardButton("👋 Да, готов(а) помочь", callback_data=settings.CALLBACK_START_EXIT)]])
        text = ("Нам будет тебя не хватать... 🙏\n\n"
                "Любое прощание — это немного грустно, но мы уважаем твой выбор и желаем огромной удачи на новом пути! "
                "Спасибо за всё, что ты сделал(а) для команды «Марчеллис». Твой опыт очень ценен для нас.\n\n"
                "Если не сложно, удели, пожалуйста, <b>пару минут</b> и ответь на 9 анонимных вопросов. Это поможет нам стать лучше для будущих коллег ✨\n\n"
                "Готов(а) начать?")
        await send_or_edit_message(update, context, text, keyboard)
        context.user_data['chat_id'] = query.message.chat_id

    elif query.data == settings.CALLBACK_DECLINE_QUIT:
        await remove_exit_jobs(user_id, context)
        await send_or_edit_message(update, context, "Понятно! Спасибо за уточнение. Хорошего дня! 😊")


async def start_exit_interview_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> ExitState:
    query = update.callback_query
    await safe_answer_callback_query(query)
    context.user_data.clear()
    context.user_data['_in_exit_interview'] = True
    context.user_data['chat_id'] = query.message.chat_id

    await send_or_edit_message(update, context, "Спасибо тебе за готовность помочь! 🙏 Давай начнем.", None)

    await asyncio.sleep(1)

    keyboard = build_inline_keyboard(RESTAURANT_OPTIONS, columns=2)
    text = "<b>Вопрос 1/9</b>\nВ каком <b>ресторане</b> ты работал(а) в последнее время?"
    await send_or_edit_message(update, context, text, keyboard)

    return ExitState.RESTAURANT


async def exit_restaurant_chosen(update: Update, context: ContextTypes.DEFAULT_TYPE) -> ExitState:
    query = update.callback_query
    await safe_answer_callback_query(query)
    restaurant = next((b[0] for b in RESTAURANT_OPTIONS if b[1] == query.data), "N/A")
    restaurant_code = query.data.replace("res_", "")
    context.user_data["exit_restaurant"] = restaurant
    context.user_data["exit_restaurant_code"] = restaurant_code
    keyboard = build_inline_keyboard(EXIT_POSITION_OPTIONS, columns=2)
    text = f"Ресторан: <b>{html.escape(restaurant)}</b>.\n\n<b>Вопрос 2/9</b>\nНа какой <b>должности</b> ты работал(а)?"
    await send_or_edit_message(update, context, text, keyboard)
    return ExitState.POSITION


async def exit_position_chosen(update: Update, context: ContextTypes.DEFAULT_TYPE) -> ExitState:
    query = update.callback_query
    await safe_answer_callback_query(query)
    position = next((b[0] for b in EXIT_POSITION_OPTIONS if b[1] == query.data), "N/A")
    context.user_data["exit_position"] = position
    keyboard = build_inline_keyboard(DURATION_OPTIONS, columns=3)
    text = f"Должность: <b>{html.escape(position)}</b>.\n\n<b>Вопрос 3/9</b>\nКак <b>долго</b> ты проработал(а) в нашей компании?"
    await send_or_edit_message(update, context, text, keyboard)
    return ExitState.DURATION


async def exit_duration_chosen(update: Update, context: ContextTypes.DEFAULT_TYPE) -> ExitState:
    query = update.callback_query
    await safe_answer_callback_query(query)
    duration = next((b[0] for b in DURATION_OPTIONS if b[1] == query.data), "N/A")
    context.user_data["exit_duration"] = duration
    text = f"Стаж: <b>{html.escape(duration)}</b>.\n\n<b>Вопрос 4/9</b>\nЧто стало <b>основной причиной</b> твоего решения уйти? (Будем благодарны за честный ответ)"
    await send_or_edit_message(update, context, text)
    return ExitState.AWAITING_REASON


async def exit_reason_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> ExitState:
    context.user_data["exit_reason"] = update.message.text.strip()
    text = "Спасибо!\n\n" \
           "<b>Вопрос 5/9</b>\nЧто, по-твоему, можно было бы <b>улучшить</b> в нашей работе или процессах?"
    await send_or_edit_message(update, context, text)
    return ExitState.AWAITING_IMPROVEMENT


async def exit_improvement_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> ExitState:
    context.user_data["exit_improvement"] = update.message.text.strip()
    keyboard = build_inline_keyboard(RATING_OPTIONS, columns=3)
    text = "Отличные идеи, спасибо!\n\n" \
           "<b>Вопрос 6/9</b>\nКак бы ты оценил(а) взаимоотношения и <b>поддержку</b> со стороны твоего <b>непосредственного руководителя</b>?"
    await send_or_edit_message(update, context, text, keyboard)
    return ExitState.LEADERSHIP


async def exit_leadership_rated(update: Update, context: ContextTypes.DEFAULT_TYPE) -> ExitState:
    query = update.callback_query
    await safe_answer_callback_query(query)
    rating = next((b[0] for b in RATING_OPTIONS if b[1] == query.data), "N/A")
    context.user_data["exit_leadership_rating"] = rating
    keyboard = build_inline_keyboard(TRAINING_OPTIONS, columns=2)
    text = f"Оценка руководителю: <b>{html.escape(rating)}</b>.\n\n<b>Вопрос 7/9</b>\nНасколько <b>достаточным</b> было <b>обучение</b>, которое ты получил(а) для работы?"
    await send_or_edit_message(update, context, text, keyboard)
    return ExitState.TRAINING


async def exit_training_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> ExitState:
    query = update.callback_query
    await safe_answer_callback_query(query)
    training = next((b[0] for b in TRAINING_OPTIONS if b[1] == query.data), "N/A")
    context.user_data["exit_training_rating"] = training
    keyboard = build_inline_keyboard(FEEDBACK_OPTIONS, columns=2)
    text = f"Оценка обучения: <b>{html.escape(training)}</b>.\n\n<b>Вопрос 8/9</b>\nКак часто ты получал(а) <b>обратную связь</b> о своей работе?"
    await send_or_edit_message(update, context, text, keyboard)
    return ExitState.FEEDBACK


async def exit_feedback_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> ExitState:
    query = update.callback_query
    await safe_answer_callback_query(query)
    feedback = next((b[0] for b in FEEDBACK_OPTIONS if b[1] == query.data), "N/A")
    context.user_data["exit_feedback_freq"] = feedback
    text = f"Частота обратной связи: <b>{html.escape(feedback)}</b>. Остался последний шаг! 🏁\n\n<b>Вопрос 9/9</b>\nЕсть ли <b>что-то еще</b>, что ты хотел(а) бы добавить или пожелать бывшим коллегам?"
    await send_or_edit_message(update, context, text)
    return ExitState.AWAITING_COMMENTS


async def exit_comments_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    context.user_data["exit_comments"] = update.message.text.strip()
    user_id, user_name, _ = get_user_data_from_update(update)
    data = context.user_data
    restaurant_code = data.get("exit_restaurant_code")
    timestamp = get_now().strftime("%Y-%m-%d %H:%M:%S")
    row_data = [
        timestamp, user_name, data.get("exit_restaurant", "N/A"), data.get("exit_position", "N/A"),
        data.get("exit_duration", "N/A"), data.get("exit_reason", "N/A"), data.get("exit_improvement", "N/A"),
        data.get("exit_leadership_rating", "N/A"), data.get("exit_training_rating", "N/A"),
        data.get("exit_feedback_freq", "N/A"), data.get("exit_comments", "N/A")
    ]

    await add_to_sheets_queue(settings.EXIT_INTERVIEW_SHEET_NAME, row_data)
    await database.log_survey_completion('exit', user_id, restaurant_code)
    await database.deactivate_employee(user_id)
    await remove_exit_jobs(user_id, context)

    admin_message = (
        f"🚶‍♂️ <b>Сотрудник прошел Exit-интервью</b>\n\n"
        f"<b>Имя:</b> {html.escape(user_name)}\n"
        f"<b>Ресторан:</b> {html.escape(data.get('exit_restaurant', 'N/A'))}\n"
        f"<b>Должность:</b> {html.escape(data.get('exit_position', 'N/A'))}\n"
        f"<b>Стаж:</b> {html.escape(data.get('exit_duration', 'N/A'))}\n\n"
        f"<b>Основная причина ухода:</b>\n<pre>{html.escape(data.get('exit_reason', 'N/A'))}</pre>\n\n"
        f"<i>Сотрудник автоматически помечен как неактивный. Данные записаны в Google-таблицу.</i>"
    )
    for admin_id in settings.ADMIN_IDS:
        try:
            await context.bot.send_message(admin_id, admin_message, parse_mode=ParseMode.HTML)
        except Exception as e:
            logger.error(f"Failed to send exit interview summary to admin {admin_id}: {e}")


    final_text = "✅ <b>Опрос завершен!</b>\n\nБольшое спасибо тебе за уделенное время и честные ответы! 🙏\nЖелаем тебе огромных успехов на новом пути! ✨"
    await send_or_edit_message(update, context, final_text)

    await asyncio.sleep(0.5)
    await context.bot.send_sticker(chat_id=user_id, sticker=stickers.SUCCESS_DOG)

    context.user_data.clear()
    return ConversationHandler.END


chat_member_handler = ChatMemberHandler(handle_chat_member, ChatMemberHandler.CHAT_MEMBER)
quit_clarification_handler = CallbackQueryHandler(
    handle_quit_clarification, pattern=f"^({settings.CALLBACK_CONFIRM_QUIT}|{settings.CALLBACK_DECLINE_QUIT})$"
)

exit_interview_conversation_handler = ConversationHandler(
    entry_points=[CallbackQueryHandler(start_exit_interview_callback, pattern=f"^{settings.CALLBACK_START_EXIT}$")],
    states={
        ExitState.RESTAURANT: [CallbackQueryHandler(exit_restaurant_chosen, pattern="^res_")],
        ExitState.POSITION: [CallbackQueryHandler(exit_position_chosen, pattern="^exit_pos_")],
        ExitState.DURATION: [CallbackQueryHandler(exit_duration_chosen, pattern="^dur_")],
        ExitState.AWAITING_REASON: [MessageHandler(filters.TEXT & ~filters.COMMAND, exit_reason_received)],
        ExitState.AWAITING_IMPROVEMENT: [MessageHandler(filters.TEXT & ~filters.COMMAND, exit_improvement_received)],
        ExitState.LEADERSHIP: [CallbackQueryHandler(exit_leadership_rated, pattern="^rate_")],
        ExitState.TRAINING: [CallbackQueryHandler(exit_training_received, pattern="^train_")],
        ExitState.FEEDBACK: [CallbackQueryHandler(exit_feedback_received, pattern="^feed_")],
        ExitState.AWAITING_COMMENTS: [MessageHandler(filters.TEXT & ~filters.COMMAND, exit_comments_received)],
    },
    fallbacks=[CommandHandler("cancel", cancel)],
    name="exit_interview_conv",
    persistent=True,
    per_message=False,
    conversation_timeout=settings.CONVERSATION_TIMEOUT_SECONDS
)

--- FILE: handlers/admin.py ---
import asyncio
import html
import logging
import math
from collections import defaultdict

from telegram import Update, InlineKeyboardMarkup, InlineKeyboardButton
from telegram.ext import (
    ContextTypes,
    CallbackQueryHandler,
    MessageHandler,
    filters,
    ConversationHandler
)
from telegram.constants import ParseMode
from telegram.error import BadRequest, Forbidden

from models import AdminState, MainMenuState
from core import settings, database
from utils.helpers import (
    safe_answer_callback_query,
    get_id_from_input,
    send_new_menu_message,
    send_or_edit_message,
    set_user_commands
)
from utils.keyboards import (
    RESTAURANT_OPTIONS,
    get_admin_menu_keyboard,
)

logger = logging.getLogger(__name__)


async def edit_admin_message(query: Update.callback_query, text: str, reply_markup: InlineKeyboardMarkup):
    try:
        await query.edit_message_text(text=text, reply_markup=reply_markup, parse_mode=ParseMode.HTML)
    except BadRequest as e:
        if "Message is not modified" not in str(e):
            logger.warning(f"Failed to edit admin message: {e}")


async def admin_panel_start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> AdminState:
    user = update.effective_user
    keyboard = get_admin_menu_keyboard()
    text = f"Ciao, {html.escape(user.first_name)}! 👋\n\nДобро пожаловать в панель администратора. Выбери действие:"
    if update.callback_query:
        await safe_answer_callback_query(update.callback_query)
        await edit_admin_message(update.callback_query, text, keyboard)
    else:
        await send_new_menu_message(context, user.id, text, keyboard)
    return AdminState.MENU


async def manage_managers_start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> AdminState:
    query = update.callback_query
    await safe_answer_callback_query(query)
    keyboard = InlineKeyboardMarkup([
        [InlineKeyboardButton("➕ Добавить менеджера", callback_data="admin_add_manager_start")],
        [InlineKeyboardButton("➖ Удалить менеджера", callback_data="admin_remove_manager_start")],
        [InlineKeyboardButton("📋 Показать список", callback_data="admin_list_managers")],
        [InlineKeyboardButton("⬅️ Назад", callback_data=settings.CALLBACK_ADMIN_BACK)],
    ])
    text = "Управление менеджерами:"
    await edit_admin_message(query, text, keyboard)
    return AdminState.MANAGE_MANAGERS


async def manage_employees_start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> AdminState:
    query = update.callback_query
    await safe_answer_callback_query(query)
    button_rows_data = [RESTAURANT_OPTIONS[i:i + 2] for i in range(0, len(RESTAURANT_OPTIONS), 2)]
    keyboard_layout = [
        [InlineKeyboardButton(text, callback_data=f"list_emp_{data}_page_0") for text, data in row_data]
        for row_data in button_rows_data
    ]
    keyboard_layout.append([InlineKeyboardButton("⬅️ Назад в меню", callback_data=settings.CALLBACK_ADMIN_BACK)])
    keyboard = InlineKeyboardMarkup(keyboard_layout)
    text = "👥 Выберите ресторан для просмотра и управления списком сотрудников:"
    await edit_admin_message(query, text, keyboard)
    return AdminState.CHOOSE_EMPLOYEE_RESTAURANT


async def show_employees_paginated(update: Update, context: ContextTypes.DEFAULT_TYPE) -> AdminState:
    query = update.callback_query
    await safe_answer_callback_query(query)
    parts = query.data.split('_')
    res_code_suffix = parts[3]
    page = int(parts[5])

    total_employees = await database.count_employees_in_restaurant(res_code_suffix)
    if total_employees == 0 and page == 0:
        await query.answer("В этом ресторане нет сотрудников.", show_alert=True)
        return await manage_employees_start(update, context)

    employees = await database.get_employees_paginated(res_code_suffix, page, settings.EMPLOYEES_PER_PAGE)
    res_name = next((name for name, code in RESTAURANT_OPTIONS if code.endswith(res_code_suffix)), res_code_suffix)
    total_pages = math.ceil(total_employees / settings.EMPLOYEES_PER_PAGE) if total_employees > 0 else 1

    buttons = []
    text = f"<b>Сотрудники «{html.escape(res_name)}»</b> (Стр. {page + 1}/{total_pages})"
    for emp in employees:
        status_icon = "✅" if emp['is_active'] else "⚪️"
        button_text = f"{status_icon} {html.escape(emp['full_name'] or f'User {emp['user_id']}')}"
        callback_data = f"adm_tgl_emp_{emp['user_id']}_res_{res_code_suffix}_page_{page}"
        buttons.append([InlineKeyboardButton(button_text, callback_data=callback_data)])
    nav_buttons = []
    if page > 0:
        nav_buttons.append(InlineKeyboardButton("<< 1", callback_data=f"list_emp_res_{res_code_suffix}_page_0"))
        nav_buttons.append(
            InlineKeyboardButton(f"< {page}", callback_data=f"list_emp_res_{res_code_suffix}_page_{page - 1}"))
    if page + 1 < total_pages:
        nav_buttons.append(
            InlineKeyboardButton(f"{page + 2} >", callback_data=f"list_emp_res_{res_code_suffix}_page_{page + 1}"))
        nav_buttons.append(InlineKeyboardButton(f"{total_pages} >>",
                                                callback_data=f"list_emp_res_{res_code_suffix}_page_{total_pages - 1}"))

    if nav_buttons:
        buttons.append(nav_buttons)
    buttons.append([InlineKeyboardButton("⬅️ К выбору ресторана", callback_data="admin_manage_employees")])
    await edit_admin_message(query, text, InlineKeyboardMarkup(buttons))
    return AdminState.LIST_EMPLOYEES_PAGINATED


async def toggle_employee_status_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> AdminState:
    query = update.callback_query
    await safe_answer_callback_query(query)
    parts = query.data.split('_')
    user_id = int(parts[3])
    await database.toggle_employee_status(user_id)
    await query.answer("Статус сотрудника изменен.")
    return await show_employees_paginated(update, context)


async def get_manager_info_text() -> str:
    managers_map = await database.get_all_managers_by_restaurant()
    if not managers_map: return "Список менеджеров пуст."
    report_parts = ["<b>📋 Актуальный список менеджеров:</b>\n"]
    for res_code_suffix, managers in sorted(managers_map.items()):
        res_name = next((name for name, code in RESTAURANT_OPTIONS if code.endswith(res_code_suffix)), res_code_suffix)
        report_parts.append(f"\n<b>📍 {html.escape(res_name)}:</b>")
        for manager in managers:
            user_mention = manager.get('full_name', 'Имя не указано')
            if manager.get('username'): user_mention += f" (@{manager['username']})"
            report_parts.append(f"  - <a href='tg://user?id={manager['user_id']}'>{html.escape(user_mention)}</a>")
    return "\n".join(report_parts)


async def list_managers(update: Update, context: ContextTypes.DEFAULT_TYPE) -> AdminState:
    query = update.callback_query
    await safe_answer_callback_query(query)
    await edit_admin_message(query, "Загрузка...", None)
    keyboard = InlineKeyboardMarkup([
        [InlineKeyboardButton("⬅️ Назад", callback_data="admin_manage_managers")]
    ])
    await edit_admin_message(query, await get_manager_info_text(), keyboard)
    return AdminState.MANAGE_MANAGERS


async def remove_manager_start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> AdminState:
    query = update.callback_query
    await safe_answer_callback_query(query)
    await edit_admin_message(query, "Загрузка...", None)
    managers_map = await database.get_all_managers_by_restaurant()
    if not managers_map:
        await query.answer("Список менеджеров пуст.", show_alert=True)
        return await manage_managers_start(update, context)

    buttons = []
    for res_code_suffix, managers in sorted(managers_map.items()):
        res_name = next((name for name, code in RESTAURANT_OPTIONS if code.endswith(res_code_suffix)), res_code_suffix)
        for manager in managers:
            user_mention = manager.get('full_name', f"User {manager['user_id']}")
            button_text = f"❌ {html.escape(user_mention)} ({html.escape(res_name)})"
            buttons.append([InlineKeyboardButton(button_text,
                                                 callback_data=f"admin_remove_mgr_{manager['user_id']}_{res_code_suffix}")])
    buttons.append([
        InlineKeyboardButton("⬅️ Назад", callback_data="admin_manage_managers"),
    ])
    await edit_admin_message(query, "Выберите менеджера для удаления:", InlineKeyboardMarkup(buttons))
    return AdminState.AWAIT_REMOVAL_ID


async def remove_manager_selected(update: Update, context: ContextTypes.DEFAULT_TYPE) -> AdminState:
    query = update.callback_query
    await safe_answer_callback_query(query)
    _, _, _, user_id_str, res_code = query.data.split('_')
    await database.remove_manager(int(user_id_str), res_code)
    await set_user_commands(int(user_id_str), context.bot)
    await query.answer("Менеджер удален.", show_alert=True)
    return await remove_manager_start(update, context)


async def add_manager_start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> AdminState:
    query = update.callback_query
    await safe_answer_callback_query(query)
    button_rows = [[InlineKeyboardButton(text, callback_data=data) for text, data in RESTAURANT_OPTIONS[i:i + 2]] for i
                   in range(0, len(RESTAURANT_OPTIONS), 2)]
    button_rows.append([
        InlineKeyboardButton("⬅️ Назад", callback_data="admin_manage_managers"),
    ])
    await edit_admin_message(query, "Шаг 1: Выберите ресторан:", InlineKeyboardMarkup(button_rows))
    return AdminState.CHOOSE_ADD_RESTAURANT


async def add_restaurant_chosen(update: Update, context: ContextTypes.DEFAULT_TYPE) -> AdminState:
    query = update.callback_query
    await safe_answer_callback_query(query)
    context.user_data['admin_add_res_code'] = query.data.replace("res_", "")
    context.user_data['admin_add_res_name'] = next((n for n, c in RESTAURANT_OPTIONS if c == query.data), "?")
    text = (f"Ресторан: «{context.user_data['admin_add_res_name']}».\n\n"
            f"<b>Шаг 2:</b> Перешлите сообщение, введите ID или @username.\n\n"
            f"<i>Примечание: поиск по @username сработает, только если пользователь ранее уже запускал бота.</i>")

    keyboard = InlineKeyboardMarkup([
        [InlineKeyboardButton("⬅️ Назад к выбору ресторана", callback_data="admin_add_manager_start")],
    ])
    await edit_admin_message(query, text, keyboard)
    return AdminState.AWAIT_ADD_ID


async def add_id_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    await send_or_edit_message(update, context, "Загрузка...")

    user_id_to_add = await get_id_from_input(update, context)

    if update.message:
        try:
            await update.message.delete()
        except (BadRequest, Forbidden):
            pass

    if user_id_to_add is None:
        return AdminState.AWAIT_ADD_ID

    res_code = context.user_data.get('admin_add_res_code')
    res_name = context.user_data.get('admin_add_res_name')

    if not res_code:
        await admin_panel_start(update, context)
        return ConversationHandler.END

    if await database.is_manager_in_restaurant(user_id_to_add, res_code):
        await send_or_edit_message(update, context, "⚠️ Пользователь уже является менеджером этого ресторана.",
                                   get_back_to_admin_menu_keyboard())
        return AdminState.MENU

    try:
        user_chat = await context.bot.get_chat(user_id_to_add)
        full_name = f"{user_chat.first_name or ''} {user_chat.last_name or ''}".strip() or "Имя не получено"
        await database.add_manager(user_id_to_add, res_code, full_name, user_chat.username)
        await set_user_commands(user_id_to_add, context.bot)
        text = f"✅ <b>{html.escape(full_name)}</b> добавлен в менеджеры «{res_name}»."
        keyboard = InlineKeyboardMarkup(
            [[InlineKeyboardButton("⬅️ Назад в меню", callback_data=settings.CALLBACK_ADMIN_BACK)]])
        await send_or_edit_message(update, context, text, keyboard)
        logger.info(f"Admin {update.effective_user.id} добавил менеджера {user_id_to_add} в ресторан {res_code}")
    except (BadRequest, Forbidden) as e:
        await send_or_edit_message(update, context, f"Ошибка: не удалось найти пользователя {user_id_to_add}. {e}",
                                   get_back_to_admin_menu_keyboard())

    context.user_data.clear()
    return AdminState.MENU


async def _get_pending_candidates_content(context: ContextTypes.DEFAULT_TYPE) -> tuple[str, InlineKeyboardMarkup]:
    pending_tasks = await database.get_all_pending_feedback()
    if not pending_tasks:
        keyboard = InlineKeyboardMarkup(
            [[InlineKeyboardButton("⬅️ Назад", callback_data=settings.CALLBACK_ADMIN_BACK)]])
        return "Нет кандидатов на рассмотрении.", keyboard

    candidates_by_restaurant = defaultdict(list)
    for task in pending_tasks:
        candidates_by_restaurant[task['restaurant_name']].append(task)

    context.application.bot_data['admin_pending_tasks'] = {task['id']: task for task in pending_tasks}

    text_parts = ["<b>Кандидаты на рассмотрении:</b>\nВыберите кандидата, чтобы выполнить действие."]
    buttons = []
    for restaurant_name, candidates in sorted(candidates_by_restaurant.items()):
        text_parts.append(f"\n<b>📍 {html.escape(restaurant_name)}:</b>")
        for candidate in candidates:
            button = InlineKeyboardButton(f"👤 {candidate['name']}", callback_data=f"cand_act_{candidate['id']}")
            buttons.append([button])

    buttons.append([InlineKeyboardButton("⬅️ Назад", callback_data=settings.CALLBACK_ADMIN_BACK)])
    return "\n".join(text_parts), InlineKeyboardMarkup(buttons)


async def admin_list_pending_candidates(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await safe_answer_callback_query(query)
    text, keyboard = await _get_pending_candidates_content(context)
    await edit_admin_message(query, text, keyboard)
    return AdminState.AWAIT_CANDIDATE_ACTION


async def handle_candidate_action_menu(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await safe_answer_callback_query(query)
    feedback_id = query.data.replace("cand_act_", "")

    all_tasks = context.application.bot_data.get('admin_pending_tasks', {})
    task = all_tasks.get(feedback_id)

    if not task:
        await query.answer("Задача этого кандидата уже неактуальна.", show_alert=True)
        return await admin_list_pending_candidates(update, context)

    candidate_name = task.get('candidate_name', 'кандидата')
    text = f"Действия для кандидата:\n<b>{html.escape(candidate_name)}</b>"

    keyboard = InlineKeyboardMarkup([
        [InlineKeyboardButton("✍️ Оставить ОС", callback_data=f"fb_{feedback_id}")],
        [InlineKeyboardButton("❌ Удалить", callback_data=f"cand_del_{feedback_id}")],
        [InlineKeyboardButton("⬅️ Назад к списку", callback_data="admin_pending_candidates")]
    ])
    await edit_admin_message(query, text, keyboard)
    return AdminState.AWAIT_CANDIDATE_ACTION


async def handle_admin_delete_candidate(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await safe_answer_callback_query(query)
    feedback_id = query.data.replace("cand_del_", "")

    all_tasks = context.application.bot_data.get('admin_pending_tasks', {})
    task = all_tasks.get(feedback_id)

    if not task or 'candidate_id' not in task['job_data']:
        await query.answer("Кандидат не найден.", show_alert=True)
        return AdminState.AWAIT_CANDIDATE_ACTION

    candidate_id = task['job_data']['candidate_id']
    keyboard = InlineKeyboardMarkup([
        [InlineKeyboardButton("✅ Да, удалить", callback_data=f"cand_del_confirm_{candidate_id}")],
        [InlineKeyboardButton("❌ Отмена", callback_data="admin_pending_candidates")]])
    await edit_admin_message(query, f"Удалить кандидата ID {candidate_id}?", keyboard)
    return AdminState.AWAIT_CANDIDATE_ACTION


async def handle_admin_delete_confirmation(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    await safe_answer_callback_query(query)
    candidate_id = int(query.data.replace("cand_del_confirm_", ""))

    await database.move_pending_feedback_to_history(
        candidate_id=candidate_id,
        decision_by_id=query.from_user.id,
        status="Удалено администратором"
    )

    logger.info(f"Admin {query.from_user.id} deleted feedback for candidate {candidate_id}.")
    await query.answer("Кандидат удален и перемещен в архив.", show_alert=True)
    await admin_list_pending_candidates(update, context)


async def show_stats(update: Update, context: ContextTypes.DEFAULT_TYPE) -> AdminState:
    query = update.callback_query
    await safe_answer_callback_query(query)
    await edit_admin_message(query, "Загрузка статистики...", None)
    stats_by_res = await database.get_survey_counts_by_restaurant()
    if not stats_by_res:
        await edit_admin_message(query, "Статистика пуста.", get_back_to_admin_menu_keyboard())
        return AdminState.MENU
    res_map = {code.split('_')[-1]: name for name, code in RESTAURANT_OPTIONS};
    res_map['N/A'] = "Не указан"
    survey_names = {'recruitment': 'Анкеты', 'onboarding': 'Онбординг', 'manager_feedback': 'ОС менеджера',
                    'candidate_feedback': 'ОС кандидата', 'exit': 'Exit-интервью', 'climate': 'Замер климата'}
    report = ["<b>📈 Статистика по опросам:</b>\n"]
    totals = defaultdict(int)
    for res_code in sorted(stats_by_res.keys(), key=lambda x: res_map.get(x, x)):
        report.append(f"\n<b>📍 {html.escape(res_map.get(res_code, res_code))}:</b>")
        for key, count in stats_by_res[res_code].items():
            if count > 0:
                report.append(f"  - {survey_names.get(key, key)}: <b>{count}</b>")
                totals[key] += count
    report.append("\n\n<b>📊 Итого:</b>")
    for key, total in totals.items(): report.append(f"  - {survey_names.get(key, key)}: <b>{total}</b>")
    await edit_admin_message(query, "\n".join(report), get_back_to_admin_menu_keyboard())
    return AdminState.MENU


async def broadcast_climate_start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> AdminState:
    query = update.callback_query
    await safe_answer_callback_query(query)

    if context.bot_data.get('broadcast_in_progress', False):
        await query.answer("❗️ Рассылка уже запущена другим администратором.", show_alert=True)
        return AdminState.MENU

    active_ids = await database.get_active_employees()
    if not active_ids:
        await edit_admin_message(query, "Не найдено активных сотрудников.", get_back_to_admin_menu_keyboard())
        return AdminState.MENU
    context.user_data['broadcast_list'] = active_ids
    keyboard = InlineKeyboardMarkup([
        [InlineKeyboardButton(f"✅ Да, запустить ({len(active_ids)} чел.)", callback_data="admin_broadcast_confirm")],
        [InlineKeyboardButton("❌ Отмена", callback_data="admin_broadcast_cancel")]])
    await edit_admin_message(query,
                             f"Запустить опрос «Замер климата» для <b>{len(active_ids)}</b> активных сотрудников?",
                             keyboard)
    return AdminState.BROADCAST_CONFIRM


async def handle_broadcast_confirmation(update: Update, context: ContextTypes.DEFAULT_TYPE) -> AdminState:
    query = update.callback_query
    await safe_answer_callback_query(query)
    if query.data == "admin_broadcast_cancel":
        await edit_admin_message(query, "Рассылка отменена.", None)
        await asyncio.sleep(1)
        return await admin_panel_start(update, context)

    if context.bot_data.get('broadcast_in_progress', False):
        await query.answer("❗️ Рассылка уже была запущена.", show_alert=True)
        return await admin_panel_start(update, context)

    context.bot_data['broadcast_in_progress'] = True
    users = context.user_data.get('broadcast_list', [])
    if not users:
        await edit_admin_message(query, "Ошибка: список пуст.", get_back_to_admin_menu_keyboard())
        context.bot_data['broadcast_in_progress'] = False
        return AdminState.MENU

    await edit_admin_message(query, f"Начинаю рассылку для {len(users)} сотрудников...", None)
    success, fail = 0, 0
    keyboard = InlineKeyboardMarkup(
        [[InlineKeyboardButton("📊 Пройти опрос", callback_data=settings.CALLBACK_START_CLIMATE)]])
    text = "Привет! 👋 Предлагаем пройти анонимный опрос, чтобы мы лучше понимали климат в команде."
    for user_id in users:
        try:
            await context.bot.send_message(user_id, text, reply_markup=keyboard)
            success += 1
            await asyncio.sleep(0.1)
        except Exception:
            fail += 1
    report = f"✅ Рассылка завершена.\n\nУспешно: {success}\nНеуспешно: {fail}"
    await context.bot.send_message(update.effective_chat.id, report)
    logger.info(f"Climate survey broadcast finished. Success: {success}, Failed: {fail}")
    context.bot_data['broadcast_in_progress'] = False
    return await admin_panel_start(update, context)

--- FILE: handlers/common.py ---
import html
import logging
import time
import traceback

logger = logging.getLogger(__name__)

from telegram import Update, ReplyKeyboardRemove
from telegram.ext import ContextTypes, ConversationHandler
from telegram.constants import ParseMode
from telegram.error import BadRequest, Forbidden

from core import settings, database
from utils.helpers import (
    get_user_data_from_update,
    add_user_to_interacted,
    remove_keyboard_from_previous_message,
    send_transient_message,
    safe_answer_callback_query,
    send_new_menu_message
)


async def handle_blocked_user(user_id: int, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handles logic when a user has blocked the bot."""
    logger.warning(f"User {user_id} has blocked the bot. Aborting interaction and cleaning up data.")
    await database.delete_user_data(user_id)
    interacted_set = context.bot_data.setdefault("users_interacted", set())
    interacted_set.discard(user_id)
    return ConversationHandler.END


async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    user_id, user_name, _ = get_user_data_from_update(update)
    logger.info(f"User {user_name} ({user_id}) cancelled the conversation.")

    if context.user_data:
        context.user_data.clear()

    try:
        await remove_keyboard_from_previous_message(context, user_id)
        if update.effective_message:
            await update.effective_message.reply_text(
                "Действие отменено.", reply_markup=ReplyKeyboardRemove()
            )
    except Forbidden:
        return await handle_blocked_user(user_id, context)
    except Exception as e:
        logger.warning(f"Could not properly execute cancel for user {user_id}: {e}")

    return ConversationHandler.END


async def error_handler(update: object, context: ContextTypes.DEFAULT_TYPE) -> None:
    if isinstance(context.error, Forbidden):
        logger.warning(f"Caught a Forbidden error in the global error handler: {context.error}")
        if update and isinstance(update, Update) and update.effective_user:
            await handle_blocked_user(update.effective_user.id, context)
        return

    logger.error("Exception while handling an update:", exc_info=context.error)

    if update and isinstance(update, Update) and update.effective_chat:
        try:
            await context.bot.send_message(
                chat_id=update.effective_chat.id,
                text="Ой, что-то пошло не по плану... 🛠️\n\nНаша команда уже получила сигнал и разбирается в ситуации. Пожалуйста, попробуй начать заново через пару минут.\n\nЕсли проблема повторяется, можно отменить действие командой /cancel."
            )
        except Exception as e:
            logger.error(f"Failed to send user-facing error message: {e}")

    tb_list = traceback.format_exception(None, context.error, context.error.__traceback__)
    update_str = update.to_json() if isinstance(update, Update) else str(update)
    user_info = "N/A"
    if context.user_data and 'chat_id' in context.user_data:
        user_info = f"User/Chat ID: {context.user_data['chat_id']}"

    message = (
        f"🆘 <b>Ой, в боте что-то сломалось!</b> 🆘\n\n"
        f"<b>Пользователь:</b> {html.escape(user_info)}\n"
        f"<b>Тип ошибки:</b> <code>{html.escape(type(context.error).__name__)}</code>\n"
        f"<b>Сообщение:</b>\n<pre>{html.escape(str(context.error))}</pre>\n\n"
        f"<b>Трассировка (кратко):</b>\n"
        f"<pre>{html.escape(''.join(tb_list[-3:]))[:1000]}</pre>\n\n"
        f"<b>Update (сокращенно):</b>\n"
        f"<pre>{html.escape(update_str)[:1000]}</pre>"
    )

    if settings.ADMIN_IDS:
        for admin_id in settings.ADMIN_IDS:
            try:
                await context.bot.send_message(chat_id=admin_id, text=message, parse_mode=ParseMode.HTML)
            except Exception as e:
                logger.critical(f"CRITICAL: Failed to send error notification to admin {admin_id}: {e}")


async def update_timestamp_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if hasattr(context.application, "bot_data") and 'last_telegram_update_ts' in context.application.bot_data:
        context.application.bot_data['last_telegram_update_ts'] = time.time()


async def prompt_to_use_button(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.message:
        try:
            await update.message.delete()
        except (BadRequest, Forbidden):
            pass
    await send_transient_message(context, update.effective_chat.id,
                                 "Пожалуйста, используй кнопки для ответа. Они чуть выше ⬆️")

--- FILE: handlers/manager_feedback_flow.py ---
import html
import logging
import time
from datetime import datetime, timedelta

from telegram import Update, InlineKeyboardMarkup, InlineKeyboardButton, User
from telegram.ext import (
    ContextTypes,
    ConversationHandler,
)
from telegram.constants import ParseMode
from telegram.error import BadRequest

from models import ManagerFeedbackState, MainMenuState
from core import settings, database
from utils.helpers import (
    safe_answer_callback_query,
    add_to_sheets_queue,
    get_now,
    send_or_edit_message,
    send_transient_message,
    format_user_for_sheets,
    TIMEZONE
)
from utils.keyboards import (
    MANAGER_FEEDBACK_OPTIONS,
    get_shift_date_keyboard,
    build_inline_keyboard
)
from handlers.common import cancel
from handlers.feedback import schedule_onboarding_noshow_check

logger = logging.getLogger(__name__)


async def start_manager_feedback_flow(update: Update, context: ContextTypes.DEFAULT_TYPE) -> ManagerFeedbackState:
    query = update.callback_query
    await safe_answer_callback_query(query)

    feedback_id = context.user_data.get('feedback_id')
    if not feedback_id:
        await query.answer("Произошла ошибка, не удалось найти задачу. Попробуйте снова.", show_alert=True)
        return MainMenuState.MAIN

    feedback_task = await database.get_pending_feedback_by_id(feedback_id)
    if not feedback_task:
        await query.answer("Эта задача уже неактуальна.", show_alert=True)
        return MainMenuState.MAIN

    context.user_data["job_data"] = feedback_task.get("job_data", {})
    context.user_data["candidate_id"] = feedback_task.get("candidate_id")
    candidate_name = feedback_task.get("candidate_name", "Неизвестный кандидат")

    keyboard = build_inline_keyboard(MANAGER_FEEDBACK_OPTIONS, 1)

    text = f"Оценка кандидата: <b>{html.escape(candidate_name)}</b>.\n\nПожалуйста, поделись своим решением:"
    await send_or_edit_message(update, context, text, keyboard)

    return ManagerFeedbackState.AWAITING_DECISION


async def decision_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> ManagerFeedbackState:
    query = update.callback_query
    await safe_answer_callback_query(query)

    base_callback = query.data
    status_text = next((name for name, data in MANAGER_FEEDBACK_OPTIONS if data == base_callback), "Неизвестно")
    status_code_part = base_callback.replace(settings.CALLBACK_MGR_FEEDBACK_PREFIX, "")

    context.user_data["feedback_status_code"] = status_code_part
    context.user_data["feedback_status_text"] = status_text.strip("✅🤔❌⛔️ ")

    if status_code_part == "onboarding":
        keyboard = get_shift_date_keyboard()
        text = (f"Отлично! Статус кандидата: <b>{context.user_data['feedback_status_text']}</b>.\n\n"
                "Теперь укажи дату первого дня ознакомительной смены:")
        await send_or_edit_message(update, context, text, keyboard)
        return ManagerFeedbackState.AWAITING_SHIFT_DATE
    else:
        text = (f"Твой выбор: <b>{context.user_data['feedback_status_text']}</b>.\n\n"
                "Пожалуйста, напиши краткую причину такого решения. Это очень важно для нас.")
        await send_or_edit_message(update, context, text, None)
        return ManagerFeedbackState.AWAITING_REASON


async def shift_date_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> ManagerFeedbackState:
    query = update.callback_query
    await safe_answer_callback_query(query)

    if query.data == "shift_date_other":
        text = "Пожалуйста, введи дату в формате ДД.ММ.ГГГГ (например, 25.12.2024):"
        await send_or_edit_message(update, context, text, None)
        return ManagerFeedbackState.AWAITING_MANUAL_SHIFT_DATE
    else:
        date_str = query.data.replace("shift_date_", "")
        context.user_data["shift_date"] = date_str
        text = (f"Дата смены: <b>{datetime.fromisoformat(date_str).strftime('%d %B %Y')}</b>.\n\n"
                "Теперь укажи время смены (например, 10-16 или 17-23).")
        await send_or_edit_message(update, context, text, None)
        return ManagerFeedbackState.AWAITING_SHIFT_TIME


async def manual_shift_date_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> ManagerFeedbackState:
    try:
        parsed_date = datetime.strptime(update.message.text, "%d.%m.%Y").date()
        context.user_data["shift_date"] = parsed_date.isoformat()
        text = (f"Дата смены: <b>{parsed_date.strftime('%d %B %Y')}</b>.\n\n"
                "Теперь укажи время смены (например, 10-16 или 17-23).")
        await send_or_edit_message(update, context, text)
        return ManagerFeedbackState.AWAITING_SHIFT_TIME
    except ValueError:
        await send_transient_message(context, update.effective_chat.id,
                                     "Неверный формат даты. Пожалуйста, введи в формате ДД.ММ.ГГГГ.")
        await update.message.delete()
        return ManagerFeedbackState.AWAITING_MANUAL_SHIFT_DATE


async def shift_time_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> ManagerFeedbackState:
    context.user_data["shift_time"] = update.message.text
    keyboard = InlineKeyboardMarkup([[
        InlineKeyboardButton("Пропустить комментарий", callback_data="skip_comment")
    ]])
    text = "Отлично. Если хочешь оставить комментарий, напиши его. " \
           "Если нет, просто нажми /skip или кнопку ниже."
    await send_or_edit_message(update, context, text, keyboard)
    return ManagerFeedbackState.AWAITING_COMMENT


async def comment_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    context.user_data["feedback_comment"] = update.message.text
    await send_or_edit_message(update, context, "Спасибо, твоя обратная связь сохранена! 🙏")
    await process_manager_feedback(context, update.effective_user)
    return ConversationHandler.END


async def skip_comment(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    user = update.effective_user
    if query:
        await safe_answer_callback_query(query)
    context.user_data["feedback_comment"] = "Не указан"
    text = "Спасибо, твоя обратная связь сохранена! 🙏"
    await send_or_edit_message(update, context, text)
    await process_manager_feedback(context, user)
    return ConversationHandler.END


async def process_manager_feedback(context: ContextTypes.DEFAULT_TYPE, responding_user: User):
    job_data = context.user_data.get("job_data", {})
    restaurant_code = job_data.get("interview_restaurant_code")
    candidate_id = job_data.get("candidate_id")
    candidate_name = job_data.get("candidate_name")
    status = context.user_data.get("feedback_status_text")
    status_code = context.user_data.get("feedback_status_code")
    timestamp = get_now().strftime("%Y-%m-%d %H:%M:%S")

    if not candidate_id:
        logger.error(f"CRITICAL: No candidate_id found in user_data during feedback processing for user {responding_user.id}")
        return

    await database.log_survey_completion('manager_feedback', responding_user.id, restaurant_code)
    all_tasks_for_candidate = await database.get_all_pending_feedback_for_candidate(candidate_id)
    manager_details = await database.get_manager_details(responding_user.id)

    manager_link = format_user_for_sheets(
        responding_user.id,
        manager_details.get('full_name') if manager_details else responding_user.full_name,
        manager_details.get('username') if manager_details else responding_user.username
    )

    reply_text = ""
    is_final_decision = status_code in ["onboarding", "refused", "unsuitable"]

    if status_code == "onboarding":
        shift_date_iso = context.user_data.get("shift_date", "Не указана")
        shift_date_str = "Не указана"
        if shift_date_iso != "Не указана":
            try:
                shift_date_dt = datetime.fromisoformat(shift_date_iso)
                shift_date_str = shift_date_dt.strftime('%d %B %Y')

                if context.job_queue:
                    check_time_naive = datetime.combine(shift_date_dt.date(), datetime.max.time())
                    check_time_aware = check_time_naive.replace(tzinfo=TIMEZONE) + timedelta(days=1)
                    job_context = {"candidate_id": candidate_id}
                    context.job_queue.run_once(
                        schedule_onboarding_noshow_check,
                        when=check_time_aware,
                        data=job_context,
                        name=f"onboarding_noshow_{candidate_id}"
                    )
                    logger.info(f"Scheduled onboarding no-show check for {candidate_id} on {check_time_aware}")
            except (ValueError, TypeError):
                shift_date_str = shift_date_iso

        shift_time = context.user_data.get("shift_time", "Не указано")
        comment = context.user_data.get("feedback_comment", "Не указан")
        reason = "Принят на смену"

        row_data = [timestamp, candidate_name, candidate_id, status, reason, manager_link, shift_date_iso, shift_time, comment]
        await add_to_sheets_queue(settings.MANAGER_FEEDBACK_SHEET_NAME, row_data)

        reply_text_parts = [
            f"✅ <b>Статус кандидата обновлен:</b> {html.escape(status)}",
            f"🗓 <b>Дата смены:</b> {html.escape(shift_date_str)}",
            f"⏰ <b>Время:</b> {html.escape(shift_time)}",
        ]
        if comment and comment != "Не указан":
            reply_text_parts.append(f"💬 <b>Комментарий:</b> {html.escape(comment)}")
        reply_text_parts.append(f"<i>Решение принял(а): {responding_user.mention_html()}</i>")
        reply_text = "\n".join(reply_text_parts)

        context.bot_data.setdefault('candidate_check_info', {})[candidate_id] = {
            "position": job_data.get('position', '—'),
            "full_name": job_data.get('full_name', '—'),
            "address": job_data.get('address', '—'),
            "phone": job_data.get('phone', '—'),
            "timestamp": time.time()
        }
        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("📄 Проверка кандидата", callback_data=f"check_candidate_{candidate_id}")]
        ])
        await context.bot.send_message(chat_id=responding_user.id, text="Кандидат одобрен. Нажмите кнопку ниже для получения данных для проверки.", reply_markup=keyboard)
    else:
        reason = context.user_data.get("feedback_reason", "Не указана")
        row_data = [timestamp, candidate_name, candidate_id, status, reason, manager_link, "", "", ""]
        await add_to_sheets_queue(settings.MANAGER_FEEDBACK_SHEET_NAME, row_data)

        if status_code in ["refused", "unsuitable"]:
            logger.info(f"Candidate {candidate_id} was refused/unsuitable. Data will be deleted.")
            await database.delete_user_data(candidate_id)

        reply_text = (
            f"❗️ <b>Статус кандидата обновлен:</b> {html.escape(status)}\n"
            f"<b>Причина:</b> {html.escape(reason)}\n"
            f"<i>Решение принял(а): {responding_user.mention_html()}</i>"
        )

    if all_tasks_for_candidate:
        if is_final_decision:
            await database.move_pending_feedback_to_history(candidate_id, responding_user.id, status)
            logger.info(f"Final decision made for candidate {candidate_id}. All pending tasks moved to history.")
        else:
            logger.info(f"Intermediate status '{status}' for candidate {candidate_id}. Tasks remain for now.")

        for task in all_tasks_for_candidate:
            try:
                await context.bot.send_message(
                    chat_id=task['manager_id'],
                    text=reply_text,
                    reply_to_message_id=task['message_id'],
                    parse_mode=ParseMode.HTML,
                    allow_sending_without_reply=True
                )
                if is_final_decision and task['manager_id'] != responding_user.id:
                    original_message = await context.bot.edit_message_reply_markup(
                        chat_id=task['manager_id'],
                        message_id=task['message_id'],
                        reply_markup=None
                    )
                    await context.bot.edit_message_text(
                         text=f"{original_message.text}\n\n<i>(Обработано: {responding_user.mention_html()})</i>",
                         chat_id=task['manager_id'],
                         message_id=task['message_id'],
                         parse_mode=ParseMode.HTML
                    )
            except BadRequest as e:
                if "message to reply not found" not in str(e).lower():
                    logger.warning(f"Could not send feedback update to manager {task['manager_id']} (BadRequest): {e}")
            except Exception as e:
                logger.error(f"Failed to send feedback reply to manager {task['manager_id']}: {e}")

--- FILE: handlers/manager.py ---
import html
import logging
import time
import asyncio

from telegram import Update, ReplyKeyboardRemove, InlineKeyboardMarkup, InlineKeyboardButton
from telegram.ext import (
    ContextTypes,
    ConversationHandler,
    CommandHandler,
    MessageHandler,
    CallbackQueryHandler,
    filters,
)
from telegram.constants import ParseMode

from models import ManagerRegistrationState
from core import settings, database, stickers
from utils.helpers import (
    get_user_data_from_update,
    safe_answer_callback_query,
    send_or_edit_message,
    send_transient_message,
    add_user_to_interacted,
    set_user_commands
)
from utils.keyboards import (
    RESTAURANT_OPTIONS,
    build_inline_keyboard
)
from handlers.common import cancel, prompt_to_use_button

logger = logging.getLogger(__name__)

AWAIT_REJECTION_REASON = -1


async def register_manager_start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int | ManagerRegistrationState:
    user = update.effective_user
    if not user:
        return ConversationHandler.END

    await add_user_to_interacted(user.id, context)
    context.user_data.clear()

    if user.id in settings.ADMIN_IDS:
        if update.message:
            await update.message.reply_text(
                "Привет! Как администратор, ты уже имеешь все права. Для управления используй команду /admin.",
                reply_markup=ReplyKeyboardRemove()
            )
        return ConversationHandler.END

    keyboard = build_inline_keyboard(RESTAURANT_OPTIONS, columns=2)
    text = ("Привет! 👋 Добро пожаловать в систему регистрации менеджеров.\n\n"
            "Пожалуйста, выбери ресторан, за которым ты будешь закреплен(а), чтобы получать анкеты кандидатов 👇")

    if update.message:
        sent_message = await update.message.reply_text(text, reply_markup=keyboard, parse_mode=ParseMode.HTML)
        context.user_data[settings.ACTIVE_MESSAGE_ID_KEY] = sent_message.message_id
    elif update.callback_query:
        await send_or_edit_message(update, context, text, keyboard)

    context.user_data['chat_id'] = update.effective_chat.id

    return ManagerRegistrationState.CHOOSE_RESTAURANT


async def restaurant_chosen(update: Update, context: ContextTypes.DEFAULT_TYPE) -> ManagerRegistrationState:
    query = update.callback_query
    await safe_answer_callback_query(query)

    if not query or not query.data:
        return ConversationHandler.END

    restaurant_code_suffix = query.data.replace("res_", "")
    restaurant_name = next((name for name, code in RESTAURANT_OPTIONS if code == query.data), "Неизвестный ресторан")

    context.user_data['reg_restaurant_code'] = restaurant_code_suffix
    context.user_data['reg_restaurant_name'] = restaurant_name

    text = "Отлично. Теперь, пожалуйста, напиши свои настоящие <b>Фамилию и Имя</b>."
    await send_or_edit_message(update, context, text)
    return ManagerRegistrationState.AWAIT_FULL_NAME


async def full_name_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    full_name = update.message.text
    if len(full_name.split()) < 2:
        await send_transient_message(context, update.effective_chat.id, "Пожалуйста, введи и Фамилию, и Имя.")
        await update.message.delete()
        return ManagerRegistrationState.AWAIT_FULL_NAME

    user = update.effective_user
    user_id = user.id
    username = user.username
    restaurant_code = context.user_data['reg_restaurant_code']
    restaurant_name = context.user_data['reg_restaurant_name']

    await database.add_pending_manager(
        user_id, restaurant_code, restaurant_name, full_name, username, time.time()
    )

    text = ("✅ Отлично! Твоя заявка принята и отправлена администратору на рассмотрение.\n\n"
            "Как только ее одобрят, ты получишь уведомление. Спасибо!")
    await send_or_edit_message(update, context, text)

    if settings.ADMIN_IDS:
        approval_keyboard = InlineKeyboardMarkup([
            [
                InlineKeyboardButton("✅ Одобрить", callback_data=f"{settings.CALLBACK_MGR_APPROVE_PREFIX}{user_id}"),
                InlineKeyboardButton("❌ Отклонить", callback_data=f"{settings.CALLBACK_MGR_REJECT_PREFIX}{user_id}")
            ]
        ])
        message = (
            f"🔔 <b>Заявка на регистрацию менеджера</b> 🔔\n\n"
            f"Пользователь: <b>{html.escape(full_name)} (@{username})</b> (<code>{user_id}</code>)\n"
            f"Хочет стать менеджером ресторана: <b>{html.escape(restaurant_name)}</b>"
        )
        for admin_id in settings.ADMIN_IDS:
            try:
                await context.bot.send_sticker(chat_id=admin_id, sticker=stickers.CONTACT_MANAGER)
                await asyncio.sleep(0.3)
                await context.bot.send_message(admin_id, message, reply_markup=approval_keyboard,
                                               parse_mode=ParseMode.HTML)
            except Exception as e:
                logger.error(f"Failed to send manager approval request to admin {admin_id}: {e}")

    context.user_data.clear()
    return ConversationHandler.END


async def handle_manager_approval(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int | None:
    query = update.callback_query
    await safe_answer_callback_query(query)

    if not query or not query.data or not query.from_user:
        return

    admin_user = query.from_user
    approve_prefix = settings.CALLBACK_MGR_APPROVE_PREFIX
    reject_prefix = settings.CALLBACK_MGR_REJECT_PREFIX

    if query.data.startswith(approve_prefix):
        target_user_id = int(query.data[len(approve_prefix):])

        pending_request = await database.get_pending_manager(target_user_id)
        if not pending_request:
            await query.edit_message_text(f"{query.message.text}\n\n<i>Заявка уже была обработана.</i>",
                                          parse_mode=ParseMode.HTML, reply_markup=None)
            await query.answer("Заявка уже была обработана.", show_alert=True)
            return

        restaurant_code = pending_request['restaurant_code']
        restaurant_name = pending_request['restaurant_name']
        full_name = pending_request['full_name']
        username = pending_request['username']

        await database.remove_pending_manager(target_user_id)
        await database.add_manager(target_user_id, restaurant_code, full_name, username)

        logger.info(f"Admin {admin_user.id} approved manager {target_user_id} for restaurant {restaurant_code}.")
        await context.bot.send_message(target_user_id,
                                       f"🎉 Поздравляем! Твоя заявка на роль менеджера в ресторане «{restaurant_name}» одобрена. Теперь ты будешь получать анкеты кандидатов.")
        await query.edit_message_text(
            f"✅ <b>Заявка ОДОБРЕНА</b>\n\n"
            f"Пользователь: <b>{html.escape(full_name)} (@{username})</b>\n"
            f"Ресторан: <b>{html.escape(restaurant_name)}</b>\n"
            f"<i>Обработал(а): {admin_user.mention_html()}</i>",
            parse_mode=ParseMode.HTML, reply_markup=None
        )
        await set_user_commands(target_user_id, context.bot)

    elif query.data.startswith(reject_prefix):
        target_user_id = int(query.data[len(reject_prefix):])

        if not await database.get_pending_manager(target_user_id):
            await query.edit_message_text(f"{query.message.text}\n\n<i>Заявка уже была обработана.</i>",
                                          parse_mode=ParseMode.HTML, reply_markup=None)
            await query.answer("Заявка уже была обработана.", show_alert=True)
            return

        context.user_data['rejection_target_id'] = target_user_id
        await query.edit_message_text(
            "Пожалуйста, укажите причину отклонения. Это сообщение будет отправлено пользователю.", reply_markup=None)
        return AWAIT_REJECTION_REASON

    return ConversationHandler.END


async def rejection_reason_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    reason = update.message.text
    admin_user = update.effective_user
    target_user_id = context.user_data.pop('rejection_target_id', None)

    if not target_user_id:
        await update.message.reply_text("Ошибка: не найден ID пользователя для отклонения.")
        return ConversationHandler.END

    pending_request = await database.get_pending_manager(target_user_id)
    if not pending_request:
        await update.message.reply_text("Заявка уже была обработана другим администратором.")
        return ConversationHandler.END

    restaurant_name = pending_request['restaurant_name']
    full_name = pending_request['full_name']
    username = pending_request['username']

    await database.remove_pending_manager(target_user_id)

    logger.info(f"Admin {admin_user.id} rejected manager {target_user_id} with reason: {reason}")

    await context.bot.send_message(
        target_user_id,
        f"😔 К сожалению, твоя заявка на роль менеджера в ресторане «{restaurant_name}» была отклонена.\n\n"
        f"<b>Причина:</b> {html.escape(reason)}"
    )

    await update.message.reply_text(
        f"❌ <b>Заявка ОТКЛОНЕНА</b>\n\n"
        f"Пользователь: <b>{html.escape(full_name)} (@{username})</b>\n"
        f"Ресторан: <b>{html.escape(restaurant_name)}</b>\n"
        f"Причина: {html.escape(reason)}\n"
        f"<i>Обработал(а): {admin_user.mention_html()}</i>",
        parse_mode=ParseMode.HTML
    )

    await set_user_commands(target_user_id, context.bot)
    return ConversationHandler.END


manager_registration_handler = ConversationHandler(
    entry_points=[
        CommandHandler("register_manager", register_manager_start),
        CallbackQueryHandler(handle_manager_approval,
                             pattern=f"^{settings.CALLBACK_MGR_APPROVE_PREFIX}|^({settings.CALLBACK_MGR_REJECT_PREFIX})")
    ],
    states={
        ManagerRegistrationState.CHOOSE_RESTAURANT: [
            CallbackQueryHandler(restaurant_chosen, pattern="^res_"),
            MessageHandler(filters.TEXT & ~filters.COMMAND, prompt_to_use_button),
        ],
        ManagerRegistrationState.AWAIT_FULL_NAME: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, full_name_received)
        ],
        AWAIT_REJECTION_REASON: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, rejection_reason_received)
        ]
    },
    fallbacks=[CommandHandler("cancel", cancel)],
    name="manager_reg_conv",
    persistent=True,
    per_message=False,
)

--- FILE: handlers/climate_survey.py ---
import html
import logging
from enum import Enum

from telegram import Update, ReplyKeyboardRemove, InlineKeyboardMarkup, InlineKeyboardButton
from telegram.ext import (
    ContextTypes,
    ConversationHandler,
    CommandHandler,
    MessageHandler,
    CallbackQueryHandler,
    filters,
)
from telegram.constants import ParseMode

from models import ClimateState
from core import settings, database
from utils.helpers import (
    get_user_data_from_update,
    safe_answer_callback_query,
    send_or_edit_message,
    add_to_sheets_queue,
    get_now
)
from utils.keyboards import (
    RESTAURANT_OPTIONS,
    GENDER_OPTIONS,
    EXIT_POSITION_OPTIONS,
    YES_NO_OPTIONS_CLIMATE,
    YES_NO_MAYBE_OPTIONS,
    build_inline_keyboard
)
from handlers.common import cancel, prompt_to_use_button

logger = logging.getLogger(__name__)


async def start_climate_survey_flow(update: Update, context: ContextTypes.DEFAULT_TYPE) -> ClimateState:
    query = update.callback_query
    await safe_answer_callback_query(query)
    context.user_data.clear()
    context.user_data['_in_climate_survey'] = True
    context.user_data['chat_id'] = query.message.chat_id

    greeting_text = (
        "Привет! Мы стремимся сделать «Марчеллис» лучшим местом для работы и профессионального роста. 🚀\n\n"
        "Успех нашей компании — это заслуга всей команды, и твое мнение играет в этом ключевую роль.\n\n"
        "Помоги нам стать ещё лучше! Пройди, пожалуйста, этот небольшой <b>анонимный опрос</b>. "
        "Твои честные ответы — это ценный вклад в наше общее развитие.")
    await send_or_edit_message(update, context, greeting_text, None)

    keyboard = InlineKeyboardMarkup([
        [InlineKeyboardButton("Да", callback_data="climate_employed_yes")],
        [InlineKeyboardButton("Нет", callback_data="climate_employed_no")],
    ])
    message_text = "Для начала, подскажи, пожалуйста, <b>работаешь ли ты сейчас в компании?</b>"
    await send_or_edit_message(update, context, message_text, keyboard)

    return ClimateState.AWAIT_EMPLOYMENT_STATUS


async def climate_employment_status_selected(update: Update, context: ContextTypes.DEFAULT_TYPE) -> ClimateState | int:
    query = update.callback_query
    await safe_answer_callback_query(query)

    if query.data == "climate_employed_no":
        await send_or_edit_message(update, context, "Спасибо за честность. Этот опрос предназначен для действующих сотрудников. Хорошего дня!")
        context.user_data.clear()
        return ConversationHandler.END

    keyboard = build_inline_keyboard(RESTAURANT_OPTIONS, columns=2)
    message_text = "Отлично! Тогда начнем.\n\n<b>Вопрос 1/17</b>\nВ каком <b>ресторане</b> ты работаешь?"
    await send_or_edit_message(update, context, message_text, keyboard)
    return ClimateState.RESTAURANT


async def climate_restaurant_selected(update: Update, context: ContextTypes.DEFAULT_TYPE) -> ClimateState:
    query = update.callback_query
    await safe_answer_callback_query(query)
    restaurant = next((b[0] for b in RESTAURANT_OPTIONS if b[1] == query.data), "N/A")
    restaurant_code = query.data.replace("res_", "")
    context.user_data["climate_restaurant"] = restaurant
    context.user_data["climate_restaurant_code"] = restaurant_code

    keyboard = build_inline_keyboard(GENDER_OPTIONS, columns=2)
    text = f"Ресторан: <b>{html.escape(restaurant)}</b>.\n\n<b>Вопрос 2/17</b>\nУкажи, пожалуйста, свой <b>пол</b>:"
    await send_or_edit_message(update, context, text, keyboard)
    return ClimateState.GENDER


async def climate_gender_selected(update: Update, context: ContextTypes.DEFAULT_TYPE) -> ClimateState:
    query = update.callback_query
    await safe_answer_callback_query(query)
    gender = next((b[0] for b in GENDER_OPTIONS if b[1] == query.data), "N/A")
    context.user_data["climate_gender"] = gender.replace('👨', '').replace('👩', '').strip()

    keyboard = build_inline_keyboard(EXIT_POSITION_OPTIONS, columns=2)
    text = "<b>Вопрос 3/17</b>\nУкажи, пожалуйста, свою <b>должность</b>:"
    await send_or_edit_message(update, context, text, keyboard)
    return ClimateState.POSITION


async def climate_position_selected(update: Update, context: ContextTypes.DEFAULT_TYPE) -> ClimateState:
    query = update.callback_query
    await safe_answer_callback_query(query)
    position = next((b[0] for b in EXIT_POSITION_OPTIONS if b[1] == query.data), "N/A")
    context.user_data["climate_position"] = position

    keyboard = build_inline_keyboard(YES_NO_OPTIONS_CLIMATE, columns=2)
    text = f"Должность: <b>{html.escape(position)}</b>.\n\n<b>Вопрос 4/17</b>\nГотов(а) ли ты <b>порекомендовать</b> нашу компанию как работодателя друзьям или близким?"
    await send_or_edit_message(update, context, text, keyboard)
    return ClimateState.RECOMMEND


async def climate_recommend_selected(update: Update, context: ContextTypes.DEFAULT_TYPE) -> ClimateState:
    query = update.callback_query
    await safe_answer_callback_query(query)
    recommend = "Да" if query.data == "climate_yes" else "Нет"
    context.user_data["climate_recommend"] = recommend

    text = f"Твой ответ: <b>{html.escape(recommend)}</b>.\n\n<b>Вопрос 5/17</b>\n<b>Почему</b> ты так считаешь? (кратко)"
    await send_or_edit_message(update, context, text)
    return ClimateState.RECOMMEND_REASON


async def climate_recommend_reason_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> ClimateState:
    context.user_data["climate_recommend_reason"] = update.message.text.strip()
    keyboard = build_inline_keyboard(YES_NO_MAYBE_OPTIONS, columns=2)
    text = "Спасибо! Теперь серия коротких вопросов.\n\n" \
           "<b>Вопрос 6/17</b>\nЯ <b>знаю</b>, что от меня ожидается на работе."
    await send_or_edit_message(update, context, text, keyboard)
    return ClimateState.EXPECTATIONS


async def climate_generic_yes_no_maybe_handler(
        update: Update,
        context: ContextTypes.DEFAULT_TYPE,
        current_data_key: str,
        next_state: Enum | None,
        next_question_number: int,
        next_question_text: str,
) -> Enum | int:
    query = update.callback_query
    await safe_answer_callback_query(query)

    answer_text = next((b[0] for b in YES_NO_MAYBE_OPTIONS if b[1] == query.data), "N/A")
    context.user_data[current_data_key] = answer_text.replace('✅ ', '').replace('☑️ ', '').replace('❌ ', '').replace(
        '🚫 ', '').strip()

    if next_state:
        keyboard = build_inline_keyboard(YES_NO_MAYBE_OPTIONS, columns=2)
        text = f"<b>Вопрос {next_question_number}/17</b>\n\n{next_question_text}"
        await send_or_edit_message(update, context, text, keyboard)
        return next_state
    else:
        await climate_final_question_answered(update, context)
        return ConversationHandler.END


async def climate_expectations_selected(update: Update, context: ContextTypes.DEFAULT_TYPE) -> Enum | int:
    return await climate_generic_yes_no_maybe_handler(
        update, context, "climate_expectations", ClimateState.BEST_ABILITY, 7,
        "У меня есть возможность делать то, что я делаю <b>лучше всего</b> 💪",
    )


async def climate_best_ability_selected(update: Update, context: ContextTypes.DEFAULT_TYPE) -> Enum | int:
    return await climate_generic_yes_no_maybe_handler(
        update, context, "climate_best_ability", ClimateState.PRAISE, 8,
        "В последние семь дней кто-то на работе <b>похвалил</b> меня или оценил мою работу 🎉",
    )


async def climate_praise_selected(update: Update, context: ContextTypes.DEFAULT_TYPE) -> Enum | int:
    return await climate_generic_yes_no_maybe_handler(
        update, context, "climate_praise", ClimateState.DEVELOPMENT_CARE, 9,
        "Мой руководитель или кто-то другой на работе <b>заботится</b> о моем <b>развитии</b> 🌱",
    )


async def climate_development_care_selected(update: Update, context: ContextTypes.DEFAULT_TYPE) -> Enum | int:
    return await climate_generic_yes_no_maybe_handler(
        update, context, "climate_development_care", ClimateState.OPINION, 10,
        "На работе у меня есть возможность <b>высказать свое мнение</b> 🗣️",
    )


async def climate_opinion_selected(update: Update, context: ContextTypes.DEFAULT_TYPE) -> Enum | int:
    return await climate_generic_yes_no_maybe_handler(
        update, context, "climate_opinion", ClimateState.COLLEAGUE_SUCCESS, 11,
        "Мои <b>коллеги</b> настроены на <b>успех</b> 🤝",
    )


async def climate_colleague_success_selected(update: Update, context: ContextTypes.DEFAULT_TYPE) -> Enum | int:
    return await climate_generic_yes_no_maybe_handler(
        update, context, "climate_colleague_success", ClimateState.MISSION, 12,
        "У нас на работе существует <b>миссия или цель</b>, которая меня вдохновляет 🎯",
    )


async def climate_mission_selected(update: Update, context: ContextTypes.DEFAULT_TYPE) -> Enum | int:
    return await climate_generic_yes_no_maybe_handler(
        update, context, "climate_mission", ClimateState.IMPORTANCE, 13,
        "Я чувствую, что моя работа <b>важна</b> ⭐",
    )


async def climate_importance_selected(update: Update, context: ContextTypes.DEFAULT_TYPE) -> Enum | int:
    return await climate_generic_yes_no_maybe_handler(
        update, context, "climate_importance", ClimateState.GROWTH_OPPORTUNITY, 14,
        "У меня есть возможность <b>развиваться и расти</b> в своей карьере 📈",
    )


async def climate_growth_opportunity_selected(update: Update, context: ContextTypes.DEFAULT_TYPE) -> Enum | int:
    return await climate_generic_yes_no_maybe_handler(
        update, context, "climate_growth_opportunity", ClimateState.SUPPORT, 15,
        "Я получаю <b>поддержку</b> от своего руководителя в выполнении своей работы 🤗",
    )


async def climate_support_selected(update: Update, context: ContextTypes.DEFAULT_TYPE) -> Enum | int:
    return await climate_generic_yes_no_maybe_handler(
        update, context, "climate_support", ClimateState.FRIENDS, 16,
        "На работе у меня есть <b>хорошие друзья</b> 😊",
    )


async def climate_friends_selected(update: Update, context: ContextTypes.DEFAULT_TYPE) -> Enum | int:
    return await climate_generic_yes_no_maybe_handler(
        update, context, "climate_friends", ClimateState.TEAM_PART, 17,
        "В своей работе я чувствую себя <b>частью команды</b> 👥",
    )


async def climate_team_part_selected(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    return await climate_generic_yes_no_maybe_handler(
        update, context, "climate_team_part", None, 0, ""
    )


async def climate_final_question_answered(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id, user_name, _ = get_user_data_from_update(update)
    data = context.user_data
    restaurant_code = data.get("climate_restaurant_code")
    timestamp = get_now().strftime("%Y-%m-%d %H:%M:%S")

    q_keys = [
        "restaurant", "gender", "position", "recommend", "recommend_reason", "expectations",
        "best_ability", "praise", "development_care", "opinion", "colleague_success",
        "mission", "importance", "growth_opportunity", "support", "friends", "team_part"
    ]
    q_answers = [data.get(f"climate_{key}", "N/A") for key in q_keys]
    row_data = [timestamp, user_name] + q_answers

    await add_to_sheets_queue(settings.CLIMATE_SURVEY_SHEET_NAME, row_data)
    await database.log_survey_completion('climate', user_id, restaurant_code)

    await send_or_edit_message(
        update, context,
        "✅ <b>Опрос завершен!</b>\n\nБольшое спасибо за твой вклад! 🙏 Твои ответы помогут нам сделать рабочую среду в «Марчеллис» еще лучше."
    )
    context.user_data.clear()


climate_survey_conversation_handler = ConversationHandler(
    entry_points=[CallbackQueryHandler(start_climate_survey_flow, pattern=f"^{settings.CALLBACK_START_CLIMATE}$")],
    states={
        ClimateState.AWAIT_EMPLOYMENT_STATUS: [
            CallbackQueryHandler(climate_employment_status_selected, pattern="^climate_employed_")],
        ClimateState.RESTAURANT: [CallbackQueryHandler(climate_restaurant_selected, pattern="^res_"),
                                  MessageHandler(filters.TEXT, prompt_to_use_button)],
        ClimateState.GENDER: [CallbackQueryHandler(climate_gender_selected, pattern="^climate_gender_"),
                              MessageHandler(filters.TEXT, prompt_to_use_button)],
        ClimateState.POSITION: [CallbackQueryHandler(climate_position_selected, pattern="^exit_pos_"),
                                MessageHandler(filters.TEXT, prompt_to_use_button)],
        ClimateState.RECOMMEND: [CallbackQueryHandler(climate_recommend_selected, pattern="^climate_(yes|no)$"),
                                 MessageHandler(filters.TEXT, prompt_to_use_button)],
        ClimateState.RECOMMEND_REASON: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, climate_recommend_reason_received)],
        ClimateState.EXPECTATIONS: [CallbackQueryHandler(climate_expectations_selected, pattern="^climate_q_"),
                                    MessageHandler(filters.TEXT, prompt_to_use_button)],
        ClimateState.BEST_ABILITY: [CallbackQueryHandler(climate_best_ability_selected, pattern="^climate_q_"),
                                    MessageHandler(filters.TEXT, prompt_to_use_button)],
        ClimateState.PRAISE: [CallbackQueryHandler(climate_praise_selected, pattern="^climate_q_"),
                              MessageHandler(filters.TEXT, prompt_to_use_button)],
        ClimateState.DEVELOPMENT_CARE: [CallbackQueryHandler(climate_development_care_selected, pattern="^climate_q_"),
                                        MessageHandler(filters.TEXT, prompt_to_use_button)],
        ClimateState.OPINION: [CallbackQueryHandler(climate_opinion_selected, pattern="^climate_q_"),
                               MessageHandler(filters.TEXT, prompt_to_use_button)],
        ClimateState.COLLEAGUE_SUCCESS: [
            CallbackQueryHandler(climate_colleague_success_selected, pattern="^climate_q_"),
            MessageHandler(filters.TEXT, prompt_to_use_button)],
        ClimateState.MISSION: [CallbackQueryHandler(climate_mission_selected, pattern="^climate_q_"),
                               MessageHandler(filters.TEXT, prompt_to_use_button)],
        ClimateState.IMPORTANCE: [CallbackQueryHandler(climate_importance_selected, pattern="^climate_q_"),
                                  MessageHandler(filters.TEXT, prompt_to_use_button)],
        ClimateState.GROWTH_OPPORTUNITY: [
            CallbackQueryHandler(climate_growth_opportunity_selected, pattern="^climate_q_"),
            MessageHandler(filters.TEXT, prompt_to_use_button)],
        ClimateState.SUPPORT: [CallbackQueryHandler(climate_support_selected, pattern="^climate_q_"),
                               MessageHandler(filters.TEXT, prompt_to_use_button)],
        ClimateState.FRIENDS: [CallbackQueryHandler(climate_friends_selected, pattern="^climate_q_"),
                               MessageHandler(filters.TEXT, prompt_to_use_button)],
        ClimateState.TEAM_PART: [CallbackQueryHandler(climate_team_part_selected, pattern="^climate_q_"),
                                 MessageHandler(filters.TEXT, prompt_to_use_button)],
    },
    fallbacks=[CommandHandler("cancel", cancel)],
    name="climate_survey_conv",
    persistent=True,
    per_message=False,
    conversation_timeout=settings.CONVERSATION_TIMEOUT_SECONDS
)

